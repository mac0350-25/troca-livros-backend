<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","app.rs"],"content":"use axum::{\n    http::{\n        header::{ACCEPT, AUTHORIZATION, CONTENT_TYPE},\n        Method,\n    },\n    Extension, Router,\n};\nuse sqlx::{postgres::PgPoolOptions, PgPool};\nuse std::sync::Arc;\nuse tower_http::cors::{Any, CorsLayer};\nuse utoipa::OpenApi;\nuse utoipa_swagger_ui::SwaggerUi;\n\nuse crate::{\n    config::Config,\n    docs::ApiDoc,\n    repositories::user_repository::PgUserRepository,\n    routes::{\n        auth_routes::auth_routes, \n        book_offered_routes::book_offered_routes,\n        google_book_routes::google_book_routes\n    },\n    services::{auth_service::AuthServiceImpl, password_service::create_password_service},\n};\n\n/// Configura e retorna o pool de conexão com o banco de dados\npub async fn create_database_pool(database_url: \u0026str) -\u003e Arc\u003cPgPool\u003e {\n    let pool = PgPoolOptions::new()\n        .max_connections(10)\n        .connect(database_url)\n        .await\n        .expect(\"Falha ao conectar ao banco de dados\");\n\n    Arc::new(pool)\n}\n\n/// Cria e configura o aplicativo Axum com todas as rotas\n///\n/// Esta função recebe a URL do banco de dados e configura o aplicativo\n/// É usada tanto pela aplicação principal quanto pelos testes\npub async fn create_app(database_url: \u0026str) -\u003e Router {\n    let pool = create_database_pool(database_url).await;\n    let config = Config::from_env().expect(\"Falha ao carregar configuração\");\n\n    // Criar serviço de autenticação compartilhado para todas as rotas protegidas\n    let user_repository = Arc::new(PgUserRepository::new(pool.as_ref().clone()));\n    let password_service = create_password_service();\n\n    let auth_service = Arc::new(AuthServiceImpl::new(\n        user_repository,\n        password_service,\n        config,\n    ));\n\n    // Configurar CORS\n    let cors = CorsLayer::new()\n        .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])\n        .allow_headers([AUTHORIZATION, ACCEPT, CONTENT_TYPE])\n        .allow_origin(Any);\n\n    // Definir rotas públicas (sem autenticação)\n    let public_routes = Router::new().merge(auth_routes(pool.clone()));\n\n    // Definir rotas protegidas (com autenticação)\n    let protected_routes = Router::new()\n        .merge(google_book_routes())\n        .merge(book_offered_routes(pool.clone()))\n        .layer(Extension(auth_service));\n\n    // Inicializar o router básico\n    let mut app = Router::new()\n        .merge(public_routes)\n        .merge(protected_routes)\n        .layer(cors);\n\n    let openapi = ApiDoc::openapi();\n    app = app.merge(SwaggerUi::new(\"/docs\").url(\"/api-docs/openapi.json\", openapi));\n\n    app\n}\n","traces":[{"line":27,"address":[3855894,3856555,3856004,3855824,3856044,3856224],"length":1,"stats":{"Line":56}},{"line":28,"address":[4193096,4192721,4192912,4193194,4192827],"length":1,"stats":{"Line":70}},{"line":31,"address":[4056695],"length":1,"stats":{"Line":47}},{"line":34,"address":[3932190],"length":1,"stats":{"Line":12}},{"line":41,"address":[6886957,6886944],"length":1,"stats":{"Line":56}},{"line":42,"address":[3650439],"length":1,"stats":{"Line":42}},{"line":43,"address":[3928819,3928748],"length":1,"stats":{"Line":27}},{"line":46,"address":[4189929,4190013],"length":1,"stats":{"Line":28}},{"line":47,"address":[3929036,3929108],"length":1,"stats":{"Line":29}},{"line":49,"address":[3929297,3929228],"length":1,"stats":{"Line":29}},{"line":50,"address":[3853444],"length":1,"stats":{"Line":15}},{"line":52,"address":[4390484],"length":1,"stats":{"Line":14}},{"line":56,"address":[3997070,3997267,3997377],"length":1,"stats":{"Line":43}},{"line":57,"address":[4390751],"length":1,"stats":{"Line":14}},{"line":58,"address":[3853866],"length":1,"stats":{"Line":15}},{"line":59,"address":[4391027],"length":1,"stats":{"Line":14}},{"line":62,"address":[4392723,4391035],"length":1,"stats":{"Line":15}},{"line":65,"address":[3929897,3930016,3930163,3930249],"length":1,"stats":{"Line":54}},{"line":66,"address":[3931315,3930062,3929916],"length":1,"stats":{"Line":10}},{"line":67,"address":[4011297,4011174,4012371],"length":1,"stats":{"Line":22}},{"line":68,"address":[3930217,3930305],"length":1,"stats":{"Line":23}},{"line":71,"address":[4393274,4393161,4393352,4393446],"length":1,"stats":{"Line":52}},{"line":72,"address":[3998106],"length":1,"stats":{"Line":13}},{"line":73,"address":[3854776],"length":1,"stats":{"Line":13}},{"line":74,"address":[4393453,4393382],"length":1,"stats":{"Line":23}},{"line":76,"address":[3930613],"length":1,"stats":{"Line":10}},{"line":77,"address":[4011769,4012254,4012277],"length":1,"stats":{"Line":13}},{"line":79,"address":[4392352],"length":1,"stats":{"Line":14}}],"covered":28,"coverable":28},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","config.rs"],"content":"use std::env;\nuse thiserror::Error;\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub struct Config {\n    pub database_url: String,\n    pub jwt_secret: String,\n    pub jwt_expires_in: String,\n    pub port: u16,\n}\n\n#[derive(Error, Debug)]\npub enum ConfigError {\n    #[error(\"Variável de ambiente não encontrada: {0}\")]\n    NotFound(String),\n\n    #[error(\"Falha ao converter variável de ambiente: {0}\")]\n    ParseError(String),\n}\n\nimpl Config {\n    pub fn from_env() -\u003e Result\u003cSelf, ConfigError\u003e {\n        let database_url = env::var(\"DATABASE_URL\")\n            .map_err(|_| ConfigError::NotFound(\"DATABASE_URL\".to_string()))?;\n\n        let jwt_secret =\n            env::var(\"JWT_SECRET\").map_err(|_| ConfigError::NotFound(\"JWT_SECRET\".to_string()))?;\n\n        let jwt_expires_in = env::var(\"JWT_EXPIRES_IN\").unwrap_or_else(|_| \"24h\".to_string());\n\n        let port = env::var(\"PORT\")\n            .unwrap_or_else(|_| \"50001\".to_string())\n            .parse::\u003cu16\u003e()\n            .map_err(|_| ConfigError::ParseError(\"PORT\".to_string()))?;\n\n        Ok(Self {\n            database_url,\n            jwt_secret,\n            jwt_expires_in,\n            port,\n        })\n    }\n}\n","traces":[{"line":23,"address":[7113222,7113233,7111776],"length":1,"stats":{"Line":12}},{"line":24,"address":[3746753,3746975],"length":1,"stats":{"Line":13}},{"line":25,"address":[7089213],"length":1,"stats":{"Line":0}},{"line":27,"address":[7070624,7070642],"length":1,"stats":{"Line":25}},{"line":30,"address":[7106788,7106929],"length":1,"stats":{"Line":25}},{"line":32,"address":[7090043,7089651,7089833,7089723],"length":1,"stats":{"Line":38}},{"line":33,"address":[4666240,4666256],"length":1,"stats":{"Line":0}},{"line":35,"address":[7024992,7024374,7024579],"length":1,"stats":{"Line":13}},{"line":37,"address":[7086745],"length":1,"stats":{"Line":14}},{"line":38,"address":[3747759],"length":1,"stats":{"Line":14}},{"line":39,"address":[7107433],"length":1,"stats":{"Line":13}},{"line":40,"address":[7086697],"length":1,"stats":{"Line":14}}],"covered":10,"coverable":12},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","error.rs"],"content":"use axum::{\n    http::StatusCode,\n    response::{IntoResponse, Response},\n    Json,\n};\nuse serde_json::json;\nuse thiserror::Error;\n\n#[derive(Error, Debug, Clone)]\npub enum AppError {\n    #[error(\"Erro de autenticação: {0}\")]\n    AuthError(String),\n\n    #[error(\"Erro de validação: {0}\")]\n    ValidationError(String),\n\n    #[error(\"Erro de banco de dados: {0}\")]\n    DatabaseError(String),\n\n    #[error(\"Recurso não encontrado: {0}\")]\n    NotFoundError(String),\n\n    #[error(\"Erro interno do servidor: {0}\")]\n    InternalServerError(String),\n}\n\nimpl IntoResponse for AppError {\n    fn into_response(self) -\u003e Response {\n        let (status, error_message) = match self {\n            AppError::AuthError(message) =\u003e (StatusCode::UNAUTHORIZED, message),\n            AppError::ValidationError(message) =\u003e (StatusCode::BAD_REQUEST, message),\n            AppError::DatabaseError(message) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, message),\n            AppError::NotFoundError(message) =\u003e (StatusCode::NOT_FOUND, message),\n            AppError::InternalServerError(message) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, message),\n        };\n\n        let body = Json(json!({\n            \"error\": {\n                \"message\": error_message,\n                \"status\": status.as_u16()\n            }\n        }));\n\n        (status, body).into_response()\n    }\n}\n\nimpl From\u003csqlx::Error\u003e for AppError {\n    fn from(error: sqlx::Error) -\u003e Self {\n        match error {\n            sqlx::Error::RowNotFound =\u003e {\n                AppError::NotFoundError(\"Registro não encontrado\".to_string())\n            }\n            _ =\u003e AppError::DatabaseError(error.to_string()),\n        }\n    }\n}\n","traces":[{"line":27,"address":[37655656],"length":1,"stats":{"Line":0}},{"line":28,"address":[27211757],"length":1,"stats":{"Line":8}},{"line":29,"address":[7299878,7300400],"length":1,"stats":{"Line":16}},{"line":30,"address":[36120880],"length":1,"stats":{"Line":11}},{"line":31,"address":[8558411,8558083],"length":1,"stats":{"Line":5}},{"line":32,"address":[26909860],"length":1,"stats":{"Line":0}},{"line":33,"address":[23132393,23131621,23130124,23131559,23131587,23132353],"length":1,"stats":{"Line":3}},{"line":34,"address":[11360150],"length":1,"stats":{"Line":2}},{"line":37,"address":[23134218,23134976,23132799],"length":1,"stats":{"Line":40}},{"line":38,"address":[36120969],"length":1,"stats":{"Line":2}},{"line":39,"address":[36147257],"length":1,"stats":{"Line":0}},{"line":40,"address":[37671313,37671441,37671377,37671505],"length":1,"stats":{"Line":16}},{"line":44,"address":[30508208],"length":1,"stats":{"Line":8}},{"line":48,"address":[5930499],"length":1,"stats":{"Line":0}},{"line":49,"address":[5935966],"length":1,"stats":{"Line":0}},{"line":50,"address":[19552215],"length":1,"stats":{"Line":0}},{"line":51,"address":[6228900],"length":1,"stats":{"Line":1}},{"line":52,"address":[5254591,5254610,5254997],"length":1,"stats":{"Line":0}},{"line":54,"address":[26693002,26692183,26690899],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":19},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","auth_handler.rs"],"content":"use std::sync::Arc;\n\nuse axum::{http::StatusCode, response::IntoResponse, Json};\nuse serde_json::json;\n\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, LoginUserDto};\nuse crate::services::auth_service::AuthService;\n\npub struct AuthHandler {\n    auth_service: Arc\u003cdyn AuthService\u003e,\n}\n\nimpl AuthHandler {\n    pub fn new(auth_service: Arc\u003cdyn AuthService\u003e) -\u003e Self {\n        Self { auth_service }\n    }\n\n    pub async fn register(\n        \u0026self,\n        Json(create_user_dto): Json\u003cCreateUserDto\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        let user = self.auth_service.register(create_user_dto).await?;\n\n        Ok((\n            StatusCode::CREATED,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Usuário registrado com sucesso\",\n                \"data\": user\n            })),\n        ))\n    }\n\n    pub async fn login(\n        \u0026self,\n        Json(login_dto): Json\u003cLoginUserDto\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        let token = self.auth_service.login(login_dto).await?;\n\n        Ok((\n            StatusCode::OK,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Login realizado com sucesso\",\n                \"data\": token\n            })),\n        ))\n    }\n}\n","traces":[{"line":15,"address":[3480944],"length":1,"stats":{"Line":15}},{"line":19,"address":[7413264],"length":1,"stats":{"Line":12}},{"line":23,"address":[6663086],"length":1,"stats":{"Line":31}},{"line":25,"address":[7401764],"length":1,"stats":{"Line":6}},{"line":27,"address":[7312655,7312775,7314521,7314552,7313176,7314162,7313692],"length":1,"stats":{"Line":30}},{"line":35,"address":[7413344],"length":1,"stats":{"Line":6}},{"line":39,"address":[6645118],"length":1,"stats":{"Line":18}},{"line":41,"address":[7399322],"length":1,"stats":{"Line":6}},{"line":43,"address":[7377887,7378360,7376850,7378725,7377371,7378756,7376970],"length":1,"stats":{"Line":36}}],"covered":9,"coverable":9},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","book_offered_handler.rs"],"content":"use axum::{\n    extract::{Extension, Path},\n    http::StatusCode,\n    response::IntoResponse,\n    Json,\n};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::sync::Arc;\nuse utoipa::ToSchema;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::services::book_offered_service::BookOfferedService;\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct AddBookRequest {\n    pub google_id: String,\n}\n\npub struct BookOfferedHandler {\n    book_offered_service: Arc\u003cdyn BookOfferedService\u003e,\n}\n\nimpl BookOfferedHandler {\n    pub fn new(book_offered_service: Arc\u003cdyn BookOfferedService\u003e) -\u003e Self {\n        Self {\n            book_offered_service,\n        }\n    }\n\n    pub async fn add_book_to_offered(\n        \u0026self,\n        Extension(user_id): Extension\u003cUuid\u003e,\n        Json(add_book_request): Json\u003cAddBookRequest\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        let book_offered = self\n            .book_offered_service\n            .add_book_to_offered(\u0026add_book_request.google_id, \u0026user_id)\n            .await?;\n\n        Ok((\n            StatusCode::CREATED,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Livro adicionado à lista de possuídos com sucesso\",\n                \"data\": book_offered\n            })),\n        ))\n    }\n\n    pub async fn remove_book_from_offered(\n        \u0026self,\n        Extension(user_id): Extension\u003cUuid\u003e,\n        Path(book_id): Path\u003cUuid\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        self.book_offered_service\n            .remove_book_from_offered(\u0026book_id, \u0026user_id)\n            .await?;\n\n        Ok((\n            StatusCode::OK,\n            Json(json!({\n                    \"status\": \"success\",\n                    \"message\": \"Livro removido da lista de possuídos com sucesso\"\n            })),\n        ))\n    }\n}\n","traces":[{"line":26,"address":[7204752],"length":1,"stats":{"Line":9}},{"line":32,"address":[7230048],"length":1,"stats":{"Line":2}},{"line":37,"address":[6999716,6999446,6999266,6999008,6999560,6999207],"length":1,"stats":{"Line":11}},{"line":39,"address":[7014602],"length":1,"stats":{"Line":2}},{"line":40,"address":[6926790,6926637,6926531,6926980,6926358,6926578],"length":1,"stats":{"Line":9}},{"line":42,"address":[6928614],"length":1,"stats":{"Line":2}},{"line":44,"address":[7011591,7010686,7009769,7009693,7011156,7011560,7010170],"length":1,"stats":{"Line":10}},{"line":52,"address":[7230112],"length":1,"stats":{"Line":1}},{"line":57,"address":[6993088,6991228,6991287,6991097,6991459,6991661,6991545],"length":1,"stats":{"Line":7}},{"line":58,"address":[6929276],"length":1,"stats":{"Line":1}},{"line":59,"address":[6991300,6991356,6991629,6991256,6991491,6991145],"length":1,"stats":{"Line":5}},{"line":61,"address":[7019078],"length":1,"stats":{"Line":1}},{"line":63,"address":[6993056,6993015,6992099,6991622,6991698,6992612],"length":1,"stats":{"Line":4}}],"covered":13,"coverable":13},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","google_book_handler.rs"],"content":"use axum::{http::StatusCode, response::IntoResponse, Json};\nuse serde_json::json;\nuse std::sync::Arc;\n\nuse crate::error::AppError;\nuse crate::models::book::BookSearchRequest;\nuse crate::services::google_book_service::GoogleBookService;\n\npub struct GoogleBookHandler {\n    google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n}\n\nimpl GoogleBookHandler {\n    pub fn new(book_service: Arc\u003cdyn GoogleBookService\u003e) -\u003e Self {\n        Self {\n            google_book_service: book_service,\n        }\n    }\n\n    pub async fn search_books(\n        \u0026self,\n        Json(search_request): Json\u003cBookSearchRequest\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        if search_request.query.is_empty() {\n            return Err(AppError::ValidationError(\n                \"A consulta não pode estar vazia\".to_string(),\n            ));\n        }\n\n        let books = self\n            .google_book_service\n            .search_books(\u0026search_request.query)\n            .await?;\n\n        Ok((\n            StatusCode::OK,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Livros encontrados com sucesso\",\n                \"data\": books\n            })),\n        ))\n    }\n}\n","traces":[{"line":14,"address":[3734384],"length":1,"stats":{"Line":12}},{"line":20,"address":[7429008],"length":1,"stats":{"Line":4}},{"line":24,"address":[7106704,7106828],"length":1,"stats":{"Line":10}},{"line":25,"address":[7107077],"length":1,"stats":{"Line":1}},{"line":26,"address":[7189586],"length":1,"stats":{"Line":1}},{"line":30,"address":[7106842,7107031,7109625,7107377,7107639,7107475,7106972],"length":1,"stats":{"Line":23}},{"line":32,"address":[7179627],"length":1,"stats":{"Line":4}},{"line":33,"address":[6649454],"length":1,"stats":{"Line":16}},{"line":35,"address":[7192005],"length":1,"stats":{"Line":4}},{"line":37,"address":[7171466,7171497,7169656,7170057,7169536,7170573,7171043],"length":1,"stats":{"Line":20}}],"covered":10,"coverable":10},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","mod.rs"],"content":"pub mod auth_handler;\npub mod book_offered_handler;\npub mod google_book_handler;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","lib.rs"],"content":"pub mod app;\npub mod config;\npub mod docs;\npub mod error;\npub mod handlers;\npub mod middleware;\npub mod models;\npub mod repositories;\npub mod routes;\npub mod services; ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","middleware","auth_middleware.rs"],"content":"use std::sync::Arc;\n\nuse axum::{\n    extract::Extension,\n    http::{header, Request},\n    middleware::Next,\n    response::Response,\n};\nuse jsonwebtoken::{decode, DecodingKey, Validation};\nuse uuid::Uuid;\n\nuse crate::{\n    config::Config,\n    error::AppError,\n    services::auth_service::{AuthServiceImpl, TokenClaims},\n};\n\npub async fn auth_middleware\u003cB\u003e(\n    Extension(_auth_service): Extension\u003cArc\u003cAuthServiceImpl\u003e\u003e,\n    mut request: Request\u003cB\u003e,\n    next: Next\u003cB\u003e,\n) -\u003e Result\u003cResponse, AppError\u003e {\n    // Verificar a existência do token de autenticação no header Authorization\n    let headers = request.headers();\n    let auth_header = headers.get(header::AUTHORIZATION);\n    let auth_header = auth_header\n        .and_then(|header| header.to_str().ok())\n        .ok_or_else(|| AppError::AuthError(\"Token de autenticação ausente\".to_string()))?;\n\n    // Validar o formato do token (Bearer \u003ctoken\u003e)\n    if !auth_header.starts_with(\"Bearer \") {\n        return Err(AppError::AuthError(\n            \"Formato de token inválido. Use Bearer \u003ctoken\u003e\".to_string(),\n        ));\n    }\n\n    // Extrair o token\n    let token = auth_header.trim_start_matches(\"Bearer \").trim();\n\n    // Carregar configuração\n    let config = Config::from_env().expect(\"Falha ao carregar configuração\");\n\n    // Validar o token JWT\n    let token_data = decode::\u003cTokenClaims\u003e(\n        token,\n        \u0026DecodingKey::from_secret(config.jwt_secret.as_bytes()),\n        \u0026Validation::default(),\n    )\n    .map_err(|e| AppError::AuthError(format!(\"Token inválido: {}\", e)))?;\n\n    // Extrair o user_id do token e converter para Uuid\n    let user_id_str = token_data.claims.sub;\n    let user_id = Uuid::parse_str(\u0026user_id_str)\n        .map_err(|_| AppError::AuthError(\"ID de usuário inválido no token\".to_string()))?;\n\n    // Adicionar o user_id aos extensions para que as rotas possam acessá-lo\n    request.extensions_mut().insert(user_id);\n\n    // Passar a requisição para o próximo handler\n    Ok(next.run(request).await)\n}\n","traces":[{"line":18,"address":[7143376],"length":1,"stats":{"Line":5}},{"line":24,"address":[7205007,7205140],"length":1,"stats":{"Line":10}},{"line":25,"address":[7231372],"length":1,"stats":{"Line":6}},{"line":26,"address":[7231445,7233666,7231670],"length":1,"stats":{"Line":9}},{"line":27,"address":[7234825,7234816],"length":1,"stats":{"Line":12}},{"line":28,"address":[7231638,7234864,7234878],"length":1,"stats":{"Line":6}},{"line":31,"address":[4379998,4379896],"length":1,"stats":{"Line":12}},{"line":32,"address":[7216353],"length":1,"stats":{"Line":1}},{"line":33,"address":[7226280],"length":1,"stats":{"Line":1}},{"line":38,"address":[4380051,4380259],"length":1,"stats":{"Line":12}},{"line":41,"address":[7205818],"length":1,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[4380382,4380479],"length":1,"stats":{"Line":12}},{"line":47,"address":[4380498],"length":1,"stats":{"Line":6}},{"line":49,"address":[4380890,4381840,4380599,4380517,4383318,4383136,4380806,4383171],"length":1,"stats":{"Line":17}},{"line":52,"address":[7210001],"length":1,"stats":{"Line":7}},{"line":53,"address":[7227628,7227357,7227450],"length":1,"stats":{"Line":11}},{"line":54,"address":[7207772,7209982,7209968],"length":1,"stats":{"Line":0}},{"line":57,"address":[7233110,7233005],"length":1,"stats":{"Line":12}},{"line":60,"address":[7227893,7225855,7227713,7228575,7228938],"length":1,"stats":{"Line":20}}],"covered":18,"coverable":20},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","middleware","mod.rs"],"content":"pub mod auth_middleware;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","book.rs"],"content":"use serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\nuse uuid::Uuid;\n\n#[derive(Debug, Serialize, ToSchema, Clone)]\npub struct GoogleBookDto {\n    pub google_id: String,\n    pub title: String,\n    pub authors: Option\u003cString\u003e,\n    pub publisher: Option\u003cString\u003e,\n    pub published_date: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub image_url: Option\u003cString\u003e,\n    pub page_count: Option\u003ci32\u003e,\n}\n\n#[derive(Debug, Serialize, ToSchema, Deserialize)]\npub struct BookSearchRequest {\n    pub query: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct BookOffered {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct BookWanted {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateBookOfferedDto {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateBookWantedDto {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","mod.rs"],"content":"pub mod book;\npub mod user;\n\n#[cfg(test)]\nmod user_test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","user.rs"],"content":"use chrono::NaiveDateTime;\nuse serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\nuse utoipa::ToSchema;\nuse uuid::Uuid;\nuse validator::Validate;\nuse validator::{validate_email, ValidationError};\n\n#[derive(Debug, FromRow, Serialize)]\npub struct User {\n    pub id: Uuid,\n    pub name: String,\n    pub email: String,\n    #[serde(skip_serializing)]\n    pub hash_password: String,\n    pub created_at: NaiveDateTime,\n    pub updated_at: NaiveDateTime,\n}\n\n#[derive(Debug, Deserialize, ToSchema, Validate)]\npub struct CreateUserDto {\n    /// Nome do usuário (máximo 255 caracteres)\n    #[validate(length(min = 1, message = \"O nome não pode estar vazio\"))]\n    #[validate(length(max = 255, message = \"O nome deve ter menos de 255 caracteres\"))]\n    pub name: String,\n\n    /// Email do usuário (deve ser único e em formato válido)\n    #[validate(length(min = 1, message = \"O email não pode estar vazio\"))]\n    #[validate(length(max = 255, message = \"O email deve ter menos de 255 caracteres\"))]\n    #[validate(custom = \"validate_email_format\")]\n    pub email: String,\n\n    /// Senha do usuário (mínimo 6 caracteres)\n    #[validate(length(min = 6, message = \"A senha deve ter pelo menos 6 caracteres\"))]\n    pub password: String,\n}\n\nimpl CreateUserDto {\n    /// Valida todos os campos do DTO\n    ///\n    /// Retorna erro se algum campo não estiver de acordo com as regras de validação\n    pub fn validate_all(\u0026self) -\u003e Result\u003c(), crate::error::AppError\u003e {\n        match self.validate() {\n            Ok(_) =\u003e Ok(()),\n            Err(e) =\u003e Err(crate::error::AppError::ValidationError(format!(\n                \"Erro de validação: {}\",\n                e\n            ))),\n        }\n    }\n}\n\n/// Função personalizada para validar formato de email\nfn validate_email_format(email: \u0026str) -\u003e Result\u003c(), ValidationError\u003e {\n    if validate_email(email) {\n        Ok(())\n    } else {\n        let mut error = ValidationError::new(\"email\");\n        error.message = Some(\"Formato de email inválido\".into());\n        Err(error)\n    }\n}\n\n#[derive(Debug, Deserialize, ToSchema, Validate)]\npub struct LoginUserDto {\n    /// Email do usuário\n    #[validate(length(min = 1, message = \"O email não pode estar vazio\"))]\n    #[validate(length(max = 255, message = \"O email deve ter menos de 255 caracteres\"))]\n    #[validate(custom = \"validate_email_format\")]\n    pub email: String,\n\n    /// Senha do usuário\n    #[validate(length(min = 1, message = \"A senha não pode estar vazia\"))]\n    pub password: String,\n}\n\nimpl LoginUserDto {\n    /// Valida todos os campos do DTO\n    ///\n    /// Retorna erro se algum campo não estiver de acordo com as regras de validação\n    pub fn validate_all(\u0026self) -\u003e Result\u003c(), crate::error::AppError\u003e {\n        match self.validate() {\n            Ok(_) =\u003e Ok(()),\n            Err(e) =\u003e Err(crate::error::AppError::ValidationError(format!(\n                \"Erro de validação: {}\",\n                e\n            ))),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, ToSchema)]\npub struct UserResponse {\n    /// ID único do usuário\n    #[schema(value_type = String, format = \"uuid\")]\n    pub id: Uuid,\n    /// Nome do usuário\n    pub name: String,\n    /// Email do usuário\n    pub email: String,\n    /// Data de criação do registro\n    #[schema(value_type = String, format = DateTime)]\n    pub created_at: NaiveDateTime,\n    /// Data da última atualização\n    #[schema(value_type = String, format = DateTime)]\n    pub updated_at: NaiveDateTime,\n}\n\n#[derive(Debug, Serialize, ToSchema)]\npub struct TokenResponse {\n    /// Token JWT de acesso\n    pub access_token: String,\n    /// Tipo do token (Bearer)\n    pub token_type: String,\n    /// Informações do usuário\n    pub user: UserResponse,\n}\n\nimpl From\u003cUser\u003e for UserResponse {\n    fn from(user: User) -\u003e Self {\n        Self {\n            id: user.id,\n            name: user.name,\n            email: user.email,\n            created_at: user.created_at,\n            updated_at: user.updated_at,\n        }\n    }\n}\n","traces":[{"line":42,"address":[7330386,7329968],"length":1,"stats":{"Line":13}},{"line":43,"address":[7329032],"length":1,"stats":{"Line":11}},{"line":44,"address":[7332545],"length":1,"stats":{"Line":11}},{"line":45,"address":[7339850,7339958,7340083],"length":1,"stats":{"Line":7}},{"line":54,"address":[7350647,7350240],"length":1,"stats":{"Line":18}},{"line":55,"address":[3610249,3610340],"length":1,"stats":{"Line":30}},{"line":56,"address":[7340360],"length":1,"stats":{"Line":16}},{"line":58,"address":[3610258],"length":1,"stats":{"Line":3}},{"line":59,"address":[3610284,3610386],"length":1,"stats":{"Line":7}},{"line":60,"address":[7329804],"length":1,"stats":{"Line":3}},{"line":81,"address":[7331266,7330848],"length":1,"stats":{"Line":6}},{"line":82,"address":[3610648],"length":1,"stats":{"Line":7}},{"line":83,"address":[7356177],"length":1,"stats":{"Line":6}},{"line":84,"address":[7356294,7356186,7356419],"length":1,"stats":{"Line":3}},{"line":120,"address":[7356560],"length":1,"stats":{"Line":7}},{"line":122,"address":[7356583],"length":1,"stats":{"Line":7}},{"line":123,"address":[7333849],"length":1,"stats":{"Line":7}},{"line":124,"address":[7341171],"length":1,"stats":{"Line":7}},{"line":125,"address":[7331390],"length":1,"stats":{"Line":7}},{"line":126,"address":[7330446],"length":1,"stats":{"Line":7}}],"covered":20,"coverable":20},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","user_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::models::user::CreateUserDto;\n    use validator::Validate;\n\n    #[test]\n    fn test_valid_user_dto() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        assert!(\n            dto.validate().is_ok(),\n            \"O DTO válido deveria passar na validação\"\n        );\n    }\n\n    #[test]\n    fn test_empty_name() {\n        let dto = CreateUserDto {\n            name: \"\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com nome vazio deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"name\"),\n            \"Erro deveria estar no campo 'name'\"\n        );\n        assert!(\n            error.field_errors().get(\"name\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"não pode estar vazio\"),\n            \"Mensagem de erro deveria indicar que o nome não pode estar vazio\"\n        );\n    }\n\n    #[test]\n    fn test_long_name() {\n        // Criar um nome com 256 caracteres (acima do limite)\n        let name = \"A\".repeat(256);\n\n        let dto = CreateUserDto {\n            name,\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com nome longo demais deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"name\"),\n            \"Erro deveria estar no campo 'name'\"\n        );\n        assert!(\n            error.field_errors().get(\"name\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"menos de 255\"),\n            \"Mensagem de erro deveria indicar que o nome deve ter menos de 255 caracteres\"\n        );\n    }\n\n    #[test]\n    fn test_long_email() {\n        // Criar um nome com 256 caracteres (acima do limite)\n        let email = \"A\".repeat(256);\n\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email,\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com email longo demais deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"email\"),\n            \"Erro deveria estar no campo 'email'\"\n        );\n        assert!(\n            error.field_errors().get(\"email\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"menos de 255\"),\n            \"Mensagem de erro deveria indicar que o email deve ter menos de 255 caracteres\"\n        );\n    }\n\n    #[test]\n    fn test_empty_email() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com email vazio deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"email\"),\n            \"Erro deveria estar no campo 'email'\"\n        );\n        assert!(\n            error.field_errors().get(\"email\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"não pode estar vazio\"),\n            \"Mensagem de erro deveria indicar que o email não pode estar vazio\"\n        );\n    }\n\n    #[test]\n    fn test_invalid_email_format() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"email_invalido\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com formato de email inválido deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"email\"),\n            \"Erro deveria estar no campo 'email'\"\n        );\n        assert!(\n            error.field_errors().get(\"email\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"Formato de email inválido\"),\n            \"Mensagem de erro deveria indicar que o formato do email é inválido\"\n        );\n    }\n\n    #[test]\n    fn test_short_password() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"12345\".to_string(), // Menos de 6 caracteres\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com senha curta demais deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"password\"),\n            \"Erro deveria estar no campo 'password'\"\n        );\n        assert!(\n            error.field_errors().get(\"password\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"pelo menos 6 caracteres\"),\n            \"Mensagem de erro deveria indicar que a senha deve ter pelo menos 6 caracteres\"\n        );\n    }\n\n    #[test]\n    fn test_validate_all_method() {\n        // Teste com DTO válido\n        let valid_dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n        assert!(\n            valid_dto.validate_all().is_ok(),\n            \"O método validate_all deveria retornar Ok para um DTO válido\"\n        );\n\n        // Teste com DTO inválido\n        let invalid_dto = CreateUserDto {\n            name: \"\".to_string(),\n            email: \"email_invalido\".to_string(),\n            password: \"12345\".to_string(),\n        };\n        let result = invalid_dto.validate_all();\n        assert!(\n            result.is_err(),\n            \"O método validate_all deveria retornar Err para um DTO inválido\"\n        );\n\n        let error = result.unwrap_err();\n        match error {\n            crate::error::AppError::ValidationError(msg) =\u003e {\n                assert!(\n                    msg.contains(\"Erro de validação\"),\n                    \"Mensagem de erro deveria começar com 'Erro de validação'\"\n                );\n            }\n            _ =\u003e panic!(\"Tipo de erro inesperado, esperava ValidationError\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository.rs"],"content":"use crate::models::book::GoogleBookDto;\nuse chrono::NaiveDate;\nuse sqlx::PgPool;\nuse async_trait::async_trait;\nuse uuid::Uuid;\nuse crate::error::AppError;\n\n// Estender GoogleBookDto para incluir o id do banco de dados\n#[derive(Debug, Clone)]\npub struct BookWithId {\n    pub id: Uuid,\n    pub book: GoogleBookDto,\n}\n\n#[async_trait]\npub trait BookRepository: Send + Sync + 'static {\n    async fn create(\u0026self, book: \u0026GoogleBookDto) -\u003e Result\u003cUuid, AppError\u003e;\n    async fn find_by_google_id(\u0026self, google_id: \u0026str) -\u003e Result\u003cOption\u003cBookWithId\u003e, AppError\u003e;\n    async fn find_by_id(\u0026self, id: \u0026str) -\u003e Result\u003cOption\u003cGoogleBookDto\u003e, AppError\u003e;\n}\n\npub struct PgBookRepository {\n    pool: PgPool,\n}\n\nimpl PgBookRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl BookRepository for PgBookRepository {\n    async fn find_by_google_id(\u0026self, google_id: \u0026str) -\u003e Result\u003cOption\u003cBookWithId\u003e, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            SELECT \n                id,\n                google_id,\n                title,\n                author,\n                publisher,\n                published_date,\n                description,\n                image_url,\n                page_count\n            FROM books \n            WHERE google_id = $1\n            \"#,\n            google_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.map(|r| BookWithId {\n            id: r.id,\n            book: GoogleBookDto {\n                google_id: r.google_id.unwrap_or_default(),\n                title: r.title,\n                authors: Some(r.author),\n                publisher: r.publisher,\n                published_date: r.published_date.map(|d| d.to_string()),\n                description: Some(r.description),\n                image_url: Some(r.image_url),\n                page_count: r.page_count,\n            }\n        }))\n    }\n\n    async fn find_by_id(\u0026self, id: \u0026str) -\u003e Result\u003cOption\u003cGoogleBookDto\u003e, AppError\u003e {\n        // Tenta converter a string em UUID\n        let book_id = match Uuid::parse_str(id) {\n            Ok(uuid) =\u003e uuid,\n            Err(_) =\u003e return Ok(None), // Retorna None para IDs inválidos\n        };\n\n        let result = sqlx::query!(\n            r#\"\n            SELECT \n                google_id,\n                title,\n                author,\n                publisher,\n                published_date,\n                description,\n                image_url,\n                page_count\n            FROM books \n            WHERE id = $1\n            \"#,\n            book_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        match result {\n            Some(r) =\u003e Ok(Some(GoogleBookDto {\n                google_id: r.google_id.unwrap_or_default(),\n                title: r.title,\n                authors: Some(r.author),\n                publisher: r.publisher,\n                published_date: r.published_date.map(|d| d.to_string()),\n                description: Some(r.description),\n                image_url: Some(r.image_url),\n                page_count: r.page_count,\n            })),\n            None =\u003e Ok(None),\n        }\n    }\n\n    async fn create(\u0026self, book: \u0026GoogleBookDto) -\u003e Result\u003cUuid, AppError\u003e {\n        // Tenta converter a data de publicação para o formato NaiveDate\n        let published_date = match \u0026book.published_date {\n            Some(date_str) =\u003e {\n                match NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\") {\n                    Ok(date) =\u003e Some(date),\n                    Err(_) =\u003e {\n                        return Err(AppError::ValidationError(format!(\n                            \"A data '{}' deve estar no formato AAAA-MM-DD\",\n                            date_str\n                        )));\n                    }\n                }\n            }\n            None =\u003e None,\n        };\n\n        let result = sqlx::query!(\n            r#\"\n            INSERT INTO books (\n                title, \n                author, \n                description, \n                image_url, \n                publisher, \n                published_date, \n                page_count, \n                google_id\n            )\n            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n            RETURNING id\n            \"#,\n            \u0026book.title[..book.title.len().min(250)],\n            \u0026book.authors.clone().unwrap_or_default()[..book.authors.clone().unwrap_or_default().len().min(250)],\n            \u0026book.description.clone().unwrap_or_default()[..book.description.clone().unwrap_or_default().len().min(250)],\n            book.image_url.clone().unwrap_or_default(),\n            book.publisher,\n            published_date,\n            book.page_count,\n            book.google_id\n        )\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.id)\n    }\n}\n","traces":[{"line":27,"address":[7116768],"length":1,"stats":{"Line":12}},{"line":34,"address":[7205247],"length":1,"stats":{"Line":9}},{"line":35,"address":[4384684,4384086,4385001,4384761,4384460,4384012],"length":1,"stats":{"Line":15}},{"line":53,"address":[7074983,7074929,7075190,7075048,7074300],"length":1,"stats":{"Line":12}},{"line":54,"address":[7070274,7070049,7070256],"length":1,"stats":{"Line":0}},{"line":56,"address":[7050178,7050328,7051519,7051467,7050576,7051708],"length":1,"stats":{"Line":12}},{"line":57,"address":[7070422],"length":1,"stats":{"Line":3}},{"line":58,"address":[7051144],"length":1,"stats":{"Line":3}},{"line":59,"address":[7075922],"length":1,"stats":{"Line":3}},{"line":60,"address":[7060563],"length":1,"stats":{"Line":3}},{"line":61,"address":[7049826],"length":1,"stats":{"Line":3}},{"line":62,"address":[7049890],"length":1,"stats":{"Line":3}},{"line":63,"address":[7050784,7049925,7050768],"length":1,"stats":{"Line":9}},{"line":64,"address":[4385696],"length":1,"stats":{"Line":3}},{"line":65,"address":[7053560],"length":1,"stats":{"Line":3}},{"line":66,"address":[7051132],"length":1,"stats":{"Line":3}},{"line":71,"address":[7061765,7061920,7061584,7061631,7062640],"length":1,"stats":{"Line":3}},{"line":73,"address":[7077444],"length":1,"stats":{"Line":1}},{"line":74,"address":[7077501],"length":1,"stats":{"Line":1}},{"line":75,"address":[7052307],"length":1,"stats":{"Line":1}},{"line":78,"address":[7051822,7052335,7051310,7051436,7052117,7052052],"length":1,"stats":{"Line":5}},{"line":95,"address":[7062681,7062563,7062822,7062617,7061792],"length":1,"stats":{"Line":4}},{"line":96,"address":[7054736,7053263,7054754],"length":1,"stats":{"Line":0}},{"line":98,"address":[7078490],"length":1,"stats":{"Line":1}},{"line":99,"address":[7079271,7078642],"length":1,"stats":{"Line":2}},{"line":100,"address":[7063248],"length":1,"stats":{"Line":1}},{"line":101,"address":[7053579],"length":1,"stats":{"Line":1}},{"line":102,"address":[7052659],"length":1,"stats":{"Line":1}},{"line":103,"address":[6990795],"length":1,"stats":{"Line":1}},{"line":104,"address":[7056243,7057392,7057408],"length":1,"stats":{"Line":3}},{"line":105,"address":[7073625],"length":1,"stats":{"Line":1}},{"line":106,"address":[4388585],"length":1,"stats":{"Line":1}},{"line":107,"address":[7053033],"length":1,"stats":{"Line":1}},{"line":109,"address":[7078596],"length":1,"stats":{"Line":0}},{"line":113,"address":[7200183],"length":1,"stats":{"Line":3}},{"line":115,"address":[7055441],"length":1,"stats":{"Line":1}},{"line":116,"address":[7065335],"length":1,"stats":{"Line":1}},{"line":117,"address":[7080799,7080888],"length":1,"stats":{"Line":2}},{"line":118,"address":[6992809],"length":1,"stats":{"Line":1}},{"line":120,"address":[4390422,4392883,4393004],"length":1,"stats":{"Line":3}},{"line":127,"address":[7058011],"length":1,"stats":{"Line":0}},{"line":130,"address":[7066541,7066060,7067983,7068447,7065698,7068564,7065803,7066441,7068857,7066184,7066278,7065897],"length":1,"stats":{"Line":7}},{"line":145,"address":[6992670,6992880],"length":1,"stats":{"Line":2}},{"line":146,"address":[7055079,7055178,7054938],"length":1,"stats":{"Line":3}},{"line":147,"address":[6993383,6993623,6993524],"length":1,"stats":{"Line":3}},{"line":148,"address":[7055700],"length":1,"stats":{"Line":1}},{"line":155,"address":[7058525,7058687,7058148,7055113,7058205],"length":1,"stats":{"Line":4}},{"line":156,"address":[7059017,7059088,7059106],"length":1,"stats":{"Line":0}},{"line":158,"address":[7057912],"length":1,"stats":{"Line":1}}],"covered":44,"coverable":49},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","create_book_test.rs"],"content":"use crate::error::AppError;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_create_book() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"abc123\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Verifica se o ID retornado não é vazio\n    assert!(\n        book_id.to_string().len() \u003e 0,\n        \"O ID do livro não deve ser vazio\"\n    );\n\n    // Busca o livro usando o repository\n    let found_book = book_repository\n        .find_by_google_id(\u0026book.google_id)\n        .await\n        .expect(\"Falha ao buscar livro pelo google_id\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro criado não foi encontrado pelo google_id\"\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se o ID do livro corresponde ao ID retornado pela criação\n    assert_eq!(found_book.id, book_id, \"O ID do livro não corresponde ao ID retornado pela criação\");\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.book.google_id, book.google_id);\n    assert_eq!(found_book.book.title, book.title);\n    assert_eq!(found_book.book.authors, book.authors);\n    assert_eq!(found_book.book.publisher, book.publisher);\n    assert_eq!(found_book.book.published_date, book.published_date);\n    assert_eq!(found_book.book.description, book.description);\n    assert_eq!(found_book.book.image_url, book.image_url);\n    assert_eq!(found_book.book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_create_book_with_invalid_date() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory, com uma data inválida\n    let book = create_test_book(\"abc456\", false);\n\n    // Tenta inserir o livro com data inválida e espera um erro de validação\n    let result = book_repository.create(\u0026book).await;\n\n    assert!(result.is_err(), \"Deveria falhar ao criar livro com data inválida\");\n\n    // Verifica se é um erro de validação\n    match result {\n        Err(AppError::ValidationError(_)) =\u003e (),\n        _ =\u003e panic!(\"Esperava um erro de validação\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","find_book_by_google_id_test.rs"],"content":"use crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_find_book_by_google_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"test123\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Testa a função find_by_google_id\n    let found_book = book_repository\n        .find_by_google_id(\u0026book.google_id)\n        .await\n        .expect(\"Falha ao buscar livro\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro com google_id '{}' não foi encontrado\",\n        book.google_id\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se o ID do livro corresponde ao ID retornado pela criação\n    assert_eq!(found_book.id, book_id, \"O ID do livro não corresponde ao ID retornado pela criação\");\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.book.google_id, book.google_id);\n    assert_eq!(found_book.book.title, book.title);\n    assert_eq!(found_book.book.authors, book.authors);\n    assert_eq!(found_book.book.publisher, book.publisher);\n    // Comparação simplificada para published_date já que pode haver diferenças de formatação\n    assert!(found_book.book.published_date.is_some());\n    assert_eq!(\n        found_book.book.description.unwrap_or_default(),\n        book.description.unwrap_or_default()\n    );\n    assert_eq!(\n        found_book.book.image_url.unwrap_or_default(),\n        book.image_url.unwrap_or_default()\n    );\n    assert_eq!(found_book.book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_find_book_by_google_id_not_found() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Testa buscar um livro que não existe\n    let not_found = book_repository\n        .find_by_google_id(\"non_existent_id\")\n        .await\n        .expect(\"Falha na consulta\");\n\n    assert!(not_found.is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","find_by_google_id_test.rs"],"content":"use crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_find_by_google_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"test_find_by_google_id_456\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Verifica se o ID retornado não é vazio\n    assert!(\n        book_id.to_string().len() \u003e 0,\n        \"O ID do livro não deve ser vazio\"\n    );\n\n    // Busca o livro usando o repository\n    let found_book = book_repository\n        .find_by_google_id(\u0026book.google_id)\n        .await\n        .expect(\"Falha ao buscar livro pelo google_id\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro criado não foi encontrado pelo google_id\"\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se o ID do livro corresponde ao ID retornado pela criação\n    assert_eq!(found_book.id, book_id, \"O ID do livro não corresponde ao ID retornado pela criação\");\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.book.google_id, book.google_id);\n    assert_eq!(found_book.book.title, book.title);\n    assert_eq!(found_book.book.authors, book.authors);\n    assert_eq!(found_book.book.publisher, book.publisher);\n    assert_eq!(found_book.book.published_date, book.published_date);\n    assert_eq!(found_book.book.description, book.description);\n    assert_eq!(found_book.book.image_url, book.image_url);\n    assert_eq!(found_book.book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_find_by_google_id_not_found() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Busca um livro com um google_id que não existe\n    let result = book_repository\n        .find_by_google_id(\"nonexistent_id\")\n        .await\n        .expect(\"Falha ao buscar livro pelo google_id\");\n\n    // Verifica se o resultado é None\n    assert!(\n        result.is_none(),\n        \"Não deveria encontrar um livro com google_id inexistente\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","find_by_id_test.rs"],"content":"use crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_find_by_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"test_find_123\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Verifica se o ID retornado não é vazio\n    assert!(\n        book_id.to_string().len() \u003e 0,\n        \"O ID do livro não deve ser vazio\"\n    );\n\n    // Busca o livro usando o repository - convertendo UUID para string\n    let found_book = book_repository\n        .find_by_id(\u0026book_id.to_string())\n        .await\n        .expect(\"Falha ao buscar livro pelo ID\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro criado não foi encontrado pelo ID\"\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.google_id, book.google_id);\n    assert_eq!(found_book.title, book.title);\n    assert_eq!(found_book.authors, book.authors);\n    assert_eq!(found_book.publisher, book.publisher);\n    assert_eq!(found_book.published_date, book.published_date);\n    assert_eq!(found_book.description, book.description);\n    assert_eq!(found_book.image_url, book.image_url);\n    assert_eq!(found_book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_find_by_id_not_found() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Busca um livro com um ID que não existe\n    let result = book_repository\n        .find_by_id(\"nonexistent_id\")\n        .await\n        .expect(\"Falha ao buscar livro pelo ID\");\n\n    // Verifica se o resultado é None\n    assert!(\n        result.is_none(),\n        \"Não deveria encontrar um livro com ID inexistente\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","mod.rs"],"content":"pub mod create_book_test;\npub mod find_book_by_google_id_test;\npub mod find_by_google_id_test;\npub mod find_by_id_test;\n\nuse crate::models::book::GoogleBookDto;\nuse crate::repositories::book_repository::PgBookRepository;\nuse crate::repositories::test_helpers::get_test_db_pool;\n\n\nasync fn setup_test_repository() -\u003e PgBookRepository {\n    // Obtém o pool de conexão com o banco de dados de teste\n    let pool = get_test_db_pool().await;\n\n    // Limpa o banco de dados para garantir o isolamento dos testes\n    crate::repositories::test_helpers::clean_database(\u0026pool).await;\n\n    // Criamos o DatabasePool com o pool real\n    PgBookRepository::new(pool)\n}\n\npub fn create_test_book(google_id: \u0026str, with_valid_date: bool) -\u003e GoogleBookDto {\n    GoogleBookDto {\n        google_id: String::from(google_id),\n        title: String::from(\"Livro de Teste\"),\n        authors: Some(String::from(\"Autor Teste\")),\n        publisher: Some(String::from(\"Editora Teste\")),\n        // Usa data válida ou inválida conforme solicitado\n        published_date: Some(String::from(if with_valid_date {\n            \"2022-05-10\"\n        } else {\n            \"10/05/2022\"\n        })),\n        description: Some(String::from(\"Esta é uma descrição de teste\")),\n        image_url: Some(String::from(\"http://example.com/livro.jpg\")),\n        page_count: Some(300),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository.rs"],"content":"use async_trait::async_trait;\nuse sqlx::PgPool;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookOffered, CreateBookOfferedDto};\n\n#[async_trait]\npub trait BooksOfferedRepository: Send + Sync + 'static {\n    async fn create(\u0026self, book_offered: \u0026CreateBookOfferedDto) -\u003e Result\u003cBookOffered, AppError\u003e;\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookOffered\u003e, AppError\u003e;\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct PgBooksOfferedRepository {\n    pool: PgPool,\n}\n\nimpl PgBooksOfferedRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl BooksOfferedRepository for PgBooksOfferedRepository {\n    async fn create(\u0026self, book_offered: \u0026CreateBookOfferedDto) -\u003e Result\u003cBookOffered, AppError\u003e {\n        // Inserir na tabela books_offered\n        let result = sqlx::query!(\n            r#\"\n            INSERT INTO books_offered (book_id, user_id)\n            VALUES ($1, $2)\n            RETURNING book_id, user_id\n            \"#,\n            book_offered.book_id,\n            book_offered.user_id\n        )\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| {\n            if e.to_string().contains(\"duplicate key\") {\n                AppError::ValidationError(\"Este livro já está na sua lista de possuídos\".to_string())\n            } else if e.to_string().contains(\"foreign key constraint\") {\n                if e.to_string().contains(\"books_offered_book_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Livro com ID {} não encontrado\",\n                        book_offered.book_id\n                    ))\n                } else if e.to_string().contains(\"books_offered_user_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Usuário com ID {} não encontrado\",\n                        book_offered.user_id\n                    ))\n                } else {\n                    AppError::DatabaseError(e.to_string())\n                }\n            } else {\n                AppError::DatabaseError(e.to_string())\n            }\n        })?;\n\n        Ok(BookOffered {\n            book_id: result.book_id,\n            user_id: result.user_id,\n        })\n    }\n\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookOffered\u003e, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            SELECT book_id, user_id\n            FROM books_offered\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.map(|r| BookOffered {\n            book_id: r.book_id,\n            user_id: r.user_id,\n        }))\n    }\n\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            DELETE FROM books_offered\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .execute(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        // Retorna true se algo foi excluído, false caso contrário\n        Ok(result.rows_affected() \u003e 0)\n    }\n} ","traces":[{"line":20,"address":[7287296],"length":1,"stats":{"Line":12}},{"line":27,"address":[7290807],"length":1,"stats":{"Line":9}},{"line":29,"address":[6795343,6794596,6795453,6795139,6795856],"length":1,"stats":{"Line":13}},{"line":39,"address":[6805199,6804208,6804920,6804974,6805039],"length":1,"stats":{"Line":12}},{"line":40,"address":[6797956,6798416,6799577,6799868],"length":1,"stats":{"Line":4}},{"line":41,"address":[6807159,6805747,6805815],"length":1,"stats":{"Line":3}},{"line":42,"address":[6734376],"length":1,"stats":{"Line":1}},{"line":43,"address":[6798670],"length":1,"stats":{"Line":1}},{"line":44,"address":[6816256,6817091],"length":1,"stats":{"Line":2}},{"line":45,"address":[6734328,6734178],"length":1,"stats":{"Line":2}},{"line":49,"address":[6796100,6795898,6795653],"length":1,"stats":{"Line":2}},{"line":50,"address":[3741447,3741597],"length":1,"stats":{"Line":2}},{"line":55,"address":[3741387],"length":1,"stats":{"Line":0}},{"line":58,"address":[6795376],"length":1,"stats":{"Line":0}},{"line":62,"address":[3740269],"length":1,"stats":{"Line":3}},{"line":63,"address":[6815417],"length":1,"stats":{"Line":3}},{"line":64,"address":[6795625],"length":1,"stats":{"Line":3}},{"line":68,"address":[6734515,6734597,6734480,6734752,6735410],"length":1,"stats":{"Line":9}},{"line":69,"address":[6818654,6818273,6817540,6818374,6818551,6818079],"length":1,"stats":{"Line":12}},{"line":79,"address":[6818052,6818171,6818106,6817344,6818321],"length":1,"stats":{"Line":12}},{"line":80,"address":[6808503,6808656,6808674],"length":1,"stats":{"Line":0}},{"line":82,"address":[6797708,6798070,6797801,6798032],"length":1,"stats":{"Line":12}},{"line":83,"address":[6824259],"length":1,"stats":{"Line":3}},{"line":84,"address":[6824276],"length":1,"stats":{"Line":3}},{"line":88,"address":[6801584,6801619,6801709,6801966,6802597],"length":1,"stats":{"Line":6}},{"line":89,"address":[6736626,6737741,6737342,6737606,6737138,6737447],"length":1,"stats":{"Line":8}},{"line":98,"address":[6664697],"length":1,"stats":{"Line":8}},{"line":99,"address":[6820294,6820480,6820498],"length":1,"stats":{"Line":0}},{"line":102,"address":[6799487,6799580],"length":1,"stats":{"Line":4}}],"covered":25,"coverable":29},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","create_books_offered_test.rs"],"content":"use crate::models::book::CreateBookOfferedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_offered_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_create_books_offered() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa a criação de um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    let result = books_offered_repository.create(\u0026book_offered).await;\n    \n    assert!(result.is_ok(), \"Falha ao criar book_offered: {:?}\", result.err());\n    \n    let book_offered = result.unwrap();\n    assert_eq!(book_offered.book_id, book_id);\n    assert_eq!(book_offered.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_create_books_offered_with_invalid_book_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta criar um book_offered com um book_id inexistente\n    let book_offered = CreateBookOfferedDto {\n        book_id: Uuid::new_v4(),\n        user_id: user.id,\n    };\n\n    let result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com book_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Livro com ID\"), \n        \"Erro deveria indicar que o livro não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_offered_with_invalid_user_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"invalid_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Tenta criar um book_offered com um user_id inexistente\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: Uuid::new_v4(),\n    };\n\n    let result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com user_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Usuário com ID\"), \n        \"Erro deveria indicar que o usuário não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_offered_duplicate() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"duplicate_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    // Primeira inserção deve ter sucesso\n    let first_result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(first_result.is_ok(), \"A primeira inserção deveria ter sucesso\");\n\n    // Segunda inserção deve falhar com erro de duplicação\n    let second_result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(second_result.is_err(), \"A segunda inserção deveria falhar\");\n    \n    let error = second_result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"já está na sua lista\"), \n        \"Erro deveria indicar que o livro já está na lista: {:?}\", error\n    );\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","delete_books_offered_test.rs"],"content":"use crate::models::book::CreateBookOfferedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_offered_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_delete_books_offered() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_offered_repository.create(\u0026book_offered).await.unwrap();\n\n    // Verifica se o book_offered foi criado corretamente\n    let find_result_before = books_offered_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_before.is_some(), \"O book_offered deveria existir antes da deleção\");\n\n    // Testa a deleção do book_offered\n    let result = books_offered_repository.delete(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao deletar book_offered: {:?}\", result.err());\n    assert!(result.unwrap(), \"A deleção deveria retornar true\");\n\n    // Verifica se foi realmente deletado\n    let find_result_after = books_offered_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_after.is_none(), \"O book_offered não foi deletado corretamente\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_offered_nonexistent() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta deletar um book_offered inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_offered_repository.delete(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A deleção deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(!result.unwrap(), \"Deleção de ID inexistente deveria retornar false\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_offered_multiple_users() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_multi_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria books_offered para ambos os usuários\n    let book_offered1 = CreateBookOfferedDto {\n        book_id,\n        user_id: user1.id,\n    };\n    \n    let book_offered2 = CreateBookOfferedDto {\n        book_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_offered_repository.create(\u0026book_offered1).await.unwrap();\n    books_offered_repository.create(\u0026book_offered2).await.unwrap();\n\n    // Deleta apenas para o usuário 1\n    let delete_result = books_offered_repository.delete(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o usuário 1 deveria ter sucesso\");\n\n    // Verifica se foi removido para o usuário 1\n    let find_result1 = books_offered_repository.find(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro não deveria mais estar oferecido pelo usuário 1\");\n\n    // Verifica se ainda existe para o usuário 2\n    let find_result2 = books_offered_repository.find(\u0026book_id, \u0026user2.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro ainda deveria estar oferecido pelo usuário 2\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_offered_multiple_books() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"delete_book1_test\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"delete_book2_test\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria books_offered para ambos os livros\n    let book_offered1 = CreateBookOfferedDto {\n        book_id: book1_id,\n        user_id: user.id,\n    };\n    \n    let book_offered2 = CreateBookOfferedDto {\n        book_id: book2_id,\n        user_id: user.id,\n    };\n\n    // Insere as relações\n    books_offered_repository.create(\u0026book_offered1).await.unwrap();\n    books_offered_repository.create(\u0026book_offered2).await.unwrap();\n\n    // Deleta apenas o livro 1\n    let delete_result = books_offered_repository.delete(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o livro 1 deveria ter sucesso\");\n\n    // Verifica se o livro 1 foi removido\n    let find_result1 = books_offered_repository.find(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro 1 não deveria mais estar oferecido\");\n\n    // Verifica se o livro 2 ainda existe\n    let find_result2 = books_offered_repository.find(\u0026book2_id, \u0026user.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro 2 ainda deveria estar oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","find_books_offered_test.rs"],"content":"use crate::models::book::CreateBookOfferedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_offered_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_find_books_offered() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_offered_repository.create(\u0026book_offered).await.unwrap();\n\n    // Testa a busca do book_offered\n    let result = books_offered_repository.find(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao buscar book_offered: {:?}\", result.err());\n    \n    let found = result.unwrap();\n    assert!(found.is_some(), \"Book offered não encontrado\");\n    \n    let found = found.unwrap();\n    assert_eq!(found.book_id, book_id);\n    assert_eq!(found.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_find_books_offered_nonexistent_book() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Testa busca com book_id inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_offered_repository.find(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_offered com ID de livro inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_offered_nonexistent_user() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_nonexistent_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa busca com user_id inexistente\n    let non_existent_user_id = Uuid::new_v4();\n    let result = books_offered_repository.find(\u0026book_id, \u0026non_existent_user_id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com user_id inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_offered com user_id inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_offered_multiple_entries() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"find_multi_test1\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"find_multi_test2\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria várias relações de books_offered\n    let book_offered1 = CreateBookOfferedDto {\n        book_id: book1_id,\n        user_id: user1.id,\n    };\n    \n    let book_offered2 = CreateBookOfferedDto {\n        book_id: book2_id,\n        user_id: user1.id,\n    };\n    \n    let book_offered3 = CreateBookOfferedDto {\n        book_id: book1_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_offered_repository.create(\u0026book_offered1).await.unwrap();\n    books_offered_repository.create(\u0026book_offered2).await.unwrap();\n    books_offered_repository.create(\u0026book_offered3).await.unwrap();\n\n    // Teste 1: Usuário 1 oferece o Livro 1\n    let result1 = books_offered_repository.find(\u0026book1_id, \u0026user1.id).await.unwrap();\n    assert!(result1.is_some(), \"Usuário 1 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 2: Usuário 1 oferece o Livro 2\n    let result2 = books_offered_repository.find(\u0026book2_id, \u0026user1.id).await.unwrap();\n    assert!(result2.is_some(), \"Usuário 1 deveria ter o Livro 2 como oferecido\");\n    \n    // Teste 3: Usuário 2 oferece o Livro 1\n    let result3 = books_offered_repository.find(\u0026book1_id, \u0026user2.id).await.unwrap();\n    assert!(result3.is_some(), \"Usuário 2 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 4: Usuário 2 NÃO oferece o Livro 2\n    let result4 = books_offered_repository.find(\u0026book2_id, \u0026user2.id).await.unwrap();\n    assert!(result4.is_none(), \"Usuário 2 não deveria ter o Livro 2 como oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","mod.rs"],"content":"pub mod create_books_offered_test;\npub mod find_books_offered_test;\npub mod delete_books_offered_test;\n\nuse crate::models::book::GoogleBookDto;\nuse crate::models::user::CreateUserDto;\nuse crate::repositories::book_repository::{BookRepository, PgBookRepository};\nuse crate::repositories::books_offered_repository::{BooksOfferedRepository, PgBooksOfferedRepository};\nuse crate::repositories::test_helpers::{get_test_db_pool, clean_database};\nuse crate::repositories::user_repository::{UserRepository, PgUserRepository};\nuse uuid::Uuid;\n\n// Cria uma função de setup de repositório para o PgBookRepository\npub async fn setup_book_repository() -\u003e impl BookRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBookRepository::new(pool)\n}\n\n// Cria uma função de setup de repositório para o PgUserRepository\npub async fn setup_user_repository() -\u003e impl UserRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgUserRepository::new(pool)\n}\n\n// Função para criar o repositório de books_offered\npub async fn setup_test_repository() -\u003e impl BooksOfferedRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBooksOfferedRepository::new(pool)\n}\n\n// Função para criar um usuário de teste\npub fn create_test_user() -\u003e CreateUserDto {\n    CreateUserDto {\n        name: \"Test User\".to_string(),\n        email: format!(\"test_{}@example.com\", Uuid::new_v4()),\n        password: \"password\".to_string(),\n    }\n}\n\n// Função para criar um livro de teste\npub fn create_test_book(google_id: \u0026str) -\u003e GoogleBookDto {\n    GoogleBookDto {\n        google_id: google_id.to_string(),\n        title: \"Livro de Teste\".to_string(),\n        authors: Some(\"Autor Teste\".to_string()),\n        publisher: Some(\"Editora Teste\".to_string()),\n        published_date: Some(\"2022-05-10\".to_string()),\n        description: Some(\"Descrição de teste\".to_string()),\n        image_url: Some(\"http://example.com/image.jpg\".to_string()),\n        page_count: Some(200),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository.rs"],"content":"use async_trait::async_trait;\nuse sqlx::PgPool;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookWanted, CreateBookWantedDto};\n\n#[async_trait]\npub trait BooksWantedRepository: Send + Sync + 'static {\n    async fn create(\u0026self, book_wanted: \u0026CreateBookWantedDto) -\u003e Result\u003cBookWanted, AppError\u003e;\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookWanted\u003e, AppError\u003e;\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct PgBooksWantedRepository {\n    pool: PgPool,\n}\n\nimpl PgBooksWantedRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl BooksWantedRepository for PgBooksWantedRepository {\n    async fn create(\u0026self, book_wanted: \u0026CreateBookWantedDto) -\u003e Result\u003cBookWanted, AppError\u003e {\n        // Inserir na tabela books_wanted\n        let result = sqlx::query!(\n            r#\"\n            INSERT INTO books_wanted (book_id, user_id)\n            VALUES ($1, $2)\n            RETURNING book_id, user_id\n            \"#,\n            book_wanted.book_id,\n            book_wanted.user_id\n        )\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| {\n            if e.to_string().contains(\"duplicate key\") {\n                AppError::ValidationError(\"Este livro já está na sua lista de desejados\".to_string())\n            } else if e.to_string().contains(\"foreign key constraint\") {\n                if e.to_string().contains(\"books_wanted_book_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Livro com ID {} não encontrado\",\n                        book_wanted.book_id\n                    ))\n                } else if e.to_string().contains(\"books_wanted_user_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Usuário com ID {} não encontrado\",\n                        book_wanted.user_id\n                    ))\n                } else {\n                    AppError::DatabaseError(e.to_string())\n                }\n            } else {\n                AppError::DatabaseError(e.to_string())\n            }\n        })?;\n\n        Ok(BookWanted {\n            book_id: result.book_id,\n            user_id: result.user_id,\n        })\n    }\n\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookWanted\u003e, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            SELECT book_id, user_id\n            FROM books_wanted\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.map(|r| BookWanted {\n            book_id: r.book_id,\n            user_id: r.user_id,\n        }))\n    }\n\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            DELETE FROM books_wanted\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .execute(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        // Retorna true se algo foi excluído, false caso contrário\n        Ok(result.rows_affected() \u003e 0)\n    }\n} ","traces":[{"line":20,"address":[7079152],"length":1,"stats":{"Line":12}},{"line":27,"address":[7082663],"length":1,"stats":{"Line":3}},{"line":29,"address":[7021744,7021027,7020484,7021341,7021231],"length":1,"stats":{"Line":5}},{"line":39,"address":[7030862,7030096,7030927,7031087,7030808],"length":1,"stats":{"Line":4}},{"line":40,"address":[7023844,7024304,7025465,7025756],"length":1,"stats":{"Line":2}},{"line":41,"address":[7031703,7033047,7031635],"length":1,"stats":{"Line":3}},{"line":42,"address":[6960264],"length":1,"stats":{"Line":1}},{"line":43,"address":[7024558],"length":1,"stats":{"Line":1}},{"line":44,"address":[7042144,7042979],"length":1,"stats":{"Line":2}},{"line":45,"address":[6960066,6960216],"length":1,"stats":{"Line":2}},{"line":49,"address":[7021541,7021988,7021786],"length":1,"stats":{"Line":2}},{"line":50,"address":[3705565,3705415],"length":1,"stats":{"Line":2}},{"line":55,"address":[3705355],"length":1,"stats":{"Line":0}},{"line":58,"address":[7021264],"length":1,"stats":{"Line":0}},{"line":62,"address":[3704237],"length":1,"stats":{"Line":1}},{"line":63,"address":[7041305],"length":1,"stats":{"Line":1}},{"line":64,"address":[7021513],"length":1,"stats":{"Line":1}},{"line":68,"address":[6960403,6961298,6960640,6960485,6960368],"length":1,"stats":{"Line":9}},{"line":69,"address":[7044262,7044161,7043967,7044439,7044542,7043428],"length":1,"stats":{"Line":12}},{"line":79,"address":[7044059,7043994,7043232,7043940,7044209],"length":1,"stats":{"Line":12}},{"line":80,"address":[7034391,7034562,7034544],"length":1,"stats":{"Line":0}},{"line":82,"address":[7023689,7023920,7023958,7023596],"length":1,"stats":{"Line":8}},{"line":83,"address":[7050147],"length":1,"stats":{"Line":1}},{"line":84,"address":[7050164],"length":1,"stats":{"Line":1}},{"line":88,"address":[7027472,7027507,7027854,7028485,7027597],"length":1,"stats":{"Line":3}},{"line":89,"address":[6963494,6963335,6963629,6962514,6963026,6963230],"length":1,"stats":{"Line":4}},{"line":98,"address":[6663273],"length":1,"stats":{"Line":4}},{"line":99,"address":[7046368,7046182,7046386],"length":1,"stats":{"Line":0}},{"line":102,"address":[7025375,7025468],"length":1,"stats":{"Line":2}}],"covered":25,"coverable":29},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","create_books_wanted_test.rs"],"content":"use crate::models::book::CreateBookWantedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_wanted_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_create_books_wanted() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa a criação de um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    let result = books_wanted_repository.create(\u0026book_wanted).await;\n    \n    assert!(result.is_ok(), \"Falha ao criar book_wanted: {:?}\", result.err());\n    \n    let book_wanted = result.unwrap();\n    assert_eq!(book_wanted.book_id, book_id);\n    assert_eq!(book_wanted.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_create_books_wanted_with_invalid_book_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta criar um book_wanted com um book_id inexistente\n    let book_wanted = CreateBookWantedDto {\n        book_id: Uuid::new_v4(),\n        user_id: user.id,\n    };\n\n    let result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com book_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Livro com ID\"), \n        \"Erro deveria indicar que o livro não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_wanted_with_invalid_user_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"invalid_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Tenta criar um book_wanted com um user_id inexistente\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: Uuid::new_v4(),\n    };\n\n    let result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com user_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Usuário com ID\"), \n        \"Erro deveria indicar que o usuário não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_wanted_duplicate() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"duplicate_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    // Primeira inserção deve ter sucesso\n    let first_result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(first_result.is_ok(), \"A primeira inserção deveria ter sucesso\");\n\n    // Segunda inserção deve falhar com erro de duplicação\n    let second_result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(second_result.is_err(), \"A segunda inserção deveria falhar\");\n    \n    let error = second_result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"já está na sua lista\"), \n        \"Erro deveria indicar que o livro já está na lista: {:?}\", error\n    );\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","delete_books_wanted_test.rs"],"content":"use crate::models::book::CreateBookWantedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_wanted_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_delete_books_wanted() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_wanted_repository.create(\u0026book_wanted).await.unwrap();\n\n    // Verifica se o book_wanted foi criado corretamente\n    let find_result_before = books_wanted_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_before.is_some(), \"O book_wanted deveria existir antes da deleção\");\n\n    // Testa a deleção do book_wanted\n    let result = books_wanted_repository.delete(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao deletar book_wanted: {:?}\", result.err());\n    assert!(result.unwrap(), \"A deleção deveria retornar true\");\n\n    // Verifica se foi realmente deletado\n    let find_result_after = books_wanted_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_after.is_none(), \"O book_wanted não foi deletado corretamente\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_wanted_nonexistent() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta deletar um book_wanted inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_wanted_repository.delete(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A deleção deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(!result.unwrap(), \"Deleção de ID inexistente deveria retornar false\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_wanted_multiple_users() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_multi_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria books_wanted para ambos os usuários\n    let book_wanted1 = CreateBookWantedDto {\n        book_id,\n        user_id: user1.id,\n    };\n    \n    let book_wanted2 = CreateBookWantedDto {\n        book_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_wanted_repository.create(\u0026book_wanted1).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted2).await.unwrap();\n\n    // Deleta apenas para o usuário 1\n    let delete_result = books_wanted_repository.delete(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o usuário 1 deveria ter sucesso\");\n\n    // Verifica se foi removido para o usuário 1\n    let find_result1 = books_wanted_repository.find(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro não deveria mais estar oferecido pelo usuário 1\");\n\n    // Verifica se ainda existe para o usuário 2\n    let find_result2 = books_wanted_repository.find(\u0026book_id, \u0026user2.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro ainda deveria estar oferecido pelo usuário 2\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_wanted_multiple_books() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"delete_book1_test\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"delete_book2_test\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria books_wanted para ambos os livros\n    let book_wanted1 = CreateBookWantedDto {\n        book_id: book1_id,\n        user_id: user.id,\n    };\n    \n    let book_wanted2 = CreateBookWantedDto {\n        book_id: book2_id,\n        user_id: user.id,\n    };\n\n    // Insere as relações\n    books_wanted_repository.create(\u0026book_wanted1).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted2).await.unwrap();\n\n    // Deleta apenas o livro 1\n    let delete_result = books_wanted_repository.delete(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o livro 1 deveria ter sucesso\");\n\n    // Verifica se o livro 1 foi removido\n    let find_result1 = books_wanted_repository.find(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro 1 não deveria mais estar oferecido\");\n\n    // Verifica se o livro 2 ainda existe\n    let find_result2 = books_wanted_repository.find(\u0026book2_id, \u0026user.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro 2 ainda deveria estar oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","find_books_wanted_test.rs"],"content":"use crate::models::book::CreateBookWantedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_wanted_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_find_books_wanted() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_wanted_repository.create(\u0026book_wanted).await.unwrap();\n\n    // Testa a busca do book_wanted\n    let result = books_wanted_repository.find(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao buscar book_wanted: {:?}\", result.err());\n    \n    let found = result.unwrap();\n    assert!(found.is_some(), \"Book wanted não encontrado\");\n    \n    let found = found.unwrap();\n    assert_eq!(found.book_id, book_id);\n    assert_eq!(found.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_find_books_wanted_nonexistent_book() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Testa busca com book_id inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_wanted_repository.find(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_wanted com ID de livro inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_wanted_nonexistent_user() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_nonexistent_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa busca com user_id inexistente\n    let non_existent_user_id = Uuid::new_v4();\n    let result = books_wanted_repository.find(\u0026book_id, \u0026non_existent_user_id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com user_id inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_wanted com user_id inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_wanted_multiple_entries() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"find_multi_test1\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"find_multi_test2\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria várias relações de books_wanted\n    let book_wanted1 = CreateBookWantedDto {\n        book_id: book1_id,\n        user_id: user1.id,\n    };\n    \n    let book_wanted2 = CreateBookWantedDto {\n        book_id: book2_id,\n        user_id: user1.id,\n    };\n    \n    let book_wanted3 = CreateBookWantedDto {\n        book_id: book1_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_wanted_repository.create(\u0026book_wanted1).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted2).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted3).await.unwrap();\n\n    // Teste 1: Usuário 1 oferece o Livro 1\n    let result1 = books_wanted_repository.find(\u0026book1_id, \u0026user1.id).await.unwrap();\n    assert!(result1.is_some(), \"Usuário 1 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 2: Usuário 1 oferece o Livro 2\n    let result2 = books_wanted_repository.find(\u0026book2_id, \u0026user1.id).await.unwrap();\n    assert!(result2.is_some(), \"Usuário 1 deveria ter o Livro 2 como oferecido\");\n    \n    // Teste 3: Usuário 2 oferece o Livro 1\n    let result3 = books_wanted_repository.find(\u0026book1_id, \u0026user2.id).await.unwrap();\n    assert!(result3.is_some(), \"Usuário 2 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 4: Usuário 2 NÃO oferece o Livro 2\n    let result4 = books_wanted_repository.find(\u0026book2_id, \u0026user2.id).await.unwrap();\n    assert!(result4.is_none(), \"Usuário 2 não deveria ter o Livro 2 como oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","mod.rs"],"content":"pub mod create_books_wanted_test;\npub mod find_books_wanted_test;\npub mod delete_books_wanted_test;\n\nuse crate::models::book::GoogleBookDto;\nuse crate::models::user::CreateUserDto;\nuse crate::repositories::book_repository::{BookRepository, PgBookRepository};\nuse crate::repositories::books_wanted_repository::{BooksWantedRepository, PgBooksWantedRepository};\nuse crate::repositories::test_helpers::{get_test_db_pool, clean_database};\nuse crate::repositories::user_repository::{UserRepository, PgUserRepository};\nuse uuid::Uuid;\n\n// Cria uma função de setup de repositório para o PgBookRepository\npub async fn setup_book_repository() -\u003e impl BookRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBookRepository::new(pool)\n}\n\n// Cria uma função de setup de repositório para o PgUserRepository\npub async fn setup_user_repository() -\u003e impl UserRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgUserRepository::new(pool)\n}\n\n// Função para criar o repositório de books_wanted\npub async fn setup_test_repository() -\u003e impl BooksWantedRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBooksWantedRepository::new(pool)\n}\n\n// Função para criar um usuário de teste\npub fn create_test_user() -\u003e CreateUserDto {\n    CreateUserDto {\n        name: \"Test User\".to_string(),\n        email: format!(\"test_{}@example.com\", Uuid::new_v4()),\n        password: \"password\".to_string(),\n    }\n}\n\n// Função para criar um livro de teste\npub fn create_test_book(google_id: \u0026str) -\u003e GoogleBookDto {\n    GoogleBookDto {\n        google_id: google_id.to_string(),\n        title: \"Livro de Teste\".to_string(),\n        authors: Some(\"Autor Teste\".to_string()),\n        publisher: Some(\"Editora Teste\".to_string()),\n        published_date: Some(\"2022-05-10\".to_string()),\n        description: Some(\"Descrição de teste\".to_string()),\n        image_url: Some(\"http://example.com/image.jpg\".to_string()),\n        page_count: Some(200),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","mod.rs"],"content":"pub mod book_repository;\npub mod user_repository;\npub mod books_offered_repository;\npub mod books_wanted_repository;\n#[cfg(test)]\npub mod user_repository_test;\n\n#[cfg(test)]\npub mod book_repository_test;\n\n#[cfg(test)]\npub mod books_offered_repository_test;\n\n#[cfg(test)]\npub mod books_wanted_repository_test;\n#[cfg(test)]\npub mod test_helpers {\n    use dotenv::dotenv;\n    use sqlx::PgPool;\n    use std::env;\n    use std::sync::Arc;\n    use tokio::sync::Mutex;\n\n    // Mutex para garantir que apenas um teste por vez acesse o banco\n    static TEST_MUTEX: tokio::sync::OnceCell\u003cArc\u003cMutex\u003c()\u003e\u003e\u003e = tokio::sync::OnceCell::const_new();\n\n    // Retorna um mutex para garantir a execução sequencial dos testes\n    pub async fn get_test_mutex() -\u003e Arc\u003cMutex\u003c()\u003e\u003e {\n        TEST_MUTEX\n            .get_or_init(|| async { Arc::new(Mutex::new(())) })\n            .await\n            .clone()\n    }\n\n    // Configura e retorna um pool de conexão com o banco de dados de teste\n    pub async fn get_test_db_pool() -\u003e PgPool {\n        // Carrega variáveis de ambiente\n        dotenv().ok();\n\n        // Usa as credenciais do banco de dados de teste\n        let db_user = env::var(\"POSTGRES_USER\").expect(\"POSTGRES_USER deve estar definido\");\n        let db_password =\n            env::var(\"POSTGRES_PASSWORD\").expect(\"POSTGRES_PASSWORD deve estar definido\");\n        let db_name = env::var(\"POSTGRES_TEST_DB\").expect(\"POSTGRES_TEST_DB deve estar definido\");\n        let db_port =\n            env::var(\"POSTGRES_TEST_PORT\").expect(\"POSTGRES_TEST_PORT deve estar definido\");\n\n        // Constrói a string de conexão para o banco de dados de teste\n        let connection_string = format!(\n            \"postgres://{}:{}@localhost:{}/{}\",\n            db_user, db_password, db_port, db_name\n        );\n\n        // Conecta ao banco de dados de teste\n        let pool = PgPool::connect(\u0026connection_string)\n            .await\n            .expect(\"Falha ao conectar ao banco de teste\");\n\n        clean_database(\u0026pool).await;\n\n        pool\n    }\n\n    // Limpa todas as tabelas do banco de teste para garantir um estado inicial conhecido\n    pub async fn clean_database(pool: \u0026PgPool) {\n        // Limpa todas as tabelas que possam afetar o teste\n        sqlx::query(\"TRUNCATE TABLE users CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela users\");\n\n        // Limpa outras tabelas relacionadas\n        sqlx::query(\"TRUNCATE TABLE books_wanted CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela books_wanted\");\n\n        sqlx::query(\"TRUNCATE TABLE books_offered CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela books_offered\");\n\n        sqlx::query(\"TRUNCATE TABLE trades CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela trades\");\n\n        sqlx::query(\"TRUNCATE TABLE books CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela books\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","user_repository.rs"],"content":"use async_trait::async_trait;\nuse sqlx::PgPool;\n\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, User};\n\n#[async_trait]\npub trait UserRepository: Send + Sync + 'static {\n    async fn create(\u0026self, user: \u0026CreateUserDto, hash_password: String) -\u003e Result\u003cUser, AppError\u003e;\n    async fn find_by_email(\u0026self, email: \u0026str) -\u003e Result\u003cOption\u003cUser\u003e, AppError\u003e;\n}\n\npub struct PgUserRepository {\n    pool: PgPool,\n}\n\nimpl PgUserRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl UserRepository for PgUserRepository {\n    async fn create(\u0026self, user: \u0026CreateUserDto, hash_password: String) -\u003e Result\u003cUser, AppError\u003e {\n        let result = sqlx::query_as::\u003c_, User\u003e(\n            \"INSERT INTO users (name, email, hash_password) VALUES ($1, $2, $3) RETURNING *\",\n        )\n        .bind(\u0026user.name)\n        .bind(\u0026user.email)\n        .bind(\u0026hash_password)\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| {\n            if e.to_string().contains(\"duplicate key\") {\n                AppError::ValidationError(\"Email já está em uso\".to_string())\n            } else {\n                AppError::DatabaseError(e.to_string())\n            }\n        })?;\n\n        Ok(result)\n    }\n\n    async fn find_by_email(\u0026self, email: \u0026str) -\u003e Result\u003cOption\u003cUser\u003e, AppError\u003e {\n        let result = sqlx::query_as::\u003c_, User\u003e(\"SELECT * FROM users WHERE email = $1\")\n            .bind(email)\n            .fetch_optional(\u0026self.pool)\n            .await\n            .map_err(AppError::from)?;\n\n        Ok(result)\n    }\n}\n","traces":[{"line":18,"address":[6936144],"length":1,"stats":{"Line":15}},{"line":25,"address":[6920727],"length":1,"stats":{"Line":30}},{"line":29,"address":[6802706],"length":1,"stats":{"Line":7}},{"line":30,"address":[6822566],"length":1,"stats":{"Line":8}},{"line":31,"address":[6812590],"length":1,"stats":{"Line":7}},{"line":33,"address":[6805700,6805362,6805416,6805472,6804940],"length":1,"stats":{"Line":30}},{"line":34,"address":[6802976,6803347],"length":1,"stats":{"Line":2}},{"line":35,"address":[3694619,3694672,3694953],"length":1,"stats":{"Line":6}},{"line":36,"address":[6806750],"length":1,"stats":{"Line":2}},{"line":38,"address":[6829423],"length":1,"stats":{"Line":0}},{"line":42,"address":[6828720],"length":1,"stats":{"Line":7}},{"line":45,"address":[6825267,6824160,6824297,6824195,6824452,6824701],"length":1,"stats":{"Line":19}},{"line":46,"address":[6807537,6807916,6807712,6807252,6807208,6807338],"length":1,"stats":{"Line":35}},{"line":47,"address":[6829991],"length":1,"stats":{"Line":6}},{"line":49,"address":[6824324,6824623,6824677,6824961,6824733],"length":1,"stats":{"Line":26}},{"line":50,"address":[6825196],"length":1,"stats":{"Line":0}},{"line":52,"address":[6804355],"length":1,"stats":{"Line":7}}],"covered":15,"coverable":17},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","user_repository_test.rs"],"content":"use crate::{\n    error::AppError,\n    models::user::CreateUserDto,\n    repositories::{\n        test_helpers::{get_test_db_pool, get_test_mutex},\n        user_repository::{PgUserRepository, UserRepository},\n    },\n};\nuse uuid::Uuid;\n\nasync fn setup_test_repository() -\u003e PgUserRepository {\n    // Obtém o pool de conexão com o banco de dados de teste\n    let pool = get_test_db_pool().await;\n    \n    // Criamos o DatabasePool com o pool real\n    PgUserRepository::new(pool)\n}\n\n#[tokio::test]\nasync fn test_create_user() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    let user = CreateUserDto {\n        name: \"Test User\".to_string(),\n        email: \"test@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n\n    // Hash simulado para testes\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    let created_user = user_repository\n        .create(\u0026user, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar usuário\");\n\n    assert_ne!(created_user.id, Uuid::nil());\n    assert_eq!(created_user.name, \"Test User\");\n    assert_eq!(created_user.email, \"test@example.com\");\n    assert_eq!(created_user.hash_password, hash_password);\n}\n\n#[tokio::test]\nasync fn test_find_by_email() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    // Cria um usuário para teste\n    let user = CreateUserDto {\n        name: \"Email Test\".to_string(),\n        email: \"find_by_email@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    // Insere o usuário no banco\n    let created_user = user_repository\n        .create(\u0026user, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar usuário\");\n\n    // Testa a busca por email com email existente\n    let found_user_opt = user_repository\n        .find_by_email(\"find_by_email@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(found_user_opt.is_some());\n\n    let found_user = found_user_opt.unwrap();\n    assert_eq!(found_user.id, created_user.id);\n    assert_eq!(found_user.email, \"find_by_email@example.com\");\n    assert_eq!(found_user.name, \"Email Test\");\n\n    // Testa a busca por email com email inexistente\n    let non_existent_result = user_repository\n        .find_by_email(\"nonexistent@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(non_existent_result.is_none());\n}\n\n#[tokio::test]\nasync fn test_email_exists() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    // Cria um usuário para teste\n    let user = CreateUserDto {\n        name: \"Email Exists Test\".to_string(),\n        email: \"email_exists@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    // Insere o usuário no banco\n    user_repository.create(\u0026user, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar usuário\");\n\n    // Verifica se email existe através de find_by_email para testar a funcionalidade\n    let found_user = user_repository\n        .find_by_email(\"email_exists@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(found_user.is_some());\n\n    // Verifica que email inexistente retorna None\n    let not_found = user_repository\n        .find_by_email(\"nonexistent@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(not_found.is_none());\n}\n\n#[tokio::test]\nasync fn test_duplicate_email() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    // Cria um primeiro usuário\n    let user1 = CreateUserDto {\n        name: \"First User\".to_string(),\n        email: \"duplicate@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    // Insere o primeiro usuário\n    user_repository.create(\u0026user1, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar primeiro usuário\");\n\n    // Tenta criar um segundo usuário com o mesmo email\n    let user2 = CreateUserDto {\n        name: \"Second User\".to_string(),\n        email: \"duplicate@example.com\".to_string(),\n        password: \"different_password\".to_string(),\n    };\n\n    // Deve falhar com erro de validação\n    let result = user_repository.create(\u0026user2, \"another_hash\".to_string()).await;\n    assert!(result.is_err());\n\n    // Verifica se é o tipo de erro esperado\n    match result {\n        Err(AppError::ValidationError(_)) =\u003e (),\n        _ =\u003e panic!(\"Esperava erro de validação para email duplicado\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","auth_routes.rs"],"content":"use std::sync::Arc;\n\nuse axum::{routing::post, Router};\nuse sqlx::PgPool;\n\nuse crate::config::Config;\nuse crate::handlers::auth_handler::AuthHandler;\nuse crate::repositories::user_repository::PgUserRepository;\nuse crate::services::auth_service::AuthServiceImpl;\nuse crate::services::password_service::create_password_service;\n\npub fn auth_routes(pool: Arc\u003cPgPool\u003e) -\u003e Router {\n    let config = Config::from_env().expect(\"Falha ao carregar configuração\");\n\n    let user_repository = Arc::new(PgUserRepository::new(pool.as_ref().clone()));\n    let password_service = create_password_service();\n\n    let auth_service = Arc::new(AuthServiceImpl::new(\n        user_repository,\n        password_service,\n        config,\n    ));\n\n    let auth_handler = Arc::new(AuthHandler::new(auth_service));\n\n    let handler_clone = auth_handler.clone();\n\n    Router::new()\n        .route(\n            \"/api/auth/register\",\n            post(move |body| async move { handler_clone.register(body).await }),\n        )\n        .route(\n            \"/api/auth/login\",\n            post(move |body| async move { auth_handler.login(body).await }),\n        )\n}\n","traces":[{"line":12,"address":[6999029,6998913,6997696],"length":1,"stats":{"Line":15}},{"line":13,"address":[6996758,6996866],"length":1,"stats":{"Line":28}},{"line":15,"address":[6997944,6997877],"length":1,"stats":{"Line":30}},{"line":16,"address":[6998023,6998095],"length":1,"stats":{"Line":30}},{"line":18,"address":[6997252],"length":1,"stats":{"Line":15}},{"line":19,"address":[6935215],"length":1,"stats":{"Line":15}},{"line":21,"address":[6997167],"length":1,"stats":{"Line":15}},{"line":24,"address":[7023547],"length":1,"stats":{"Line":15}},{"line":26,"address":[7008166,7008236],"length":1,"stats":{"Line":30}},{"line":28,"address":[5121681,5121819,5121986],"length":1,"stats":{"Line":45}},{"line":31,"address":[6998509],"length":1,"stats":{"Line":58}},{"line":35,"address":[7388806,7388880,7388768,7389258,7388915],"length":1,"stats":{"Line":37}}],"covered":12,"coverable":12},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","book_offered_routes.rs"],"content":"use std::sync::Arc;\n\nuse axum::{\n    routing::{delete, post},\n    Router,\n};\nuse sqlx::PgPool;\n\nuse crate::{\n    handlers::book_offered_handler::BookOfferedHandler,\n    repositories::{\n        book_repository::PgBookRepository, \n        books_offered_repository::PgBooksOfferedRepository,\n        books_wanted_repository::PgBooksWantedRepository\n    },\n    routes::protect_routes,\n    services::{\n        book_offered_service::BookOfferedServiceImpl,\n        google_book_service::GoogleBookServiceImpl,\n        http_service::HttpServiceImpl,\n    },\n};\n\npub fn book_offered_routes(pool: Arc\u003cPgPool\u003e) -\u003e Router {\n    // Repositórios\n    let book_repository = Arc::new(PgBookRepository::new(pool.as_ref().clone()));\n    let books_offered_repository = Arc::new(PgBooksOfferedRepository::new(pool.as_ref().clone()));\n    let books_wanted_repository = Arc::new(PgBooksWantedRepository::new(pool.as_ref().clone()));\n    \n    // Serviço HTTP\n    let http_service = Arc::new(HttpServiceImpl::new());\n    \n    // Serviço do Google Books\n    let google_book_service = Arc::new(GoogleBookServiceImpl::new(http_service));\n    \n    // Serviço de Livros Oferecidos\n    let book_offered_service = Arc::new(BookOfferedServiceImpl::new(\n        book_repository,\n        books_offered_repository,\n        books_wanted_repository,\n        google_book_service,\n    ));\n\n    // Handler\n    let book_offered_handler = Arc::new(BookOfferedHandler::new(book_offered_service));\n    let handler_clone = book_offered_handler.clone();\n    let handler_clone2 = book_offered_handler.clone();\n\n    // Configurar rotas protegidas\n    protect_routes(\n        Router::new()\n            .route(\n                \"/api/books/offered\",\n                post(move |user_id, body| async move {\n                    handler_clone.add_book_to_offered(user_id, body).await\n                }),\n            )\n            .route(\n                \"/api/books/offered/:book_id\",\n                delete(move |user_id, path| async move {\n                    handler_clone2.remove_book_from_offered(user_id, path).await\n                }),\n            ),\n    )\n} ","traces":[{"line":24,"address":[7073816,7073957,7072144],"length":1,"stats":{"Line":11}},{"line":26,"address":[7045951,7046086],"length":1,"stats":{"Line":22}},{"line":27,"address":[7067043,7066967],"length":1,"stats":{"Line":22}},{"line":28,"address":[7072656,7072580],"length":1,"stats":{"Line":22}},{"line":31,"address":[7072803,7072741],"length":1,"stats":{"Line":23}},{"line":34,"address":[7046608],"length":1,"stats":{"Line":9}},{"line":37,"address":[7046723],"length":1,"stats":{"Line":9}},{"line":38,"address":[4138139],"length":1,"stats":{"Line":17}},{"line":39,"address":[7072915],"length":1,"stats":{"Line":12}},{"line":40,"address":[7057475],"length":1,"stats":{"Line":12}},{"line":45,"address":[7046821],"length":1,"stats":{"Line":13}},{"line":46,"address":[7047848,7047921],"length":1,"stats":{"Line":27}},{"line":47,"address":[7046977,7047044],"length":1,"stats":{"Line":22}},{"line":51,"address":[6985278,6985448,6985124],"length":1,"stats":{"Line":40}},{"line":53,"address":[7057885],"length":1,"stats":{"Line":10}},{"line":54,"address":[7048085],"length":1,"stats":{"Line":21}},{"line":55,"address":[6946759,6946424,6946563,6946500],"length":1,"stats":{"Line":6}},{"line":60,"address":[7068076],"length":1,"stats":{"Line":14}},{"line":61,"address":[3592740,3592960,3592696,3592795],"length":1,"stats":{"Line":3}}],"covered":19,"coverable":19},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","google_book_routes.rs"],"content":"use std::sync::Arc;\n\nuse axum::{routing::post, Router};\n\nuse crate::{\n    handlers::google_book_handler::GoogleBookHandler, routes::protect_routes,\n    services::google_book_service::GoogleBookServiceImpl, services::http_service::HttpServiceImpl,\n};\n\npub fn google_book_routes() -\u003e Router {\n    // Serviço HTTP\n    let http_service = Arc::new(HttpServiceImpl::new());\n\n    // Serviço do Google Books\n    let book_service = Arc::new(GoogleBookServiceImpl::new(http_service));\n\n    // Handler\n    let book_handler = Arc::new(GoogleBookHandler::new(book_service));\n    let handler_clone = book_handler.clone();\n\n    // Configurar rota protegida\n    protect_routes(Router::new().route(\n        \"/api/books/search\",\n        post(move |body| async move { handler_clone.search_books(body).await }),\n    ))\n}\n","traces":[{"line":10,"address":[6960450,6960478,6959936],"length":1,"stats":{"Line":15}},{"line":12,"address":[6939168],"length":1,"stats":{"Line":15}},{"line":15,"address":[6940176],"length":1,"stats":{"Line":8}},{"line":18,"address":[3748266],"length":1,"stats":{"Line":12}},{"line":19,"address":[6960145,6960078],"length":1,"stats":{"Line":21}},{"line":22,"address":[6940485,6940556,6940334],"length":1,"stats":{"Line":32}},{"line":23,"address":[6960215],"length":1,"stats":{"Line":13}},{"line":24,"address":[4186166,4186144,4186275,4186240,4186578],"length":1,"stats":{"Line":29}}],"covered":8,"coverable":8},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","mod.rs"],"content":"pub mod auth_routes;\npub mod book_offered_routes;\npub mod google_book_routes;\n\nuse axum::{middleware::from_fn, Router};\n\nuse crate::middleware::auth_middleware::auth_middleware;\n\n/// Função auxiliar para aplicar o middleware de autenticação a qualquer rota\n///\n/// Esta função facilita a proteção de rotas, mantendo consistência na aplicação\n/// do middleware de autenticação em todo o projeto.\npub fn protect_routes(router: Router) -\u003e Router {\n    router.layer(from_fn(auth_middleware))\n}\n","traces":[{"line":13,"address":[7283006,7282977,7282832],"length":1,"stats":{"Line":13}},{"line":14,"address":[7282848,7282990],"length":1,"stats":{"Line":10}}],"covered":2,"coverable":2},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\nuse chrono::{Duration, Utc};\nuse jsonwebtoken::{encode, EncodingKey, Header};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\nuse crate::config::Config;\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, LoginUserDto, TokenResponse, UserResponse};\nuse crate::repositories::user_repository::UserRepository;\nuse crate::services::password_service::PasswordService;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct TokenClaims {\n    pub sub: String,\n    pub iat: usize,\n    pub exp: usize,\n}\n\n#[async_trait]\npub trait AuthService: Send + Sync + 'static {\n    async fn register(\u0026self, user_dto: CreateUserDto) -\u003e Result\u003cUserResponse, AppError\u003e;\n    async fn login(\u0026self, login_dto: LoginUserDto) -\u003e Result\u003cTokenResponse, AppError\u003e;\n}\n\npub struct AuthServiceImpl {\n    user_repository: Arc\u003cdyn UserRepository\u003e,\n    password_service: Arc\u003cdyn PasswordService\u003e,\n    config: Config,\n}\n\nimpl AuthServiceImpl {\n    pub fn new(\n        user_repository: Arc\u003cdyn UserRepository\u003e,\n        password_service: Arc\u003cdyn PasswordService\u003e,\n        config: Config,\n    ) -\u003e Self {\n        Self {\n            user_repository,\n            password_service,\n            config,\n        }\n    }\n\n    fn generate_token(\u0026self, user_id: \u0026Uuid) -\u003e Result\u003cString, AppError\u003e {\n        let now = Utc::now();\n        let iat = now.timestamp() as usize;\n        let exp = (now + Duration::hours(self.config.jwt_expires_in.parse::\u003ci64\u003e().unwrap()))\n            .timestamp() as usize;\n\n        let claims = TokenClaims {\n            sub: user_id.to_string(),\n            iat,\n            exp,\n        };\n\n        encode(\n            \u0026Header::default(),\n            \u0026claims,\n            \u0026EncodingKey::from_secret(self.config.jwt_secret.as_bytes()),\n        )\n        .map_err(|e| AppError::InternalServerError(format!(\"Erro ao gerar token: {}\", e)))\n    }\n}\n\n#[async_trait]\nimpl AuthService for AuthServiceImpl {\n    async fn register(\u0026self, user_dto: CreateUserDto) -\u003e Result\u003cUserResponse, AppError\u003e {\n        // Validar entrada usando as validações do DTO\n        user_dto.validate_all()?;\n\n        // Hash da senha usando o adapter\n        let hash_password = self.password_service.hash_password(\u0026user_dto.password)?;\n\n        // Criar usuário\n        let user = self\n            .user_repository\n            .create(\u0026user_dto, hash_password)\n            .await?;\n\n        Ok(UserResponse::from(user))\n    }\n\n    async fn login(\u0026self, login_dto: LoginUserDto) -\u003e Result\u003cTokenResponse, AppError\u003e {\n        // Validar entrada usando as validações do DTO\n        login_dto.validate_all()?;\n\n        // Buscar usuário pelo email\n        let user = self\n            .user_repository\n            .find_by_email(\u0026login_dto.email)\n            .await?\n            .ok_or_else(|| AppError::AuthError(\"Credenciais inválidas\".to_string()))?;\n\n        // Verificar senha usando o adapter\n        let is_valid = self\n            .password_service\n            .verify_password(\u0026login_dto.password, \u0026user.hash_password)?;\n        if !is_valid {\n            return Err(AppError::AuthError(\"Credenciais inválidas\".to_string()));\n        }\n\n        // Gerar token\n        let token = self.generate_token(\u0026user.id)?;\n\n        Ok(TokenResponse {\n            access_token: token,\n            token_type: \"Bearer\".to_string(),\n            user: UserResponse::from(user),\n        })\n    }\n}\n","traces":[{"line":35,"address":[7097376],"length":1,"stats":{"Line":16}},{"line":47,"address":[7114784,7115604],"length":1,"stats":{"Line":9}},{"line":48,"address":[7104811],"length":1,"stats":{"Line":7}},{"line":49,"address":[7120278],"length":1,"stats":{"Line":9}},{"line":50,"address":[4011827,4011974],"length":1,"stats":{"Line":16}},{"line":54,"address":[7105098],"length":1,"stats":{"Line":7}},{"line":60,"address":[7115189],"length":1,"stats":{"Line":9}},{"line":62,"address":[7032537,7032610],"length":1,"stats":{"Line":16}},{"line":64,"address":[7270528,7270550,7270714],"length":1,"stats":{"Line":0}},{"line":70,"address":[7095199],"length":1,"stats":{"Line":48}},{"line":72,"address":[7215653,7215491,7215570,7216339],"length":1,"stats":{"Line":28}},{"line":75,"address":[7276828,7277520,7277211,7276984],"length":1,"stats":{"Line":22}},{"line":78,"address":[7304611,7303410,7303944,7303624,7304134,7303691],"length":1,"stats":{"Line":37}},{"line":80,"address":[7303570],"length":1,"stats":{"Line":7}},{"line":81,"address":[6679332],"length":1,"stats":{"Line":29}},{"line":83,"address":[4305553,4305802],"length":1,"stats":{"Line":14}},{"line":86,"address":[7283377,7285825,7282795,7282605,7285725,7282400,7282447],"length":1,"stats":{"Line":25}},{"line":88,"address":[7306101,7305609,7305784,7305688],"length":1,"stats":{"Line":16}},{"line":91,"address":[7279517,7279763,7280056,7280243,7279834,7282327,7280884,7280480],"length":1,"stats":{"Line":36}},{"line":93,"address":[4306984],"length":1,"stats":{"Line":7}},{"line":94,"address":[6652724],"length":1,"stats":{"Line":26}},{"line":95,"address":[6653735,6653786],"length":1,"stats":{"Line":6}},{"line":98,"address":[7220015,7221109,7219615,7219889],"length":1,"stats":{"Line":14}},{"line":100,"address":[7280985,7281183],"length":1,"stats":{"Line":8}},{"line":101,"address":[7284649],"length":1,"stats":{"Line":9}},{"line":102,"address":[7307476,7307545],"length":1,"stats":{"Line":4}},{"line":106,"address":[7292253,7292051,7293072,7292401],"length":1,"stats":{"Line":14}},{"line":108,"address":[7282897],"length":1,"stats":{"Line":7}},{"line":109,"address":[7302354],"length":1,"stats":{"Line":9}},{"line":110,"address":[7285074],"length":1,"stats":{"Line":7}},{"line":111,"address":[7281746],"length":1,"stats":{"Line":9}}],"covered":30,"coverable":31},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service_test","login_tests.rs"],"content":"use super::*;\nuse crate::models::user::{LoginUserDto, User};\nuse crate::services::auth_service::AuthServiceImpl;\nuse mockall::predicate;\nuse std::sync::Arc;\n\n/// Testa o login com credenciais válidas\n///\n/// Verifica se:\n/// 1. O login é bem-sucedido com email e senha corretos\n/// 2. O token é gerado corretamente\n/// 3. Os dados do usuário são retornados corretamente\n#[tokio::test]\nasync fn success_with_valid_credentials() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n    let user_id = Uuid::new_v4();\n    let test_timestamp = create_test_timestamp();\n\n    // Mock para retornar um usuário quando buscado por email\n    mock_repo\n        .expect_find_by_email()\n        .with(predicate::eq(\"teste@example.com\"))\n        .returning(move |_| {\n            Ok(Some(User {\n                id: user_id,\n                name: \"Teste\".to_string(),\n                email: \"teste@example.com\".to_string(),\n                hash_password: \"hash_password\".to_string(),\n                created_at: test_timestamp,\n                updated_at: test_timestamp,\n            }))\n        });\n\n    // Criar mock do PasswordService configurado para retornar true (senha válida)\n    let mock_password_service = create_mock_password_service(\"hash_dummy\".to_string(), true);\n\n    // Criar serviço de autenticação com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Act\n    let login_dto = LoginUserDto {\n        email: \"teste@example.com\".to_string(),\n        password: \"senha123\".to_string(),\n    };\n\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(result.is_ok(), \"O login deveria ter sido bem-sucedido\");\n\n    if let Ok(token_response) = result {\n        assert_eq!(token_response.token_type, \"Bearer\");\n        assert!(!token_response.access_token.is_empty());\n        assert_eq!(token_response.user.name, \"Teste\");\n        assert_eq!(token_response.user.email, \"teste@example.com\");\n    }\n}\n\n/// Testa falhas de validação em campos obrigatórios durante o login\n///\n/// Este teste parametrizado verifica se o login falha apropriadamente quando:\n/// - O email está vazio\n/// - O email tem formato inválido\n/// - O email é muito longo\n/// - A senha está vazia\n///\n/// E valida que a mensagem de erro contém o texto esperado em cada caso.\n#[tokio::test]\nasync fn fail_with_invalid_fields() {\n    // Casos de teste parametrizados\n    let test_cases = vec![\n        InvalidFieldTestCase {\n            name: \"email vazio\",\n            field_name: \"email\",\n            user_name: \"\",  // não importa para login\n            user_email: \"\", // Email vazio\n            user_password: \"senha123\",\n            expected_message: \"O email não pode estar vazio\",\n        },\n        InvalidFieldTestCase {\n            name: \"formato de email inválido\",\n            field_name: \"email\",\n            user_name: \"\",                // não importa para login\n            user_email: \"email_invalido\", // Email com formato inválido\n            user_password: \"senha123\",\n            expected_message: \"Formato de email inválido\",\n        },\n        // Para o teste de email longo, vamos adicioná-lo diretamente no teste\n        // e não na lista de casos, para evitar problemas de lifetime\n    ];\n\n    // Executar testes para cada caso de validação\n    for test_case in test_cases {\n        // Arrange\n        let mock_repo = MockUserRepository::new();\n\n        // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n        let mock_password_service =\n            create_mock_password_service(\"hashed_password\".to_string(), true);\n\n        let auth_service = AuthServiceImpl::new(\n            Arc::new(mock_repo),\n            mock_password_service,\n            create_test_config(),\n        );\n\n        let login_dto = LoginUserDto {\n            email: test_case.user_email.to_string(),\n            password: test_case.user_password.to_string(),\n        };\n\n        // Act\n        let result = auth_service.login(login_dto).await;\n\n        // Assert\n        assert!(\n            result.is_err(),\n            \"O login deveria falhar com {} inválido/vazio\",\n            test_case.field_name\n        );\n\n        assert_validation_error_with_message(\n            \u0026result.unwrap_err(),\n            test_case.expected_message,\n            \u0026format!(\"Erro ao validar {}\", test_case.name),\n        );\n    }\n\n    // Teste específico para email longo\n    let mock_repo = MockUserRepository::new();\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Criar um email longo (acima do limite)\n    let long_email = \"A\".repeat(256);\n    let login_dto = LoginUserDto {\n        email: long_email,\n        password: \"senha123\".to_string(),\n    };\n\n    // Act\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O login deveria falhar com email muito longo\"\n    );\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"O email deve ter menos de 255 caracteres\",\n        \"Erro ao validar email muito longo\",\n    );\n\n    // Teste para senha vazia\n    let mock_repo = MockUserRepository::new();\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let login_dto = LoginUserDto {\n        email: \"teste@example.com\".to_string(),\n        password: \"\".to_string(),\n    };\n\n    // Act\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(result.is_err(), \"O login deveria falhar com senha vazia\");\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"A senha não pode estar vazia\",\n        \"Erro ao validar senha vazia\",\n    );\n}\n\n/// Testa o login com email inexistente\n///\n/// Verifica se:\n/// 1. O login falha quando o email não existe no banco\n/// 2. A mensagem de erro indica \"Credenciais inválidas\" (sem expor se o email existe ou não)\n#[tokio::test]\nasync fn fail_with_invalid_email() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Mock retorna None (usuário não encontrado)\n    mock_repo\n        .expect_find_by_email()\n        .with(predicate::eq(\"nao_existe@example.com\"))\n        .returning(|_| Ok(None));\n\n    // Criar mock do PasswordService (não importa a configuração, pois o email não existe)\n    let mock_password_service = create_mock_password_service(\"hash_dummy\".to_string(), true);\n\n    // Criar serviço de autenticação com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Act\n    let login_dto = LoginUserDto {\n        email: \"nao_existe@example.com\".to_string(),\n        password: \"senha123\".to_string(),\n    };\n\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(result.is_err(), \"O login deveria falhar com email inválido\");\n    assert_auth_error_with_message(\n        \u0026result.unwrap_err(),\n        \"Credenciais inválidas\",\n        \"Erro ao fazer login com email inválido\",\n    );\n}\n\n/// Testa o login com senha incorreta\n///\n/// Verifica se:\n/// 1. O login falha quando a senha está incorreta\n/// 2. A mensagem de erro indica \"Credenciais inválidas\" (sem especificar que a senha está errada)\n#[tokio::test]\nasync fn fail_with_invalid_password() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n    let user_id = Uuid::new_v4();\n    let test_timestamp = create_test_timestamp();\n\n    // Mock retorna um usuário (email existe)\n    mock_repo\n        .expect_find_by_email()\n        .with(predicate::eq(\"teste@example.com\"))\n        .returning(move |_| {\n            Ok(Some(User {\n                id: user_id,\n                name: \"Teste\".to_string(),\n                email: \"teste@example.com\".to_string(),\n                hash_password: \"hash_password\".to_string(),\n                created_at: test_timestamp,\n                updated_at: test_timestamp,\n            }))\n        });\n\n    // Criar mock do PasswordService configurado para retornar false (senha inválida)\n    let mock_password_service = create_mock_password_service(\"hash_dummy\".to_string(), false);\n\n    // Criar serviço de autenticação com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Act\n    let login_dto = LoginUserDto {\n        email: \"teste@example.com\".to_string(),\n        password: \"senha_incorreta\".to_string(),\n    };\n\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O login deveria falhar com senha incorreta\"\n    );\n    assert_auth_error_with_message(\n        \u0026result.unwrap_err(),\n        \"Credenciais inválidas\",\n        \"Erro ao fazer login com senha incorreta\",\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service_test","mod.rs"],"content":"use async_trait::async_trait;\nuse chrono::DateTime;\nuse mockall::mock;\nuse std::sync::Arc;\nuse uuid::Uuid;\n\nuse crate::config::Config;\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, User};\nuse crate::repositories::user_repository::UserRepository;\nuse crate::services::auth_service::AuthService;\nuse crate::services::password_service::PasswordService;\n\n// Módulos de testes\npub mod login_tests;\npub mod register_tests;\n\n// ----- Mocks para os testes -----\n\n// Mock do UserRepository\nmock! {\n    pub UserRepository {}\n\n    #[async_trait]\n    impl UserRepository for UserRepository {\n        async fn create(\u0026self, user: \u0026CreateUserDto, hash_password: String) -\u003e Result\u003cUser, AppError\u003e;\n        async fn find_by_email(\u0026self, email: \u0026str) -\u003e Result\u003cOption\u003cUser\u003e, AppError\u003e;\n    }\n}\n\n// Mock do PasswordService\nmock! {\n    pub PasswordService {}\n\n    #[async_trait]\n    impl PasswordService for PasswordService {\n        fn hash_password(\u0026self, password: \u0026str) -\u003e Result\u003cString, AppError\u003e;\n        fn verify_password(\u0026self, password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, AppError\u003e;\n    }\n}\n\n// ----- Funções auxiliares para preparação de testes -----\n\n/// Cria uma configuração padrão para testes\npub fn create_test_config() -\u003e Config {\n    Config {\n        database_url: \"postgres://dummy\".to_string(),\n        jwt_secret: \"test_secret\".to_string(),\n        jwt_expires_in: \"1\".to_string(),\n        port: 8080,\n    }\n}\n\n/// Cria um timestamp fictício para testes\npub fn create_test_timestamp() -\u003e chrono::NaiveDateTime {\n    let timestamp = DateTime::from_timestamp(61, 0).unwrap();\n    timestamp.naive_utc()\n}\n\n/// Cria um usuário fictício para testes\npub fn create_test_user(name: \u0026str, email: \u0026str) -\u003e User {\n    User {\n        id: Uuid::new_v4(),\n        name: name.to_string(),\n        email: email.to_string(),\n        hash_password: \"hashed_password\".to_string(),\n        created_at: create_test_timestamp(),\n        updated_at: create_test_timestamp(),\n    }\n}\n\n/// Cria um DTO de usuário para testes\npub fn create_user_dto(name: \u0026str, email: \u0026str, password: \u0026str) -\u003e CreateUserDto {\n    CreateUserDto {\n        name: name.to_string(),\n        email: email.to_string(),\n        password: password.to_string(),\n    }\n}\n\n/// Cria um mock do PasswordService configurado para testes\npub fn create_mock_password_service(\n    hash_result: String,\n    verify_result: bool,\n) -\u003e Arc\u003cMockPasswordService\u003e {\n    let mut mock_service = MockPasswordService::new();\n\n    // Configure o comportamento do mock para hash_password\n    mock_service\n        .expect_hash_password()\n        .returning(move |_| Ok(hash_result.clone()));\n\n    // Configure o comportamento do mock para verify_password\n    mock_service\n        .expect_verify_password()\n        .returning(move |_, _| Ok(verify_result));\n\n    Arc::new(mock_service)\n}\n\n// Struct para facilitar parametrização de testes\npub struct InvalidFieldTestCase {\n    pub name: \u0026'static str,             // Nome do caso de teste\n    pub field_name: \u0026'static str,       // Nome do campo sendo testado\n    pub user_name: \u0026'static str,        // Valor para o campo nome\n    pub user_email: \u0026'static str,       // Valor para o campo email\n    pub user_password: \u0026'static str,    // Valor para o campo senha\n    pub expected_message: \u0026'static str, // Mensagem de erro esperada\n}\n\n// ----- Funções auxiliares para verificação de erros -----\n\n/// Verifica se o erro é do tipo esperado e contém a mensagem esperada\npub fn assert_error_with_message(\n    err: \u0026AppError,\n    error_type: \u0026str,\n    expected_message: \u0026str,\n    context: \u0026str,\n) {\n    match (err, error_type) {\n        (AppError::ValidationError(msg), \"ValidationError\") =\u003e {\n            assert!(\n                msg.contains(expected_message),\n                \"{}: Mensagem de erro inesperada: '{}', esperava que contivesse: '{}'\",\n                context,\n                msg,\n                expected_message\n            );\n        }\n        (AppError::AuthError(msg), \"AuthError\") =\u003e {\n            assert!(\n                msg.contains(expected_message),\n                \"{}: Mensagem de erro inesperada: '{}', esperava que contivesse: '{}'\",\n                context,\n                msg,\n                expected_message\n            );\n        }\n        (AppError::DatabaseError(msg), \"DatabaseError\") =\u003e {\n            assert!(\n                msg.contains(expected_message),\n                \"{}: Mensagem de erro inesperada: '{}', esperava que contivesse: '{}'\",\n                context,\n                msg,\n                expected_message\n            );\n        }\n        _ =\u003e panic!(\n            \"{}: Tipo de erro inesperado: {:?}, esperava {}\",\n            context, err, error_type\n        ),\n    }\n}\n\n/// Verifica se o erro é do tipo ValidationError e contém a mensagem esperada\npub fn assert_validation_error_with_message(err: \u0026AppError, expected_message: \u0026str, context: \u0026str) {\n    assert_error_with_message(err, \"ValidationError\", expected_message, context);\n}\n\n/// Verifica se o erro é do tipo AuthError e contém a mensagem esperada\npub fn assert_auth_error_with_message(err: \u0026AppError, expected_message: \u0026str, context: \u0026str) {\n    assert_error_with_message(err, \"AuthError\", expected_message, context);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service_test","register_tests.rs"],"content":"use super::*;\nuse crate::error::AppError;\nuse crate::services::auth_service::AuthServiceImpl;\nuse mockall::predicate;\nuse std::sync::Arc;\n\n/// Testa o registro de usuário com dados válidos\n///\n/// Verifica se:\n/// 1. O registro é bem-sucedido quando todos os campos são válidos\n/// 2. O objeto UserResponse retornado contém os dados corretos do usuário\n#[tokio::test]\nasync fn success_with_valid_data() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Configurar mock para retornar sucesso\n    mock_repo\n        .expect_create()\n        .with(\n            predicate::function(|user: \u0026CreateUserDto| {\n                user.name == \"Teste\"\n                    \u0026\u0026 user.email == \"teste@example.com\"\n                    \u0026\u0026 user.password.len() \u003e= 6\n            }),\n            predicate::always(),\n        )\n        .returning(|user, _| Ok(create_test_user(\u0026user.name, \u0026user.email)));\n\n    // Criar mock do PasswordService que retorna um hash fixo\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    // Criar o serviço com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"teste@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(result.is_ok(), \"O registro deveria ter sido bem-sucedido\");\n\n    if let Ok(user_response) = result {\n        assert_eq!(user_response.name, \"Teste\");\n        assert_eq!(user_response.email, \"teste@example.com\");\n    }\n}\n\n/// Testa falhas de validação em campos obrigatórios durante o registro\n///\n/// Este teste parametrizado verifica se o registro falha apropriadamente quando:\n/// - O nome está vazio\n/// - O email está vazio\n/// - A senha está vazia\n///\n/// E valida que a mensagem de erro contém o texto esperado em cada caso.\n#[tokio::test]\nasync fn fail_with_invalid_fields() {\n    // Casos de teste parametrizados\n    let test_cases = vec![\n        InvalidFieldTestCase {\n            name: \"nome vazio\",\n            field_name: \"nome\",\n            user_name: \"\",\n            user_email: \"teste@example.com\",\n            user_password: \"senha123\",\n            expected_message: \"O nome não pode estar vazio\",\n        },\n        InvalidFieldTestCase {\n            name: \"email vazio\",\n            field_name: \"email\",\n            user_name: \"Teste\",\n            user_email: \"\",\n            user_password: \"senha123\",\n            expected_message: \"O email não pode estar vazio\",\n        },\n        InvalidFieldTestCase {\n            name: \"senha vazia\",\n            field_name: \"senha\",\n            user_name: \"Teste\",\n            user_email: \"teste@example.com\",\n            user_password: \"\",\n            expected_message: \"deve ter pelo menos 6\",\n        },\n    ];\n\n    // Executar testes para cada caso de validação\n    for test_case in test_cases {\n        // Arrange\n        let mock_repo = MockUserRepository::new();\n\n        // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n        let mock_password_service =\n            create_mock_password_service(\"hashed_password\".to_string(), true);\n\n        let auth_service = AuthServiceImpl::new(\n            Arc::new(mock_repo),\n            mock_password_service,\n            create_test_config(),\n        );\n\n        let dto = create_user_dto(\n            test_case.user_name,\n            test_case.user_email,\n            test_case.user_password,\n        );\n\n        // Act\n        let result = auth_service.register(dto).await;\n\n        // Assert\n        assert!(\n            result.is_err(),\n            \"O registro deveria falhar com {} vazio\",\n            test_case.field_name\n        );\n\n        assert_validation_error_with_message(\n            \u0026result.unwrap_err(),\n            test_case.expected_message,\n            \u0026format!(\"Erro ao validar {}\", test_case.name),\n        );\n    }\n}\n\n/// Testa o registro de usuário com senha muito curta (menos de 6 caracteres)\n///\n/// Verifica se:\n/// 1. O registro falha apropriadamente\n/// 2. A mensagem de erro indica que a senha precisa ter pelo menos 6 caracteres\n#[tokio::test]\nasync fn fail_with_short_password() {\n    // Arrange\n    let mock_repo = MockUserRepository::new();\n\n    // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"teste@example.com\", \"12345\"); // Menos de 6 caracteres\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(result.is_err(), \"O registro deveria falhar com senha curta\");\n\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"A senha deve ter pelo menos 6 caracteres\",\n        \"Erro ao validar tamanho mínimo da senha\",\n    );\n}\n\n/// Testa o registro de usuário com email já existente\n///\n/// Verifica se:\n/// 1. O registro falha quando o email já está em uso\n/// 2. A mensagem de erro indica especificamente que o email já está em uso\n#[tokio::test]\nasync fn fail_with_duplicate_email() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Simular erro de duplicação de email\n    mock_repo\n        .expect_create()\n        .with(predicate::always(), predicate::always())\n        .returning(|_, _| {\n            Err(AppError::ValidationError(\n                \"Email já está em uso\".to_string(),\n            ))\n        });\n\n    // Criar mock do PasswordService\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"email_existente@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O registro deveria falhar com email duplicado\"\n    );\n\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"Email já está em uso\",\n        \"Erro ao validar email duplicado\",\n    );\n}\n\n/// Testa o registro de usuário com nome muito longo\n///\n/// Verifica se:\n/// 1. O registro falha quando o nome é excessivamente longo\n/// 2. A mensagem de erro indica que o nome é muito longo\n#[tokio::test]\nasync fn fail_with_long_name() {\n    // Arrange\n    let mock_repo = MockUserRepository::new();\n\n    // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Criar um nome com 256 caracteres (acima do limite)\n    let long_name = \"A\".repeat(256);\n    let dto = create_user_dto(\u0026long_name, \"teste@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O registro deveria falhar com nome muito longo\"\n    );\n\n    assert_error_with_message(\n        \u0026result.unwrap_err(),\n        \"ValidationError\",\n        \"O nome deve ter menos de 255 caracteres\",\n        \"Erro ao validar nome com tamanho excessivo\",\n    );\n}\n\n/// Testa o comportamento quando o repositório retorna um erro de banco de dados\n///\n/// Verifica se:\n/// 1. O erro do repositório é propagado corretamente pelo serviço\n/// 2. A mensagem de erro é mantida intacta\n#[tokio::test]\nasync fn fail_with_database_error() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Configurar mock para retornar um erro de banco de dados\n    mock_repo\n        .expect_create()\n        .with(predicate::always(), predicate::always())\n        .returning(|_, _| {\n            Err(AppError::DatabaseError(\n                \"Erro de conexão com o banco de dados\".to_string(),\n            ))\n        });\n\n    // Criar mock do PasswordService\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"teste@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O registro deveria falhar com erro de banco de dados\"\n    );\n\n    assert_error_with_message(\n        \u0026result.unwrap_err(),\n        \"DatabaseError\",\n        \"Erro de conexão com o banco de dados\",\n        \"Erro ao lidar com falha do repositório\",\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_offered_service.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookOffered, CreateBookOfferedDto};\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::services::google_book_service::GoogleBookService;\n\n#[async_trait]\npub trait BookOfferedService: Send + Sync + 'static {\n    async fn add_book_to_offered(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookOffered, AppError\u003e;\n    async fn remove_book_from_offered(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct BookOfferedServiceImpl {\n    book_repository: Arc\u003cdyn BookRepository\u003e,\n    books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n    books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n    google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n}\n\nimpl BookOfferedServiceImpl {\n    pub fn new(\n        book_repository: Arc\u003cdyn BookRepository\u003e,\n        books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n        books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n        google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n    ) -\u003e Self {\n        Self {\n            book_repository,\n            books_offered_repository,\n            books_wanted_repository,\n            google_book_service,\n        }\n    }\n}\n\n#[async_trait]\nimpl BookOfferedService for BookOfferedServiceImpl {\n    async fn add_book_to_offered(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookOffered, AppError\u003e {\n        // Variável para armazenar o UUID do banco de dados\n        let book_uuid: Uuid;\n        \n        // Verificar se o livro existe no banco de dados e obter seu ID interno\n        let existing_book = self.book_repository.find_by_google_id(google_id).await?;\n        \n        if let Some(book_with_id) = existing_book {\n            // Se o livro já existe, usar o ID existente\n            book_uuid = book_with_id.id;\n        } else {\n            // Livro não existe, precisa ser criado\n            // Buscar do Google Books API\n            let book_dto = self.google_book_service.find_book_by_id(google_id).await?;\n            \n            // Criar o livro no banco de dados\n            book_uuid = self.book_repository.create(\u0026book_dto).await?;\n        }\n        \n        // Verificar se o livro já está na lista de desejados do usuário\n        if let Some(_) = self.books_wanted_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de desejados\".to_string()));\n        }\n        \n        // Verificar se o livro já está na lista de possuídos do usuário\n        if let Some(_) = self.books_offered_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de possuídos\".to_string()));\n        }\n        \n        // Criar DTO para adicionar à lista de possuídos\n        let create_dto = CreateBookOfferedDto {\n            book_id: book_uuid,\n            user_id: *user_id,\n        };\n\n        // Adicionar à lista de livros possuídos\n        let book_offered = self.books_offered_repository.create(\u0026create_dto).await?;\n\n        Ok(book_offered)\n    }\n\n    async fn remove_book_from_offered(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        // Verificar se o livro existe na lista de possuídos do usuário\n        let exists = self.books_offered_repository.find(book_id, user_id).await?;\n        if exists.is_none() {\n            return Err(AppError::ValidationError(\n                \"Este livro não está na sua lista de possuídos\".to_string(),\n            ));\n        }\n\n        // Remover da lista de livros possuídos\n        self.books_offered_repository.delete(book_id, user_id).await\n    }\n} ","traces":[{"line":27,"address":[7404736],"length":1,"stats":{"Line":14}},{"line":44,"address":[7412183],"length":1,"stats":{"Line":9}},{"line":49,"address":[7601697,7602216,7601015,7600695,7601306,7601115],"length":1,"stats":{"Line":8}},{"line":51,"address":[7626918,7627030],"length":1,"stats":{"Line":6}},{"line":53,"address":[7627091],"length":1,"stats":{"Line":3}},{"line":57,"address":[7627141,7627511,7625980,7627321,7627933,7628221],"length":1,"stats":{"Line":7}},{"line":60,"address":[7602627,7602805,7600737,7603339,7603006],"length":1,"stats":{"Line":2}},{"line":64,"address":[7627256,7628688,7629614,7626022,7628870],"length":1,"stats":{"Line":8}},{"line":65,"address":[7623892,7623818],"length":1,"stats":{"Line":2}},{"line":69,"address":[7599819,7603065,7603395,7603255,7604218],"length":1,"stats":{"Line":8}},{"line":70,"address":[7624567,7624731],"length":1,"stats":{"Line":4}},{"line":76,"address":[7624624],"length":1,"stats":{"Line":3}},{"line":80,"address":[7630128,7630447,7631043,7626064,7630895,7630318],"length":1,"stats":{"Line":8}},{"line":82,"address":[7604559],"length":1,"stats":{"Line":3}},{"line":85,"address":[7401622],"length":1,"stats":{"Line":6}},{"line":87,"address":[6659919],"length":1,"stats":{"Line":3}},{"line":88,"address":[4332458,4332366],"length":1,"stats":{"Line":4}},{"line":89,"address":[4332654],"length":1,"stats":{"Line":2}},{"line":90,"address":[7632329],"length":1,"stats":{"Line":2}},{"line":95,"address":[6660898],"length":1,"stats":{"Line":5}}],"covered":20,"coverable":20},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_offered_wanted_service_test","add_book_to_offered_test.rs"],"content":"use std::sync::Arc;\n\nuse mockall::predicate::*;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookOffered, BookWanted, CreateBookOfferedDto, GoogleBookDto};\nuse crate::repositories::book_repository::BookWithId;\nuse crate::services::book_offered_service::{BookOfferedService, BookOfferedServiceImpl};\nuse crate::services::book_offered_wanted_service_test::{MockBookRepository, MockBooksOfferedRepository, MockBooksWantedRepository, MockGoogleBookService};\n\n#[tokio::test]\nasync fn test_add_book_to_offered_when_book_exists() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n    \n    let google_id = \"test123\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar Some para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(move |_| {\n            Ok(Some(BookWithId {\n                id: book_id,\n                book: GoogleBookDto {\n                    google_id: google_id.to_string(),\n                    title: \"Livro Teste\".to_string(),\n                    authors: None,\n                    publisher: None,\n                    published_date: None,\n                    description: None,\n                    image_url: None,\n                    page_count: None,\n                }\n            }))\n        });\n\n    // Configurar o mock do books_wanted_repository para retornar None para find\n    // (indicando que o livro não está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_offered_repository para retornar None para find\n    // (indicando que o livro ainda não está na lista de possuídos)\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_offered_repository para retornar um BookOffered para create\n    books_offered_repo\n        .expect_create()\n        .with(function(move |dto: \u0026CreateBookOfferedDto| {\n            dto.book_id == book_id \u0026\u0026 dto.user_id == user_id\n        }))\n        .times(1)\n        .returning(move |dto| {\n            Ok(BookOffered {\n                book_id: dto.book_id,\n                user_id: dto.user_id,\n            })\n        });\n\n    // Google Book Service não será usado neste teste, pois o livro já existe\n    let google_book_service = MockGoogleBookService::new();\n\n    // Act\n    let service = BookOfferedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_offered(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_ok());\n    let book_offered = result.unwrap();\n    assert_eq!(book_offered.book_id, book_id);\n    assert_eq!(book_offered.user_id, user_id);\n}\n\n#[tokio::test]\nasync fn test_add_book_to_offered_when_book_does_not_exist() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n\n    let google_id = \"new_book123\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar None para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(|_| Ok(None));\n\n    // Configurar o mock do google_book_service para retornar um livro\n    let google_book_service = MockGoogleBookService::new()\n        .with_find_book_by_id(move |id| {\n            assert_eq!(id, google_id);\n            Ok(GoogleBookDto {\n                google_id: google_id.to_string(),\n                title: \"Novo Livro\".to_string(),\n                authors: None,\n                publisher: None,\n                published_date: None,\n                description: None,\n                image_url: None,\n                page_count: None,\n            })\n        });\n\n    // Configurar o mock do book_repository para retornar um UUID para create\n    book_repo\n        .expect_create()\n        .times(1)\n        .returning(move |_| Ok(book_id));\n\n    // Configurar o mock do books_wanted_repository para retornar None para find\n    // (indicando que o livro não está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_offered_repository para retornar None para find\n    // (indicando que o livro ainda não está na lista de possuídos)\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_offered_repository para retornar um BookOffered para create\n    books_offered_repo\n        .expect_create()\n        .with(function(move |dto: \u0026CreateBookOfferedDto| {\n            dto.book_id == book_id \u0026\u0026 dto.user_id == user_id\n        }))\n        .times(1)\n        .returning(move |dto| {\n            Ok(BookOffered {\n                book_id: dto.book_id,\n                user_id: dto.user_id,\n            })\n        });\n\n    // Act\n    let service = BookOfferedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_offered(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_ok());\n    let book_offered = result.unwrap();\n    assert_eq!(book_offered.book_id, book_id);\n    assert_eq!(book_offered.user_id, user_id);\n}\n\n#[tokio::test]\nasync fn test_add_book_to_offered_when_book_already_offered() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n\n    let google_id = \"already_offered123\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar Some para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(move |_| {\n            Ok(Some(BookWithId {\n                id: book_id,\n                book: GoogleBookDto {\n                    google_id: google_id.to_string(),\n                    title: \"Livro Já Oferecido\".to_string(),\n                    authors: None,\n                    publisher: None,\n                    published_date: None,\n                    description: None,\n                    image_url: None,\n                    page_count: None,\n                }\n            }))\n        });\n\n    // Configurar o mock do books_wanted_repository para retornar None para find\n    // (indicando que o livro não está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_offered_repository para retornar Some para find\n    // (indicando que o livro já está na lista de possuídos)\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(move |book_id, user_id| {\n            Ok(Some(BookOffered {\n                book_id: *book_id,\n                user_id: *user_id,\n            }))\n        });\n\n    // Google Book Service não será usado neste teste\n    let google_book_service = MockGoogleBookService::new();\n\n    // Act\n    let service = BookOfferedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_offered(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_err());\n    match result {\n        Err(AppError::ValidationError(msg)) =\u003e {\n            assert_eq!(msg, \"Este livro já está na sua lista de possuídos\");\n        }\n        _ =\u003e panic!(\"Erro inesperado\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_add_book_to_offered_when_book_already_wanted() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n    let books_offered_repo = MockBooksOfferedRepository::new();\n\n    let google_id = \"already_wanted123\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar Some para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(move |_| {\n            Ok(Some(BookWithId {\n                id: book_id,\n                book: GoogleBookDto {\n                    google_id: google_id.to_string(),\n                    title: \"Livro Já Desejado\".to_string(),\n                    authors: None,\n                    publisher: None,\n                    published_date: None,\n                    description: None,\n                    image_url: None,\n                    page_count: None,\n                }\n            }))\n        });\n\n    // Configurar o mock do books_wanted_repository para retornar Some para find\n    // (indicando que o livro já está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(move |book_id, user_id| {\n            Ok(Some(BookWanted {\n                book_id: *book_id,\n                user_id: *user_id,\n            }))\n        });\n\n    // Google Book Service não será usado neste teste\n    let google_book_service = MockGoogleBookService::new();\n\n    // Act\n    let service = BookOfferedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_offered(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_err());\n    match result {\n        Err(AppError::ValidationError(msg)) =\u003e {\n            assert_eq!(msg, \"Este livro já está na sua lista de desejados\");\n        }\n        _ =\u003e panic!(\"Erro inesperado\"),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_offered_wanted_service_test","add_book_to_wanted_test.rs"],"content":"use std::sync::Arc;\n\nuse mockall::predicate::*;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookWanted, BookOffered, CreateBookWantedDto, GoogleBookDto};\nuse crate::repositories::book_repository::BookWithId;\nuse crate::services::book_wanted_service::{BookWantedService, BookWantedServiceImpl};\nuse crate::services::book_offered_wanted_service_test::{MockBookRepository, MockBooksWantedRepository, MockBooksOfferedRepository, MockGoogleBookService};\n\n#[tokio::test]\nasync fn test_add_book_to_wanted_when_book_exists() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n    \n    let google_id = \"offered\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar Some para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(move |_| {\n            Ok(Some(BookWithId {\n                id: book_id,\n                book: GoogleBookDto {\n                    google_id: google_id.to_string(),\n                    title: \"Livro Teste\".to_string(),\n                    authors: None,\n                    publisher: None,\n                    published_date: None,\n                    description: None,\n                    image_url: None,\n                    page_count: None,\n                }\n            }))\n        });\n\n    // Configurar o mock do books_offered_repository para retornar None para find\n    // (indicando que o livro não está na lista de possuídos)\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_wanted_repository para retornar None para find\n    // (indicando que o livro ainda não está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_wanted_repository para retornar um BookWanted para create\n    books_wanted_repo\n        .expect_create()\n        .with(function(move |dto: \u0026CreateBookWantedDto| {\n            dto.book_id == book_id \u0026\u0026 dto.user_id == user_id\n        }))\n        .times(1)\n        .returning(move |dto| {\n            Ok(BookWanted {\n                book_id: dto.book_id,\n                user_id: dto.user_id,\n            })\n        });\n\n    // Google Book Service não será usado neste teste, pois o livro já existe\n    let google_book_service = MockGoogleBookService::new();\n\n    // Act\n    let service = BookWantedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_wanted(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_ok());\n    let book_wanted = result.unwrap();\n    assert_eq!(book_wanted.book_id, book_id);\n    assert_eq!(book_wanted.user_id, user_id);\n}\n\n#[tokio::test]\nasync fn test_add_book_to_wanted_when_book_does_not_exist() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n\n    let google_id = \"new_book123\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar None para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(|_| Ok(None));\n\n    // Configurar o mock do google_book_service para retornar um livro\n    let google_book_service = MockGoogleBookService::new()\n        .with_find_book_by_id(move |id| {\n            assert_eq!(id, google_id);\n            Ok(GoogleBookDto {\n                google_id: google_id.to_string(),\n                title: \"Novo Livro\".to_string(),\n                authors: None,\n                publisher: None,\n                published_date: None,\n                description: None,\n                image_url: None,\n                page_count: None,\n            })\n        });\n\n    // Configurar o mock do book_repository para retornar um UUID para create\n    book_repo\n        .expect_create()\n        .times(1)\n        .returning(move |_| Ok(book_id));\n\n    // Configurar o mock do books_offered_repository para retornar None para find\n    // (indicando que o livro não está na lista de possuídos)\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_wanted_repository para retornar None para find\n    // (indicando que o livro ainda não está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_wanted_repository para retornar um BookWanted para create\n    books_wanted_repo\n        .expect_create()\n        .with(function(move |dto: \u0026CreateBookWantedDto| {\n            dto.book_id == book_id \u0026\u0026 dto.user_id == user_id\n        }))\n        .times(1)\n        .returning(move |dto| {\n            Ok(BookWanted {\n                book_id: dto.book_id,\n                user_id: dto.user_id,\n            })\n        });\n\n    // Act\n    let service = BookWantedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_wanted(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_ok());\n    let book_wanted = result.unwrap();\n    assert_eq!(book_wanted.book_id, book_id);\n    assert_eq!(book_wanted.user_id, user_id);\n}\n\n#[tokio::test]\nasync fn test_add_book_to_wanted_when_book_already_wanted() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n    let books_offered_repo = MockBooksOfferedRepository::new();\n\n    let google_id = \"already_wanted123\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar Some para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(move |_| {\n            Ok(Some(BookWithId {\n                id: book_id,\n                book: GoogleBookDto {\n                    google_id: google_id.to_string(),\n                    title: \"Livro Já Oferecido\".to_string(),\n                    authors: None,\n                    publisher: None,\n                    published_date: None,\n                    description: None,\n                    image_url: None,\n                    page_count: None,\n                }\n            }))\n        });\n\n    // // Configurar o mock do books_offered_repository para retornar None para find\n    // // (indicando que o livro não está na lista de possuídos)\n    // books_offered_repo\n    //     .expect_find()\n    //     .with(eq(book_id), eq(user_id))\n    //     .times(1)\n    //     .returning(|_, _| Ok(None));\n\n    // Configurar o mock do books_wanted_repository para retornar Some para find\n    // (indicando que o livro já está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(move |book_id, user_id| {\n            Ok(Some(BookWanted {\n                book_id: *book_id,\n                user_id: *user_id,\n            }))\n        });\n\n    // Google Book Service não será usado neste teste\n    let google_book_service = MockGoogleBookService::new();\n\n    // Act\n    let service = BookWantedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_wanted(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_err());\n    match result {\n        Err(AppError::ValidationError(msg)) =\u003e {\n            assert_eq!(msg, \"Este livro já está na sua lista de desejados\");\n        }\n        _ =\u003e panic!(\"Erro inesperado\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_add_book_to_wanted_when_book_already_offered() {\n    // Arrange\n    let mut book_repo = MockBookRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n\n    let google_id = \"already_offered123\";\n    let user_id = Uuid::new_v4();\n    let book_id = Uuid::new_v4();\n\n    // Configurar o mock do book_repository para retornar Some para find_by_google_id\n    book_repo\n        .expect_find_by_google_id()\n        .with(eq(google_id))\n        .times(1)\n        .returning(move |_| {\n            Ok(Some(BookWithId {\n                id: book_id,\n                book: GoogleBookDto {\n                    google_id: google_id.to_string(),\n                    title: \"Livro Já Desejado\".to_string(),\n                    authors: None,\n                    publisher: None,\n                    published_date: None,\n                    description: None,\n                    image_url: None,\n                    page_count: None,\n                }\n            }))\n        });\n\n    // Configurar o mock do books_offered_repository para retornar Some para find\n    // (indicando que o livro já está na lista de possuídos)\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(move |book_id, user_id| {\n            Ok(Some(BookOffered {\n                book_id: *book_id,\n                user_id: *user_id,\n            }))\n        });\n\n\n    // Configurar o mock do books_wanted_repository para retornar None para find\n    // (indicando que o livro não está na lista de desejados)\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Google Book Service não será usado neste teste\n    let google_book_service = MockGoogleBookService::new();\n\n    // Act\n    let service = BookWantedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.add_book_to_wanted(google_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_err());\n    match result {\n        Err(AppError::ValidationError(msg)) =\u003e {\n            assert_eq!(msg, \"Este livro já está na sua lista de possuídos\");\n        }\n        _ =\u003e panic!(\"Erro inesperado\"),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_offered_wanted_service_test","mod.rs"],"content":"pub mod add_book_to_offered_test;\npub mod remove_book_from_offered_test;\npub mod add_book_to_wanted_test;\npub mod remove_book_from_wanted_test;\n\nuse mockall::{mock, predicate::*};\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookOffered, CreateBookOfferedDto, GoogleBookDto, BookWanted};\nuse crate::repositories::book_repository::BookWithId;\n\n// Mock para o BookRepository\nmock! {\n    pub BookRepository {}\n\n    #[async_trait::async_trait]\n    impl crate::repositories::book_repository::BookRepository for BookRepository {\n        async fn create(\u0026self, book: \u0026GoogleBookDto) -\u003e Result\u003cUuid, AppError\u003e;\n        async fn find_by_google_id(\u0026self, google_id: \u0026str) -\u003e Result\u003cOption\u003cBookWithId\u003e, AppError\u003e;\n        async fn find_by_id(\u0026self, id: \u0026str) -\u003e Result\u003cOption\u003cGoogleBookDto\u003e, AppError\u003e;\n    }\n}\n\n// Mock para o BooksOfferedRepository\nmock! {\n    pub BooksOfferedRepository {}\n\n    #[async_trait::async_trait]\n    impl crate::repositories::books_offered_repository::BooksOfferedRepository for BooksOfferedRepository {\n        async fn create(\u0026self, book_offered: \u0026CreateBookOfferedDto) -\u003e Result\u003cBookOffered, AppError\u003e;\n        async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookOffered\u003e, AppError\u003e;\n        async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n    }\n}\n\n// Mock para o BooksWantedRepository\nmock! {\n    pub BooksWantedRepository {}\n\n    #[async_trait::async_trait]\n    impl crate::repositories::books_wanted_repository::BooksWantedRepository for BooksWantedRepository {\n        async fn create(\u0026self, book_wanted: \u0026crate::models::book::CreateBookWantedDto) -\u003e Result\u003cBookWanted, AppError\u003e;\n        async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookWanted\u003e, AppError\u003e;\n        async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n    }\n}\n\n// Mock para o GoogleBookService - versão simplificada\n// O problema era com os lifetimes na trait original\npub struct MockGoogleBookService {\n    pub find_book_by_id_fn: Box\u003cdyn Fn(\u0026str) -\u003e Result\u003cGoogleBookDto, AppError\u003e + Send + Sync\u003e,\n}\n\nimpl MockGoogleBookService {\n    pub fn new() -\u003e Self {\n        // Por padrão, retorna um erro (será substituído nos testes)\n        Self {\n            find_book_by_id_fn: Box::new(|_| Err(AppError::NotFoundError(\"Livro não encontrado\".to_string()))),\n        }\n    }\n\n    pub fn with_find_book_by_id\u003cF\u003e(mut self, f: F) -\u003e Self \n    where \n        F: Fn(\u0026str) -\u003e Result\u003cGoogleBookDto, AppError\u003e + 'static + Send + Sync \n    {\n        self.find_book_by_id_fn = Box::new(f);\n        self\n    }\n}\n\nimpl crate::services::google_book_service::GoogleBookService for MockGoogleBookService {\n    fn search_books\u003c'a\u003e(\n        \u0026'a self,\n        _query: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cVec\u003cGoogleBookDto\u003e, AppError\u003e\u003e + Send + 'a\u003e\u003e {\n        // Podemos implementar se for necessário nos testes\n        Box::pin(async { Ok(vec![]) })\n    }\n\n    fn find_book_by_id\u003c'a\u003e(\n        \u0026'a self,\n        google_id: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cGoogleBookDto, AppError\u003e\u003e + Send + 'a\u003e\u003e {\n        let result = (self.find_book_by_id_fn)(google_id);\n        Box::pin(async move { result })\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_offered_wanted_service_test","remove_book_from_offered_test.rs"],"content":"use std::sync::Arc;\n\nuse mockall::predicate::*;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::BookOffered;\nuse crate::services::book_offered_service::{BookOfferedService, BookOfferedServiceImpl};\nuse crate::services::book_offered_wanted_service_test::{MockBookRepository, MockBooksOfferedRepository, MockBooksWantedRepository, MockGoogleBookService};\n\n#[tokio::test]\nasync fn test_remove_book_from_offered() {\n    // Arrange\n    let book_repo = MockBookRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n    let books_wanted_repo = MockBooksWantedRepository::new();\n    let google_book_service = MockGoogleBookService::new();\n\n    let book_id = Uuid::new_v4();\n    let user_id = Uuid::new_v4();\n\n    // Configurar o mock do books_offered_repository para retornar Some para find\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(move |book_id, user_id| {\n            Ok(Some(BookOffered {\n                book_id: *book_id,\n                user_id: *user_id,\n            }))\n        });\n\n    // Configurar o mock do books_offered_repository para retornar true para delete\n    books_offered_repo\n        .expect_delete()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(true));\n\n    // Act\n    let service = BookOfferedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.remove_book_from_offered(\u0026book_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), true);\n}\n\n#[tokio::test]\nasync fn test_remove_book_from_offered_when_not_offered() {\n    // Arrange\n    let book_repo = MockBookRepository::new();\n    let mut books_offered_repo = MockBooksOfferedRepository::new();\n    let books_wanted_repo = MockBooksWantedRepository::new();\n    let google_book_service = MockGoogleBookService::new();\n\n    let book_id = Uuid::new_v4();\n    let user_id = Uuid::new_v4();\n\n    // Configurar o mock do books_offered_repository para retornar None para find\n    books_offered_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Act\n    let service = BookOfferedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.remove_book_from_offered(\u0026book_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_err());\n    match result {\n        Err(AppError::ValidationError(msg)) =\u003e {\n            assert_eq!(msg, \"Este livro não está na sua lista de possuídos\");\n        }\n        _ =\u003e panic!(\"Erro inesperado\"),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_offered_wanted_service_test","remove_book_from_wanted_test.rs"],"content":"use std::sync::Arc;\n\nuse mockall::predicate::*;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::BookWanted;\nuse crate::services::book_wanted_service::{BookWantedService, BookWantedServiceImpl};\nuse crate::services::book_offered_wanted_service_test::{MockBookRepository, MockBooksWantedRepository, MockBooksOfferedRepository, MockGoogleBookService};\n\n#[tokio::test]\nasync fn test_remove_book_from_wanted() {\n    // Arrange\n    let book_repo = MockBookRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n    let books_offered_repo = MockBooksOfferedRepository::new();\n    let google_book_service = MockGoogleBookService::new();\n\n    let book_id = Uuid::new_v4();\n    let user_id = Uuid::new_v4();\n\n    // Configurar o mock do books_wanted_repository para retornar Some para find\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(move |book_id, user_id| {\n            Ok(Some(BookWanted {\n                book_id: *book_id,\n                user_id: *user_id,\n            }))\n        });\n\n    // Configurar o mock do books_wanted_repository para retornar true para delete\n    books_wanted_repo\n        .expect_delete()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(true));\n\n    // Act\n    let service = BookWantedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.remove_book_from_wanted(\u0026book_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), true);\n}\n\n#[tokio::test]\nasync fn test_remove_book_from_wanted_when_not_wanted() {\n    // Arrange\n    let book_repo = MockBookRepository::new();\n    let mut books_wanted_repo = MockBooksWantedRepository::new();\n    let books_offered_repo = MockBooksOfferedRepository::new();\n    let google_book_service = MockGoogleBookService::new();\n\n    let book_id = Uuid::new_v4();\n    let user_id = Uuid::new_v4();\n\n    // Configurar o mock do books_wanted_repository para retornar None para find\n    books_wanted_repo\n        .expect_find()\n        .with(eq(book_id), eq(user_id))\n        .times(1)\n        .returning(|_, _| Ok(None));\n\n    // Act\n    let service = BookWantedServiceImpl::new(\n        Arc::new(book_repo),\n        Arc::new(books_wanted_repo),\n        Arc::new(books_offered_repo),\n        Arc::new(google_book_service),\n    );\n\n    let result = service.remove_book_from_wanted(\u0026book_id, \u0026user_id).await;\n\n    // Assert\n    assert!(result.is_err());\n    match result {\n        Err(AppError::ValidationError(msg)) =\u003e {\n            assert_eq!(msg, \"Este livro não está na sua lista de desejados\");\n        }\n        _ =\u003e panic!(\"Erro inesperado\"),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_wanted_service.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookWanted, CreateBookWantedDto};\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::services::google_book_service::GoogleBookService;\n\n#[async_trait]\npub trait BookWantedService: Send + Sync + 'static {\n    async fn add_book_to_wanted(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookWanted, AppError\u003e;\n    async fn remove_book_from_wanted(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct BookWantedServiceImpl {\n    book_repository: Arc\u003cdyn BookRepository\u003e,\n    books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n    books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n    google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n}\n\nimpl BookWantedServiceImpl {\n    pub fn new(\n        book_repository: Arc\u003cdyn BookRepository\u003e,\n        books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n        books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n        google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n    ) -\u003e Self {\n        Self {\n            book_repository,\n            books_wanted_repository,\n            books_offered_repository,\n            google_book_service,\n        }\n    }\n}\n\n#[async_trait]\nimpl BookWantedService for BookWantedServiceImpl {\n    async fn add_book_to_wanted(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookWanted, AppError\u003e {\n        // Variável para armazenar o UUID do banco de dados\n        let book_uuid: Uuid;\n        \n        // Verificar se o livro existe no banco de dados e obter seu ID interno\n        let existing_book = self.book_repository.find_by_google_id(google_id).await?;\n        \n        if let Some(book_with_id) = existing_book {\n            // Se o livro já existe, usar o ID existente\n            book_uuid = book_with_id.id;\n        } else {\n            // Livro não existe, precisa ser criado\n            // Buscar do Google Books API\n            let book_dto = self.google_book_service.find_book_by_id(google_id).await?;\n            \n            // Criar o livro no banco de dados\n            book_uuid = self.book_repository.create(\u0026book_dto).await?;\n        }\n        \n        // Verificar se o livro já está na lista de desejados do usuário\n        if let Some(_) = self.books_wanted_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de desejados\".to_string()));\n        }\n        \n        // Verificar se o livro já está na lista de possuídos do usuário\n        if let Some(_) = self.books_offered_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de possuídos\".to_string()));\n        }\n        \n        // Criar DTO para adicionar à lista de desejados\n        let create_dto = CreateBookWantedDto {\n            book_id: book_uuid,\n            user_id: *user_id,\n        };\n\n        // Adicionar à lista de livros desejados\n        let book_wanted = self.books_wanted_repository.create(\u0026create_dto).await?;\n\n        Ok(book_wanted)\n    }\n\n    async fn remove_book_from_wanted(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        // Verificar se o livro existe na lista de desejados do usuário\n        let exists = self.books_wanted_repository.find(book_id, user_id).await?;\n        if exists.is_none() {\n            return Err(AppError::ValidationError(\n                \"Este livro não está na sua lista de desejados\".to_string(),\n            ));\n        }\n\n        // Remover da lista de livros desejados\n        self.books_wanted_repository.delete(book_id, user_id).await\n    }\n} ","traces":[{"line":27,"address":[4529232],"length":1,"stats":{"Line":1}},{"line":44,"address":[4488731,4488137,4488411,4489659,4487968,4488015],"length":1,"stats":{"Line":3}},{"line":49,"address":[4488167,4488763,4489637,4488576,4489138,4488483],"length":1,"stats":{"Line":2}},{"line":51,"address":[4489203,4489095],"length":1,"stats":{"Line":2}},{"line":53,"address":[4489264],"length":1,"stats":{"Line":1}},{"line":57,"address":[6595534],"length":1,"stats":{"Line":2}},{"line":60,"address":[6683720],"length":1,"stats":{"Line":2}},{"line":64,"address":[6660994],"length":1,"stats":{"Line":2}},{"line":65,"address":[4491331,4491401],"length":1,"stats":{"Line":2}},{"line":69,"address":[4491684,4492476,4491548,4488251,4491362],"length":1,"stats":{"Line":2}},{"line":70,"address":[4492052,4492209],"length":1,"stats":{"Line":2}},{"line":76,"address":[4492106],"length":1,"stats":{"Line":1}},{"line":80,"address":[6658534],"length":1,"stats":{"Line":2}},{"line":82,"address":[4492801],"length":1,"stats":{"Line":1}},{"line":85,"address":[4529574],"length":1,"stats":{"Line":3}},{"line":87,"address":[4493633,4493309,4494575,4494181,4493822],"length":1,"stats":{"Line":1}},{"line":88,"address":[4494158,4494250],"length":1,"stats":{"Line":2}},{"line":89,"address":[4494446],"length":1,"stats":{"Line":1}},{"line":90,"address":[4494289],"length":1,"stats":{"Line":1}},{"line":95,"address":[6660162],"length":1,"stats":{"Line":2}}],"covered":20,"coverable":20},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service.rs"],"content":"use crate::error::AppError;\nuse crate::models::book::GoogleBookDto;\nuse crate::services::http_service::HttpService;\nuse serde_json::Value;\nuse std::sync::Arc;\n\npub trait GoogleBookService: Send + Sync {\n    fn search_books\u003c'a\u003e(\n        \u0026'a self,\n        query: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cVec\u003cGoogleBookDto\u003e, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e;\n\n    fn find_book_by_id\u003c'a\u003e(\n        \u0026'a self,\n        google_id: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cGoogleBookDto, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e;\n}\n\npub struct GoogleBookServiceImpl {\n    http_service: Arc\u003cdyn HttpService\u003e,\n}\n\nimpl GoogleBookServiceImpl {\n    pub fn new(http_service: Arc\u003cdyn HttpService\u003e) -\u003e Self {\n        Self { http_service }\n    }\n\n    // Função auxiliar para converter JSON em GoogleBookDto\n    fn convert_to_google_book_dto(\u0026self, item: \u0026Value) -\u003e GoogleBookDto {\n        let google_id = item[\"id\"].as_str().unwrap_or_default().to_string();\n        let volume_info = \u0026item[\"volumeInfo\"];\n\n        // Extrair informações\n        let title = volume_info[\"title\"].as_str();\n        let title = title.unwrap_or_default().to_string();\n\n        // Processar autores\n        let authors = match volume_info[\"authors\"].as_array() {\n            Some(authors_array) =\u003e {\n                let mut authors_vec: Vec\u003cString\u003e = Vec::new();\n                for author in authors_array {\n                    if let Some(author_str) = author.as_str() {\n                        authors_vec.push(author_str.to_string());\n                    }\n                }\n                Some(authors_vec.join(\", \"))\n            }\n            None =\u003e None,\n        };\n\n        let publisher = volume_info[\"publisher\"].as_str().map(|s| s.to_string());\n\n        let published_date = match volume_info[\"publishedDate\"].as_str() {\n            Some(date_str) =\u003e Some(date_str.to_string()),\n            None =\u003e None,\n        };\n\n        let description = volume_info[\"description\"].as_str().map(|s| s.to_string());\n        let page_count = volume_info[\"pageCount\"].as_i64().map(|n| n as i32);\n\n        let image_url = match volume_info.get(\"imageLinks\") {\n            Some(image_links) =\u003e match image_links.get(\"thumbnail\") {\n                Some(thumbnail) =\u003e thumbnail.as_str().map(|s| s.to_string()),\n                None =\u003e None,\n            },\n            None =\u003e None,\n        };\n\n        GoogleBookDto {\n            google_id,\n            title,\n            authors,\n            publisher,\n            published_date,\n            description,\n            image_url,\n            page_count,\n        }\n    }\n}\n\nimpl GoogleBookService for GoogleBookServiceImpl {\n    fn search_books\u003c'a\u003e(\n        \u0026'a self,\n        query: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cVec\u003cGoogleBookDto\u003e, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e {\n        Box::pin(async move {\n            let mut url = String::from(\"https://www.googleapis.com/books/v1/volumes?q=\");\n            url.push_str(\u0026query);\n            url.push_str(\"\u0026fields=items(id,volumeInfo(title,authors,publisher,publishedDate,description,pageCount,imageLinks/thumbnail))\");\n\n            let data = self.http_service.get(\u0026url).await?;\n\n            let items = match data.get(\"items\") {\n                Some(items) =\u003e items,\n                None =\u003e return Ok(vec![]),\n            };\n\n            let mut books = Vec::new();\n\n            if let Some(items_array) = items.as_array() {\n                for item in items_array {\n                    let book = self.convert_to_google_book_dto(item);\n                    books.push(book);\n                }\n            }\n\n            Ok(books)\n        })\n    }\n\n    fn find_book_by_id\u003c'a\u003e(\n        \u0026'a self,\n        google_id: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cGoogleBookDto, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e {\n        Box::pin(async move {\n            let mut url = String::from(\"https://www.googleapis.com/books/v1/volumes/\");\n            url.push_str(\u0026google_id);\n            url.push_str(\"?fields=id,volumeInfo(title,authors,publisher,publishedDate,description,pageCount,imageLinks/thumbnail)\");\n\n            let data = match self.http_service.get(\u0026url).await {\n                Ok(data) =\u003e data,\n                Err(AppError::NotFoundError(_)) =\u003e {\n                    let message = format!(\"Livro com ID {} não encontrado\", google_id);\n                    return Err(AppError::NotFoundError(message));\n                }\n                Err(e) =\u003e return Err(e),\n            };\n\n            // Converter dados em GoogleBookDto\n            let book = self.convert_to_google_book_dto(\u0026data);\n            Ok(book)\n        })\n    }\n}\n","traces":[{"line":28,"address":[7267152],"length":1,"stats":{"Line":12}},{"line":33,"address":[7208679,7208843,7205984],"length":1,"stats":{"Line":5}},{"line":34,"address":[7270714],"length":1,"stats":{"Line":5}},{"line":35,"address":[7288208,7288125],"length":1,"stats":{"Line":10}},{"line":38,"address":[7206232],"length":1,"stats":{"Line":5}},{"line":39,"address":[7268497],"length":1,"stats":{"Line":5}},{"line":42,"address":[7271169,7271079],"length":1,"stats":{"Line":10}},{"line":43,"address":[7294005],"length":1,"stats":{"Line":5}},{"line":44,"address":[5082276],"length":1,"stats":{"Line":5}},{"line":45,"address":[7268091,7267968,7267881],"length":1,"stats":{"Line":15}},{"line":46,"address":[5082574,5084343],"length":1,"stats":{"Line":10}},{"line":47,"address":[7280753],"length":1,"stats":{"Line":5}},{"line":50,"address":[7268153,7268056],"length":1,"stats":{"Line":10}},{"line":52,"address":[7267761],"length":1,"stats":{"Line":1}},{"line":55,"address":[5082303,5082758],"length":1,"stats":{"Line":20}},{"line":57,"address":[7207155,7207239],"length":1,"stats":{"Line":10}},{"line":58,"address":[7269589,7269495],"length":1,"stats":{"Line":10}},{"line":59,"address":[7289299],"length":1,"stats":{"Line":4}},{"line":62,"address":[7413654,7413632],"length":1,"stats":{"Line":20}},{"line":63,"address":[5083243,5083323],"length":1,"stats":{"Line":20}},{"line":65,"address":[7268962],"length":1,"stats":{"Line":5}},{"line":66,"address":[7270710,7270012],"length":1,"stats":{"Line":10}},{"line":67,"address":[7438960,7438982],"length":1,"stats":{"Line":15}},{"line":68,"address":[7270747],"length":1,"stats":{"Line":0}},{"line":70,"address":[7269992],"length":1,"stats":{"Line":4}},{"line":87,"address":[7290848],"length":1,"stats":{"Line":5}},{"line":93,"address":[4753234,4751660,4751703,4751520,4751567,4752057],"length":1,"stats":{"Line":17}},{"line":94,"address":[7413853],"length":1,"stats":{"Line":6}},{"line":95,"address":[4751750],"length":1,"stats":{"Line":5}},{"line":96,"address":[4751824],"length":1,"stats":{"Line":6}},{"line":98,"address":[7435339,7433738,7434145,7434503,7433903],"length":1,"stats":{"Line":11}},{"line":100,"address":[7413683,7413837],"length":1,"stats":{"Line":10}},{"line":101,"address":[7417365],"length":1,"stats":{"Line":5}},{"line":102,"address":[7434658,7434717],"length":1,"stats":{"Line":4}},{"line":105,"address":[7417386],"length":1,"stats":{"Line":5}},{"line":107,"address":[7417564,7417499],"length":1,"stats":{"Line":10}},{"line":108,"address":[7434929,7435058],"length":1,"stats":{"Line":10}},{"line":109,"address":[7435158],"length":1,"stats":{"Line":5}},{"line":110,"address":[4753093],"length":1,"stats":{"Line":5}},{"line":114,"address":[7417638],"length":1,"stats":{"Line":5}},{"line":118,"address":[7296480],"length":1,"stats":{"Line":2}},{"line":124,"address":[7291062],"length":1,"stats":{"Line":6}},{"line":125,"address":[4753333],"length":1,"stats":{"Line":2}},{"line":126,"address":[7425533],"length":1,"stats":{"Line":2}},{"line":127,"address":[4753521],"length":1,"stats":{"Line":2}},{"line":129,"address":[6677332],"length":1,"stats":{"Line":8}},{"line":130,"address":[4754061],"length":1,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[7442136,7441908],"length":1,"stats":{"Line":4}},{"line":133,"address":[7426801],"length":1,"stats":{"Line":2}},{"line":135,"address":[7436495],"length":1,"stats":{"Line":1}},{"line":139,"address":[7415465],"length":1,"stats":{"Line":1}},{"line":140,"address":[7415589],"length":1,"stats":{"Line":1}}],"covered":51,"coverable":53},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service_test","find_book_by_id_tests.rs"],"content":"use crate::services::google_book_service::{GoogleBookService, GoogleBookServiceImpl};\nuse crate::services::http_service::{HttpService, HttpServiceImpl};\nuse std::sync::Arc;\nuse crate::error::AppError;\nuse serde_json::json;\n\n// Implementação para mock do HttpService\nstruct MockHttpService {\n    response: Option\u003cserde_json::Value\u003e,\n    error: Option\u003cAppError\u003e,\n}\n\nimpl MockHttpService {\n    fn new_success(response: serde_json::Value) -\u003e Self {\n        Self {\n            response: Some(response),\n            error: None,\n        }\n    }\n\n    fn new_error(error: AppError) -\u003e Self {\n        Self {\n            response: None,\n            error: Some(error),\n        }\n    }\n}\n\nimpl HttpService for MockHttpService {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        _url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cserde_json::Value, AppError\u003e\u003e + Send + 'a\u003e\u003e {\n        let response = self.response.clone();\n        let error = self.error.clone();\n\n        Box::pin(async move {\n            match (response, error) {\n                (Some(resp), _) =\u003e Ok(resp),\n                (_, Some(err)) =\u003e Err(err),\n                _ =\u003e Err(AppError::InternalServerError(\"Nenhuma resposta ou erro configurado\".to_string())),\n            }\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn find_book_by_id_test() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // ID de um livro bem conhecido\n        let book_id = \"YyXoAAAACAAJ\"; // Clean Code de Robert Martin\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca de livro por ID deveria ser bem-sucedida\");\n\n        let book = result.unwrap();\n        assert_eq!(book.google_id, book_id, \"O ID do livro deve corresponder ao solicitado\");\n        assert!(!book.title.is_empty(), \"O título não deve estar vazio\");\n    }\n\n    #[tokio::test]\n    async fn test_find_book_by_id_invalid_id() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // ID inválido que não deve existir\n        let book_id = \"invalid_id_12345678900987654321\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"A busca com ID inválido deve falhar\");\n    }\n\n    #[tokio::test]\n    async fn test_find_book_by_id_empty_id() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        let book_id = \"\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"A busca com ID vazio deve falhar\");\n    }\n\n    #[tokio::test]\n    async fn test_find_book_by_id_real_book_details() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // ID de um livro específico da O'Reilly sobre Rust\n        let book_id = \"0weDoAEACAAJ\"; // \"Programming Rust\" de Jim Blandy\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca por ID válido deve ser bem-sucedida\");\n\n        let book = result.unwrap();\n        assert_eq!(book.google_id, book_id);\n        \n        // Validações de campos obrigatórios\n        assert!(!book.title.is_empty(), \"Título deve estar presente\");\n        \n        // Verificação de campos opcionais com conteúdo esperado\n        if let Some(authors) = book.authors {\n            assert!(!authors.is_empty(), \"Lista de autores não deve estar vazia quando presente\");\n        }\n        \n        if let Some(description) = book.description {\n            assert!(!description.is_empty(), \"Descrição não deve estar vazia quando presente\");\n        }\n        \n        if let Some(image_url) = book.image_url {\n            assert!(image_url.starts_with(\"http\"), \"URL da imagem deve ser válida\");\n        }\n    }\n\n    // Teste usando mock para simular erro 404 (NotFoundError)\n    #[tokio::test]\n    async fn test_find_book_by_id_not_found_error() {\n        // Arrange\n        // Criar um mock do HttpService que retorna erro NotFoundError\n        let mock_http_service = Arc::new(MockHttpService::new_error(\n            AppError::NotFoundError(\"Recurso não encontrado\".to_string())\n        ));\n        \n        let service = GoogleBookServiceImpl::new(mock_http_service);\n        let book_id = \"test_not_found_id\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"Deve falhar quando o livro não é encontrado\");\n        \n        match result {\n            Err(AppError::NotFoundError(msg)) =\u003e {\n                assert!(msg.contains(\"não encontrado\"), \"Mensagem deve informar que o livro não foi encontrado\");\n                assert!(msg.contains(book_id), \"Mensagem deve conter o ID do livro\");\n            },\n            _ =\u003e panic!(\"Deveria retornar um NotFoundError\")\n        }\n    }\n\n    // Teste usando mock para simular erro interno (InternalServerError)\n    #[tokio::test]\n    async fn test_find_book_by_id_internal_error() {\n        // Arrange\n        // Criar um mock do HttpService que retorna erro interno\n        let mock_http_service = Arc::new(MockHttpService::new_error(\n            AppError::InternalServerError(\"Erro interno na requisição HTTP\".to_string())\n        ));\n        \n        let service = GoogleBookServiceImpl::new(mock_http_service);\n        let book_id = \"test_error_id\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"Deve falhar quando ocorre um erro interno\");\n        \n        match result {\n            Err(AppError::InternalServerError(msg)) =\u003e {\n                assert!(msg.contains(\"Erro interno\"), \"Mensagem deve informar sobre o erro interno\");\n            },\n            _ =\u003e panic!(\"Deveria propagar o InternalServerError\")\n        }\n    }\n\n    // Teste usando mock para simular resposta vazia ou inválida\n    #[tokio::test]\n    async fn test_find_book_by_id_empty_response() {\n        // Arrange\n        // Criar um mock que retorna objeto vazio com apenas ID\n        let mock_http_service = Arc::new(MockHttpService::new_success(json!({\n            \"id\": \"test_empty_response_id\",\n            // Sem volumeInfo ou outros campos necessários\n        })));\n        \n        let service = GoogleBookServiceImpl::new(mock_http_service);\n        let book_id = \"test_empty_response_id\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        // A chamada deve ter sucesso, mas o livro retornado deve ter apenas o ID\n        assert!(result.is_ok(), \"Deve retornar um objeto mesmo com dados mínimos\");\n        \n        let book = result.unwrap();\n        assert_eq!(book.google_id, book_id, \"ID do livro deve corresponder\");\n        assert_eq!(book.title, \"\", \"Título deve estar vazio\");\n        assert_eq!(book.authors, None, \"Autores devem ser None\");\n        assert_eq!(book.description, None, \"Descrição deve ser None\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service_test","mod.rs"],"content":"pub mod find_book_by_id_tests;\npub mod search_books_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service_test","search_books_tests.rs"],"content":"use crate::services::google_book_service::{GoogleBookService, GoogleBookServiceImpl};\nuse crate::services::http_service::HttpServiceImpl;\nuse std::sync::Arc;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_search_books_real_api() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        let query = \"Rust Programming Language\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca de livros deveria ser bem-sucedida\");\n\n        let books = result.unwrap();\n        assert!(\n            !books.is_empty(),\n            \"A busca deveria retornar pelo menos um livro\"\n        );\n\n        // Verificar estrutura dos dados retornados no primeiro livro\n        let first_book = \u0026books[0];\n        assert!(\n            !first_book.google_id.is_empty(),\n            \"O ID do Google não deve estar vazio\"\n        );\n        assert!(\n            !first_book.title.is_empty(),\n            \"O título não deve estar vazio\"\n        );\n\n        // Verificamos se os campos opcionais possuem estrutura adequada quando presentes\n        if let Some(authors) = \u0026first_book.authors {\n            assert!(\n                !authors.is_empty(),\n                \"Autores não devem estar vazios quando presentes\"\n            );\n        }\n\n        if let Some(image_url) = \u0026first_book.image_url {\n            assert!(\n                image_url.starts_with(\"http\"),\n                \"URL da imagem deve ser uma URL válida quando presente\"\n            );\n        }\n\n        if let Some(page_count) = first_book.page_count {\n            assert!(\n                page_count \u003e 0,\n                \"Contagem de páginas deve ser positiva quando presente\"\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_books_with_specific_author() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        let query = \"author:Martin Fowler\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca por autor deveria ser bem-sucedida\");\n\n        let books = result.unwrap();\n        if !books.is_empty() {\n            // Se houver resultados, verificar se o autor está presente em pelo menos um livro\n            let author_found = books.iter().any(|book| {\n                if let Some(authors) = \u0026book.authors {\n                    authors.contains(\"Fowler\")\n                } else {\n                    false\n                }\n            });\n\n            assert!(\n                author_found,\n                \"Pelo menos um livro deveria conter o autor buscado\"\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_books_with_nonexistent_title() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // Uma string improvável de corresponder a um título real\n        let query = \"título extremamente improvável de existir 9283749232874\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(\n            result.is_ok(),\n            \"A busca por título inexistente deve ser processada sem erro\"\n        );\n\n        let books = result.unwrap();\n        assert!(\n            books.is_empty(),\n            \"A busca por título inexistente deve retornar lista vazia\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_search_books_response_structure() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // Um livro bem conhecido que deve ter todos os campos preenchidos\n        let query = \"title:Clean Code Robert Martin\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca deveria ser bem-sucedida\");\n\n        let books = result.unwrap();\n        if !books.is_empty() {\n            let book = \u0026books[0];\n\n            // Verificamos a estrutura completa do objeto retornado\n            assert!(\n                !book.google_id.is_empty(),\n                \"ID do Google deve estar preenchido\"\n            );\n            assert!(!book.title.is_empty(), \"Título deve estar preenchido\");\n\n            // Campos opcionais devem ter estrutura válida se presentes\n            if let Some(publisher) = \u0026book.publisher {\n                assert!(\n                    !publisher.is_empty(),\n                    \"Editora não deve estar vazia quando presente\"\n                );\n            }\n\n            if let Some(published_date) = \u0026book.published_date {\n                assert!(\n                    !published_date.is_empty(),\n                    \"Data de publicação não deve estar vazia quando presente\"\n                );\n            }\n\n            if let Some(description) = \u0026book.description {\n                assert!(\n                    !description.is_empty(),\n                    \"Descrição não deve estar vazia quando presente\"\n                );\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","http_service.rs"],"content":"use crate::error::AppError;\nuse reqwest::Client;\nuse serde_json::Value;\n\npub trait HttpService: Send + Sync {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cValue, AppError\u003e\u003e + Send + 'a\u003e\u003e;\n}\n\npub struct HttpServiceImpl {\n    client: Client,\n}\n\nimpl HttpServiceImpl {\n    pub fn new() -\u003e Self {\n        Self {\n            client: Client::new(),\n        }\n    }\n}\n\nimpl HttpService for HttpServiceImpl {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cValue, AppError\u003e\u003e + Send + 'a\u003e\u003e\n    {\n        Box::pin(async move {\n            let response = self.client.get(url).send().await.map_err(|e| {\n                AppError::InternalServerError(format!(\"Erro na requisição HTTP: {}\", e))\n            })?;\n\n            let status = response.status();\n            if !status.is_success() {\n                let message = format!(\"Erro na requisição: Status {}\", status);\n                return Err(AppError::NotFoundError(message));\n            }\n\n            let data: Value = response.json().await.map_err(|e| {\n                AppError::InternalServerError(format!(\"Erro ao processar resposta: {}\", e))\n            })?;\n\n            Ok(data)\n        })\n    }\n}\n","traces":[{"line":17,"address":[7418720],"length":1,"stats":{"Line":16}},{"line":19,"address":[7438545],"length":1,"stats":{"Line":16}},{"line":25,"address":[7418736],"length":1,"stats":{"Line":6}},{"line":30,"address":[7417807],"length":1,"stats":{"Line":16}},{"line":31,"address":[6904309,6904601,6905583,6906436,6904464,6905004,6904380,6906192],"length":1,"stats":{"Line":16}},{"line":32,"address":[6926998,6927063,6927162],"length":1,"stats":{"Line":0}},{"line":35,"address":[6925723,6925877],"length":1,"stats":{"Line":10}},{"line":36,"address":[6931320],"length":1,"stats":{"Line":5}},{"line":37,"address":[6905226,6905126],"length":1,"stats":{"Line":4}},{"line":38,"address":[6843411],"length":1,"stats":{"Line":2}},{"line":41,"address":[6906464,6906708,6905608,6905154,6904398,6906133,6906054,6905500],"length":1,"stats":{"Line":15}},{"line":42,"address":[6932874,6932775,6932710],"length":1,"stats":{"Line":0}},{"line":45,"address":[6905935],"length":1,"stats":{"Line":5}}],"covered":11,"coverable":13},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","http_service_test","get.rs"],"content":"use serde_json::json;\nuse crate::error::AppError;\nuse crate::services::http_service::{HttpService, HttpServiceImpl};\n\n// Implementação simples de HttpService para testes\nstruct TestHttpService {\n    response: Option\u003cserde_json::Value\u003e,\n    error: Option\u003cAppError\u003e,\n    expected_url: String,\n}\n\nimpl TestHttpService {\n    fn new_success(url: \u0026str, response: serde_json::Value) -\u003e Self {\n        Self {\n            response: Some(response),\n            error: None,\n            expected_url: url.to_string(),\n        }\n    }\n\n    fn new_error(url: \u0026str, error: AppError) -\u003e Self {\n        Self {\n            response: None,\n            error: Some(error),\n            expected_url: url.to_string(),\n        }\n    }\n}\n\nimpl HttpService for TestHttpService {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cserde_json::Value, AppError\u003e\u003e + Send + 'a\u003e\u003e {\n        let response = self.response.clone();\n        let error = self.error.clone();\n        let expected_url = self.expected_url.clone();\n\n        Box::pin(async move {\n            // Verifica se a URL é a esperada\n            assert_eq!(url, expected_url, \"URL não corresponde à esperada\");\n\n            // Retorna o resultado configurado\n            match (response, error) {\n                (Some(resp), _) =\u003e Ok(resp),\n                (_, Some(err)) =\u003e Err(err),\n                _ =\u003e Err(AppError::InternalServerError(\"Nenhuma resposta ou erro configurado\".to_string())),\n            }\n        })\n    }\n}\n\n// Teste para simular erro na requisição HTTP\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_http_request_error() {\n    // Criar serviço de teste que simula um erro de conexão\n    let service = TestHttpService::new_error(\n        \"https://example.com/test\",\n        AppError::InternalServerError(\"Erro na requisição HTTP: falha de conexão\".to_string())\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/test\").await;\n    \n    // Verificar que retornou o erro interno esperado\n    assert!(result.is_err());\n    match result {\n        Err(AppError::InternalServerError(msg)) =\u003e {\n            assert!(msg.contains(\"Erro na requisição HTTP\"));\n        }\n        _ =\u003e panic!(\"Deveria ser um erro InternalServerError\"),\n    }\n}\n\n// Teste para simular erro de status HTTP (404)\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_http_status_error() {\n    // Criar serviço de teste que simula um erro 404\n    let service = TestHttpService::new_error(\n        \"https://example.com/not-found\",\n        AppError::NotFoundError(\"Erro na requisição: Status 404\".to_string())\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/not-found\").await;\n    \n    // Verificar que retornou o erro NotFound esperado\n    assert!(result.is_err());\n    match result {\n        Err(AppError::NotFoundError(msg)) =\u003e {\n            assert!(msg.contains(\"Status 404\"));\n        }\n        _ =\u003e panic!(\"Deveria ser um erro NotFoundError\"),\n    }\n}\n\n// Teste para simular JSON inválido\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_invalid_json_response() {\n    // Criar serviço de teste que simula um erro de JSON inválido\n    let service = TestHttpService::new_error(\n        \"https://example.com/invalid-json\",\n        AppError::InternalServerError(\"Erro ao processar resposta: JSON inválido\".to_string())\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/invalid-json\").await;\n    \n    // Verificar que retornou o erro de processamento esperado\n    assert!(result.is_err());\n    match result {\n        Err(AppError::InternalServerError(msg)) =\u003e {\n            assert!(msg.contains(\"Erro ao processar resposta\"));\n        }\n        _ =\u003e panic!(\"Deveria ser um erro InternalServerError\"),\n    }\n}\n\n// Teste para resposta bem-sucedida\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_successful_response() {\n    // Criar serviço de teste que simula uma resposta bem-sucedida\n    let service = TestHttpService::new_success(\n        \"https://example.com/success\",\n        json!({\"test\": \"success\"})\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/success\").await;\n    \n    // Verificar que retornou o resultado esperado\n    assert!(result.is_ok());\n    let data = result.unwrap();\n    assert_eq!(data[\"test\"], json!(\"success\"));\n}\n\n// Teste de integração com o HttpServiceImpl real\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_real_http_service() {\n    // Criamos uma instância real do HttpService\n    let http_service = HttpServiceImpl::new();\n    \n    // Fazemos uma requisição para uma API pública conhecida\n    let result = http_service.get(\"https://jsonplaceholder.typicode.com/todos/1\").await;\n    \n    // Verificamos se a requisição foi bem-sucedida\n    assert!(result.is_ok());\n    \n    // Verificamos se a resposta contém campos esperados\n    let data = result.unwrap();\n    assert!(data.get(\"id\").is_some());\n    assert!(data.get(\"title\").is_some());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","http_service_test","mod.rs"],"content":"pub mod get;","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","mod.rs"],"content":"pub mod auth_service;\npub mod book_offered_service;\npub mod book_wanted_service;\npub mod google_book_service;\npub mod http_service;\npub mod password_service;\n\n#[cfg(test)]\npub mod auth_service_test;\n\n#[cfg(test)]\npub mod book_offered_wanted_service_test;\n\n#[cfg(test)]\npub mod google_book_service_test;\n\n#[cfg(test)]\npub mod http_service_test;\n\n#[cfg(test)]\npub mod password_service_test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","password_service.rs"],"content":"use async_trait::async_trait;\nuse std::sync::Arc;\n\nuse argon2::{\n    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},\n    Argon2,\n};\n\nuse crate::error::AppError;\n\n/// Interface para serviços de gerenciamento de senha\n///\n/// Esta interface define operações para hash e verificação de senhas,\n/// permitindo desacoplar o AuthService da implementação específica (Argon2)\n#[async_trait]\npub trait PasswordService: Send + Sync + 'static {\n    /// Gera um hash para uma senha\n    fn hash_password(\u0026self, password: \u0026str) -\u003e Result\u003cString, AppError\u003e;\n\n    /// Verifica se uma senha corresponde a um hash\n    fn verify_password(\u0026self, password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, AppError\u003e;\n}\n\n/// Implementação do PasswordService usando Argon2\npub struct Argon2PasswordService;\n\nimpl Argon2PasswordService {\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n}\n\n#[async_trait]\nimpl PasswordService for Argon2PasswordService {\n    fn hash_password(\u0026self, password: \u0026str) -\u003e Result\u003cString, AppError\u003e {\n        let salt = SaltString::generate(\u0026mut OsRng);\n        let argon2 = Argon2::default();\n\n        argon2\n            .hash_password(password.as_bytes(), \u0026salt)\n            .map(|hash| hash.to_string())\n            .map_err(|e| AppError::InternalServerError(format!(\"Erro ao gerar hash: {}\", e)))\n    }\n\n    fn verify_password(\u0026self, password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, AppError\u003e {\n        let parsed_hash = PasswordHash::new(hash)\n            .map_err(|e| AppError::InternalServerError(format!(\"Erro ao analisar hash: {}\", e)))?;\n\n        Ok(Argon2::default()\n            .verify_password(password.as_bytes(), \u0026parsed_hash)\n            .is_ok())\n    }\n}\n\n/// Factory para criar instâncias do PasswordService\n///\n/// Permite flexibilidade para mudar a implementação no futuro\npub fn create_password_service() -\u003e Arc\u003cdyn PasswordService\u003e {\n    Arc::new(Argon2PasswordService::new())\n}\n","traces":[{"line":35,"address":[6647984],"length":1,"stats":{"Line":11}},{"line":36,"address":[6627250],"length":1,"stats":{"Line":11}},{"line":37,"address":[6566069],"length":1,"stats":{"Line":11}},{"line":39,"address":[6653532],"length":1,"stats":{"Line":11}},{"line":41,"address":[7150364,7150352],"length":1,"stats":{"Line":17}},{"line":42,"address":[7150400,7150384,7150517],"length":1,"stats":{"Line":0}},{"line":45,"address":[6638160],"length":1,"stats":{"Line":7}},{"line":46,"address":[6638266,6638593],"length":1,"stats":{"Line":9}},{"line":47,"address":[7148048,7148064,7148181],"length":1,"stats":{"Line":4}},{"line":49,"address":[6628610],"length":1,"stats":{"Line":8}},{"line":58,"address":[6637936],"length":1,"stats":{"Line":14}},{"line":59,"address":[6627169],"length":1,"stats":{"Line":16}}],"covered":11,"coverable":12},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","password_service_test.rs"],"content":"use crate::error::AppError;\nuse crate::services::password_service::{\n    create_password_service, Argon2PasswordService, PasswordService,\n};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_hash_password_success() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n\n        // Act\n        let result = service.hash_password(password);\n\n        // Assert\n        assert!(\n            result.is_ok(),\n            \"O hash da senha deveria ser gerado com sucesso\"\n        );\n        let hash = result.unwrap();\n        assert!(!hash.is_empty(), \"O hash não deve ser vazio\");\n        assert!(\n            hash.contains(\"$argon2\"),\n            \"O hash deve usar o formato Argon2\"\n        );\n    }\n\n    #[test]\n    fn test_verify_password_success() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n\n        // Primeiro, gerar um hash da senha\n        let hash = service.hash_password(password).unwrap();\n\n        // Act\n        let result = service.verify_password(password, \u0026hash);\n\n        // Assert\n        assert!(result.is_ok(), \"A verificação deveria ser bem-sucedida\");\n        assert!(\n            result.unwrap(),\n            \"A senha correta deveria ser verificada como válida\"\n        );\n    }\n\n    #[test]\n    fn test_verify_password_with_wrong_password() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let correct_password = \"senha123\";\n        let wrong_password = \"senha456\";\n\n        // Primeiro, gerar um hash da senha correta\n        let hash = service.hash_password(correct_password).unwrap();\n\n        // Act\n        let result = service.verify_password(wrong_password, \u0026hash);\n\n        // Assert\n        assert!(\n            result.is_ok(),\n            \"A verificação deveria ser processada sem erros\"\n        );\n        assert!(\n            !result.unwrap(),\n            \"A senha incorreta deveria ser verificada como inválida\"\n        );\n    }\n\n    #[test]\n    fn test_verify_password_with_invalid_hash() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n        let invalid_hash = \"hash_invalido\";\n\n        // Act\n        let result = service.verify_password(password, invalid_hash);\n\n        // Assert\n        assert!(\n            result.is_err(),\n            \"A verificação deveria falhar com hash inválido\"\n        );\n        let error = result.unwrap_err();\n        match error {\n            AppError::InternalServerError(msg) =\u003e {\n                assert!(\n                    msg.contains(\"Erro ao analisar hash\"),\n                    \"A mensagem de erro deveria indicar problema na análise do hash\"\n                );\n            }\n            _ =\u003e panic!(\"Tipo de erro inesperado: {:?}\", error),\n        }\n    }\n\n    #[test]\n    fn test_create_password_service() {\n        // Act\n        let _service = create_password_service();\n\n        // Assert\n        // Verificamos se a função factory retorna corretamente um serviço\n        // A verificação é implícita, pois se não retornasse um PasswordService,\n        // o código não compilaria\n        assert!(true, \"O serviço foi criado com sucesso\");\n    }\n\n    #[test]\n    fn test_hashed_passwords_are_different() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n\n        // Act\n        let hash1 = service.hash_password(password).unwrap();\n        let hash2 = service.hash_password(password).unwrap();\n\n        // Assert\n        assert_ne!(\n            hash1, hash2,\n            \"Hashes da mesma senha devem ser diferentes (salt diferente)\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","add_book_offered_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_add_book_to_offered() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Primeiro, vamos buscar um livro para obter um ID válido\n    let search_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de busca\");\n\n    let search_body: Value = search_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de busca\");\n\n    let books = search_body[\"data\"].as_array().unwrap();\n    assert!(!books.is_empty(), \"A busca deve retornar pelo menos um livro\");\n\n    let google_id = books[0][\"google_id\"].as_str().unwrap();\n\n    // Act - Adicionar o livro à lista de possuídos\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para adicionar livro\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::CREATED);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(\n        body[\"message\"],\n        \"Livro adicionado à lista de possuídos com sucesso\"\n    );\n    assert!(body[\"data\"][\"book_id\"].is_string());\n    assert!(body[\"data\"][\"user_id\"].is_string());\n\n    // Tentar adicionar o mesmo livro novamente deve falhar\n    let duplicate_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição duplicada\");\n\n    let duplicate_status = duplicate_response.status();\n    let duplicate_body: Value = duplicate_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta duplicada\");\n\n    assert_eq!(duplicate_status, StatusCode::BAD_REQUEST);\n    assert_eq!(duplicate_body[\"error\"][\"status\"], 400);\n    assert!(duplicate_body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"já está na sua lista de possuídos\"));\n}\n\n#[tokio::test]\nasync fn test_add_book_to_offered_invalid_google_id() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Tentar adicionar um livro com ID inválido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": \"id_que_nao_existe_12345\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - A requisição deve falhar pois o Google Books API não encontrará o livro\n    let status = response.status();\n    assert_eq!(status, StatusCode::NOT_FOUND);\n}\n\n#[tokio::test]\nasync fn test_add_book_to_offered_without_authentication() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Tentar adicionar um livro sem autenticação\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .json(\u0026json!({\n            \"google_id\": \"qualquerid\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - A requisição deve falhar por falta de autenticação\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token de autenticação ausente\"));\n}\n\n// Teste para verificar erro ao tentar adicionar livro que já está na lista de desejados\n#[tokio::test]\n#[ignore = \"Requer implementação da rota de livros desejados\"]\nasync fn test_add_book_to_offered_already_in_wanted() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Primeiro, vamos buscar um livro para obter um ID válido\n    let search_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de busca\");\n\n    let search_body: Value = search_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de busca\");\n\n    let books = search_body[\"data\"].as_array().unwrap();\n    assert!(!books.is_empty(), \"A busca deve retornar pelo menos um livro\");\n\n    let google_id = books[0][\"google_id\"].as_str().unwrap();\n\n    // Nota: Este teste está marcado como ignorado (#[ignore]) porque requer a implementação\n    // da rota de livros desejados primeiro. Quando essa rota for implementada, podemos \n    // adicionar o livro à lista de desejados usando uma requisição HTTP normal.\n\n    // Adicionar à lista de desejados (isso depende da implementação da rota /api/books/wanted)\n    let wanted_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/wanted\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await;\n\n    // Se a rota não estiver disponível, ignorar o teste\n    if wanted_response.is_err() {\n        println!(\"A rota de livros desejados não está disponível. Ignorando teste.\");\n        return;\n    }\n\n    // Garantir que o livro foi adicionado à lista de desejados\n    assert_eq!(wanted_response.unwrap().status(), StatusCode::CREATED);\n\n    // Act - Tentar adicionar o mesmo livro à lista de oferecidos\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para adicionar livro à lista de oferecidos\");\n\n    // Assert - Verificar que a requisição falhou com o erro esperado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"já está na sua lista de desejados\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","auth_login_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::setup_test_app;\nuse reqwest::StatusCode;\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_login_success() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Criar email único para evitar conflitos\n    let email = format!(\"login_test_{}@example.com\", chrono::Utc::now().timestamp());\n    let password = \"senha123\";\n\n    // Registrar um usuário primeiro\n    let register_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Login\",\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de registro\");\n\n    assert_eq!(register_response.status(), StatusCode::CREATED);\n\n    // Act - Fazer login com usuário criado\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de login\");\n\n    // Assert\n    let status = login_response.status();\n    let body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(body[\"message\"], \"Login realizado com sucesso\");\n\n    // Verificar se retornou um token e os dados do usuário\n    assert!(body[\"data\"][\"access_token\"].is_string());\n    assert_eq!(body[\"data\"][\"token_type\"], \"Bearer\");\n    assert_eq!(body[\"data\"][\"user\"][\"email\"], email);\n}\n\n#[tokio::test]\nasync fn test_login_invalid_credentials() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Criar email único para evitar conflitos\n    let email = format!(\n        \"invalid_login_{}@example.com\",\n        chrono::Utc::now().timestamp()\n    );\n\n    // Registrar um usuário primeiro\n    let register_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário para Teste de Login Inválido\",\n            \"email\": email,\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de registro\");\n\n    assert_eq!(register_response.status(), StatusCode::CREATED);\n\n    // Act - Fazer login com senha incorreta\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": \"senha_incorreta\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de login\");\n\n    // Assert\n    let status = login_response.status();\n    let body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Credenciais inválidas\"));\n}\n\n#[tokio::test]\nasync fn test_login_nonexistent_user() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Email que provavelmente não existe\n    let email = format!(\"nonexistent_{}@example.com\", chrono::Utc::now().timestamp());\n\n    // Act - Fazer login com usuário inexistente\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": \"qualquer_senha\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de login\");\n\n    // Assert\n    let status = login_response.status();\n    let body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Credenciais inválidas\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","auth_register_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::setup_test_app;\nuse reqwest::StatusCode;\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_register_user_success() {\n    // Arrange - Configurar o aplicativo de teste\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Gerar um email único para evitar conflitos\n    let email = format!(\"test_user_{}@example.com\", chrono::Utc::now().timestamp());\n\n    // Act - Enviar requisição para registrar um usuário\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Teste\",\n            \"email\": email,\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::CREATED);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(body[\"message\"], \"Usuário registrado com sucesso\");\n    assert!(body[\"data\"][\"id\"].is_string());\n    assert_eq!(body[\"data\"][\"name\"], \"Usuário de Teste\");\n    assert_eq!(body[\"data\"][\"email\"], email);\n}\n\n#[tokio::test]\nasync fn test_register_user_invalid_email() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar requisição com email inválido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Teste\",\n            \"email\": \"email_invalido\",\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Formato de email inválido\"));\n}\n\n#[tokio::test]\nasync fn test_register_user_password_too_short() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar requisição com senha muito curta\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Teste\",\n            \"email\": \"usuario@example.com\",\n            \"password\": \"12345\"  // Menos de 6 caracteres\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"A senha deve ter\"));\n}\n\n#[tokio::test]\nasync fn test_register_user_duplicate_email() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Email que será duplicado\n    let email = format!(\"duplicate_{}@example.com\", chrono::Utc::now().timestamp());\n\n    // Primeiro registro (deve ter sucesso)\n    let _ = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Primeiro Usuário\",\n            \"email\": email,\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar primeira requisição\");\n\n    // Act - Tentar registrar com o mesmo email\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Segundo Usuário\",\n            \"email\": email,\n            \"password\": \"outrasenha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar segunda requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Email já está em uso\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","books_search_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_search_books_success() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar livros com um termo de busca válido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Rust Programming\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(body[\"message\"], \"Livros encontrados com sucesso\");\n    assert!(body[\"data\"].is_array());\n\n    // Verificar se há pelo menos um livro na resposta\n    let data = body[\"data\"].as_array().unwrap();\n    if !data.is_empty() {\n        let first_book = \u0026data[0];\n\n        // Verificar se os campos obrigatórios existem\n        assert!(first_book[\"google_id\"].is_string());\n        assert!(first_book[\"title\"].is_string());\n\n        // Verificar se os campos têm valores adequados\n        assert!(!first_book[\"google_id\"].as_str().unwrap().is_empty());\n        assert!(!first_book[\"title\"].as_str().unwrap().is_empty());\n    }\n}\n\n#[tokio::test]\nasync fn test_search_books_without_authentication() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar livros sem fornecer token de autenticação\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar que a requisição falhou por falta de autenticação\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token de autenticação ausente\"));\n}\n\n#[tokio::test]\nasync fn test_search_books_with_invalid_token() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Token inválido\n    let invalid_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjk5OTk5OTk5OTl9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n\n    // Act - Buscar livros com token inválido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", invalid_token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar que a requisição falhou por token inválido\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_search_books_empty_query() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar uma consulta vazia\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"não pode estar vazia\"));\n}\n\n#[tokio::test]\nasync fn test_search_books_specific_book() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar um livro específico com termos mais específicos\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code: A Handbook of Agile Software Craftsmanship Robert Martin\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n\n    let data = body[\"data\"].as_array().unwrap();\n\n    // Verificar se os resultados são relevantes - não exigimos match exato, pois a API pode retornar resultados diferentes\n    let is_relevant = data.iter().any(|book| {\n        let title = book[\"title\"].as_str().unwrap_or(\"\");\n        let authors = book[\"authors\"].as_str().unwrap_or(\"\");\n\n        // Considerar relevante se contiver partes do título ou nome do autor\n        title.contains(\"Clean\")\n            || title.contains(\"Code\")\n            || authors.contains(\"Martin\")\n            || authors.contains(\"Robert\")\n    });\n\n    assert!(\n        is_relevant,\n        \"Deveria encontrar livros relacionados a 'Clean Code' ou 'Robert Martin'\"\n    );\n}\n\n#[tokio::test]\nasync fn test_search_books_nonexistent_title() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar um título improvável de existir\n    let unique_query = format!(\"TítuloMuitoImprovável{}\", chrono::Utc::now().timestamp());\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": unique_query\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n\n    // O array de dados deve estar vazio ou ter poucos resultados\n    let data = body[\"data\"].as_array().unwrap();\n    assert!(\n        data.len() \u003c 2,\n        \"Não deveria encontrar muitos livros com um título improvável\"\n    );\n}\n\n#[tokio::test]\nasync fn test_search_books_with_author_filter() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar livros de um autor específico\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"author:Martin Fowler\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n\n    let data = body[\"data\"].as_array().unwrap();\n    if !data.is_empty() {\n        // Verificar se os livros retornados são do autor pesquisado\n        let author_found = data.iter().any(|book| {\n            if let Some(authors) = book[\"authors\"].as_str() {\n                authors.contains(\"Fowler\") || authors.contains(\"Martin\")\n            } else {\n                false\n            }\n        });\n\n        assert!(\n            author_found,\n            \"Deveria encontrar pelo menos um livro do autor Martin Fowler\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","common","mod.rs"],"content":"pub mod test_utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","common","test_utils.rs"],"content":"use reqwest::Client;\nuse serde_json::{json, Value};\nuse std::net::TcpListener;\nuse troca_livros_api::app;\nuse uuid::Uuid;\n\npub struct TestApp {\n    pub port: u16,\n}\n\n/// Configura um aplicativo de teste com um banco de dados de teste\n///\n/// Esta função:\n/// 1. Cria uma conexão com o banco de dados de teste\n/// 2. Configura o servidor Axum\n/// 3. Inicia o servidor em uma porta aleatória\n/// 4. Retorna o objeto TestApp com informações para os testes\npub async fn setup_test_app() -\u003e TestApp {\n    // Carregar variáveis de ambiente\n    dotenv::dotenv().ok();\n\n    // Configurar logging para testes\n    let _ = tracing_subscriber::fmt()\n        .with_test_writer()\n        .with_env_filter(\"info\")\n        .try_init();\n\n    // Obter a URL do banco de dados de teste a partir da variável de ambiente\n    let test_db_url =\n        std::env::var(\"TEST_DATABASE_URL\").expect(\"TEST_DATABASE_URL não está definida\");\n\n    // Encontrar uma porta disponível\n    let listener = TcpListener::bind(\"127.0.0.1:0\").expect(\"Falha ao vincular a porta aleatória\");\n    let port = listener.local_addr().unwrap().port();\n\n    // Configurar rotas sem Swagger UI (não necessário para testes)\n    let created_app = app::create_app(\u0026test_db_url).await;\n\n    // Iniciar o servidor em uma nova thread\n    let server = axum::Server::from_tcp(listener)\n        .expect(\"Falha ao criar servidor a partir do listener\")\n        .serve(created_app.into_make_service());\n\n    tokio::spawn(server);\n\n    TestApp { port }\n}\n\n/// Cria um usuário de teste e retorna o token de autenticação\n///\n/// Esta função:\n/// 1. Registra um novo usuário (se necessário)\n/// 2. Faz login para obter o token JWT\n/// 3. Retorna o token para ser usado em requisições autenticadas\n#[allow(dead_code)]\npub async fn get_auth_token(app: \u0026TestApp) -\u003e String {\n    let client = Client::new();\n\n    // Criar credenciais únicas usando UUID para garantir unicidade absoluta\n    // mesmo quando chamado no mesmo milissegundo\n    let uuid = Uuid::new_v4().to_string();\n    let email = format!(\"auth_test_{}@example.com\", uuid);\n    let password = \"Senha@123\";\n    let name = format!(\"Usuário de Teste {}\", uuid);\n\n    // Registrar usuário\n    let register_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": name,\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao registrar usuário de teste\");\n\n    assert_eq!(register_response.status(), reqwest::StatusCode::CREATED);\n\n    // Fazer login\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao autenticar usuário de teste\");\n\n    let login_body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler resposta de login\");\n\n    // Extrair token\n    login_body[\"data\"][\"access_token\"]\n        .as_str()\n        .expect(\"Token não encontrado na resposta\")\n        .to_string()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","middleware_auth_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_auth_middleware_token_expiration() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Token expirado (exp está no passado)\n    let expired_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n\n    // Act - Tentar acessar uma rota protegida com token expirado\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", expired_token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_auth_middleware_malformed_token() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Token malformado (não é um JWT válido)\n    let malformed_token = \"isto_nao_e_um_token_jwt_valido\";\n\n    // Act - Tentar acessar uma rota protegida com token malformado\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", malformed_token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_auth_middleware_missing_bearer() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar token sem o prefixo \"Bearer \"\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, token) // Token sem o prefixo Bearer\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Formato de token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_auth_middleware_access_multiple_protected_routes() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Acessar a primeira rota protegida\n    let response1 = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar primeira requisição\");\n\n    // Assert para a primeira rota\n    assert_eq!(response1.status(), StatusCode::OK);\n\n    // Act - Acessar a mesma rota protegida novamente com o mesmo token\n    let response2 = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Domain-Driven Design\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar segunda requisição\");\n\n    // Assert para a segunda rota\n    assert_eq!(response2.status(), StatusCode::OK);\n\n    // Verificar que os dados retornados são diferentes (consultas diferentes)\n    let body1: Value = response1\n        .json()\n        .await\n        .expect(\"Falha ao ler primeira resposta\");\n    let body2: Value = response2\n        .json()\n        .await\n        .expect(\"Falha ao ler segunda resposta\");\n\n    // Verificar que ambas as respostas têm o status de sucesso\n    assert_eq!(body1[\"status\"], \"success\");\n    assert_eq!(body2[\"status\"], \"success\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","remove_book_offered_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n\n#[tokio::test]\nasync fn test_remove_book_from_offered() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Primeiro, vamos buscar um livro para obter um ID válido\n    let search_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Domain-Driven Design\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de busca\");\n\n    let search_body: Value = search_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de busca\");\n\n    let books = search_body[\"data\"].as_array().unwrap();\n    assert!(!books.is_empty(), \"A busca deve retornar pelo menos um livro\");\n\n    let google_id = books[0][\"google_id\"].as_str().unwrap();\n\n    // Adicionar o livro à lista de possuídos\n    let add_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para adicionar livro\");\n\n    let add_body: Value = add_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de adição\");\n\n    let book_id = add_body[\"data\"][\"book_id\"].as_str().unwrap();\n\n    // Act - Remover o livro da lista de possuídos\n    let response = client\n        .delete(\u0026format!(\n            \"http://localhost:{}/api/books/offered/{}\",\n            app.port, book_id\n        ))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para remover livro\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(\n        body[\"message\"],\n        \"Livro removido da lista de possuídos com sucesso\"\n    );\n\n    // Tentar remover o mesmo livro novamente deve falhar\n    let second_delete_response = client\n        .delete(\u0026format!(\n            \"http://localhost:{}/api/books/offered/{}\",\n            app.port, book_id\n        ))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .send()\n        .await\n        .expect(\"Falha ao enviar segunda requisição para remover livro\");\n\n    let second_delete_status = second_delete_response.status();\n    let second_delete_body: Value = second_delete_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da segunda resposta de remoção\");\n\n    assert_eq!(second_delete_status, StatusCode::BAD_REQUEST);\n    assert_eq!(second_delete_body[\"error\"][\"status\"], 400);\n    assert!(second_delete_body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"não está na sua lista de possuídos\"));\n} ","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","app.rs"],"content":"use axum::{\n    http::{\n        header::{ACCEPT, AUTHORIZATION, CONTENT_TYPE},\n        Method,\n    },\n    Extension, Router,\n};\nuse sqlx::{postgres::PgPoolOptions, PgPool};\nuse std::sync::Arc;\nuse tower_http::cors::{Any, CorsLayer};\nuse utoipa::OpenApi;\nuse utoipa_swagger_ui::SwaggerUi;\n\nuse crate::{\n    config::Config,\n    docs::ApiDoc,\n    repositories::user_repository::PgUserRepository,\n    routes::{\n        auth_routes::auth_routes, \n        book_offered_routes::book_offered_routes,\n        google_book_routes::google_book_routes\n    },\n    services::{auth_service::AuthServiceImpl, password_service::create_password_service},\n};\n\n/// Configura e retorna o pool de conexão com o banco de dados\npub async fn create_database_pool(database_url: \u0026str) -\u003e Arc\u003cPgPool\u003e {\n    let pool = PgPoolOptions::new()\n        .max_connections(10)\n        .connect(database_url)\n        .await\n        .expect(\"Falha ao conectar ao banco de dados\");\n\n    Arc::new(pool)\n}\n\n/// Cria e configura o aplicativo Axum com todas as rotas\n///\n/// Esta função recebe a URL do banco de dados e configura o aplicativo\n/// É usada tanto pela aplicação principal quanto pelos testes\npub async fn create_app(database_url: \u0026str) -\u003e Router {\n    let pool = create_database_pool(database_url).await;\n    let config = Config::from_env().expect(\"Falha ao carregar configuração\");\n\n    // Criar serviço de autenticação compartilhado para todas as rotas protegidas\n    let user_repository = Arc::new(PgUserRepository::new(pool.as_ref().clone()));\n    let password_service = create_password_service();\n\n    let auth_service = Arc::new(AuthServiceImpl::new(\n        user_repository,\n        password_service,\n        config,\n    ));\n\n    // Configurar CORS\n    let cors = CorsLayer::new()\n        .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])\n        .allow_headers([AUTHORIZATION, ACCEPT, CONTENT_TYPE])\n        .allow_origin(Any);\n\n    // Definir rotas públicas (sem autenticação)\n    let public_routes = Router::new().merge(auth_routes(pool.clone()));\n\n    // Definir rotas protegidas (com autenticação)\n    let protected_routes = Router::new()\n        .merge(google_book_routes())\n        .merge(book_offered_routes(pool.clone()))\n        .layer(Extension(auth_service));\n\n    // Inicializar o router básico\n    let mut app = Router::new()\n        .merge(public_routes)\n        .merge(protected_routes)\n        .layer(cors);\n\n    let openapi = ApiDoc::openapi();\n    app = app.merge(SwaggerUi::new(\"/docs\").url(\"/api-docs/openapi.json\", openapi));\n\n    app\n}\n","traces":[{"line":27,"address":[3999302,3999963,3999452,3999632,3999232,3999412],"length":1,"stats":{"Line":43}},{"line":28,"address":[4394513,4394986,4394619,4394888,4394704],"length":1,"stats":{"Line":67}},{"line":31,"address":[4527447],"length":1,"stats":{"Line":38}},{"line":34,"address":[4393534],"length":1,"stats":{"Line":9}},{"line":41,"address":[6949949,6949936],"length":1,"stats":{"Line":49}},{"line":42,"address":[3934679],"length":1,"stats":{"Line":40}},{"line":43,"address":[4390092,4390163],"length":1,"stats":{"Line":25}},{"line":46,"address":[4391805,4391721],"length":1,"stats":{"Line":25}},{"line":47,"address":[4390452,4390380],"length":1,"stats":{"Line":26}},{"line":49,"address":[4390641,4390572],"length":1,"stats":{"Line":18}},{"line":50,"address":[3996852],"length":1,"stats":{"Line":9}},{"line":52,"address":[3853460],"length":1,"stats":{"Line":17}},{"line":56,"address":[3929342,3929649,3929539],"length":1,"stats":{"Line":51}},{"line":57,"address":[3853727],"length":1,"stats":{"Line":9}},{"line":58,"address":[3997274],"length":1,"stats":{"Line":9}},{"line":59,"address":[3854003],"length":1,"stats":{"Line":9}},{"line":62,"address":[3855699,3854011],"length":1,"stats":{"Line":17}},{"line":65,"address":[4391593,4391241,4391507,4391360],"length":1,"stats":{"Line":68}},{"line":66,"address":[4392659,4391260,4391406],"length":1,"stats":{"Line":15}},{"line":67,"address":[4191265,4191142,4192339],"length":1,"stats":{"Line":33}},{"line":68,"address":[4391561,4391649],"length":1,"stats":{"Line":32}},{"line":71,"address":[4011514,4011592,4011686,4011401],"length":1,"stats":{"Line":56}},{"line":72,"address":[3930378],"length":1,"stats":{"Line":16}},{"line":73,"address":[3998184],"length":1,"stats":{"Line":16}},{"line":74,"address":[4011693,4011622],"length":1,"stats":{"Line":32}},{"line":76,"address":[4391957],"length":1,"stats":{"Line":14}},{"line":77,"address":[4192245,4191737,4192222],"length":1,"stats":{"Line":16}},{"line":79,"address":[3855328],"length":1,"stats":{"Line":14}}],"covered":28,"coverable":28},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","config.rs"],"content":"use std::env;\nuse thiserror::Error;\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub struct Config {\n    pub database_url: String,\n    pub jwt_secret: String,\n    pub jwt_expires_in: String,\n    pub port: u16,\n}\n\n#[derive(Error, Debug)]\npub enum ConfigError {\n    #[error(\"Variável de ambiente não encontrada: {0}\")]\n    NotFound(String),\n\n    #[error(\"Falha ao converter variável de ambiente: {0}\")]\n    ParseError(String),\n}\n\nimpl Config {\n    pub fn from_env() -\u003e Result\u003cSelf, ConfigError\u003e {\n        let database_url = env::var(\"DATABASE_URL\")\n            .map_err(|_| ConfigError::NotFound(\"DATABASE_URL\".to_string()))?;\n\n        let jwt_secret =\n            env::var(\"JWT_SECRET\").map_err(|_| ConfigError::NotFound(\"JWT_SECRET\".to_string()))?;\n\n        let jwt_expires_in = env::var(\"JWT_EXPIRES_IN\").unwrap_or_else(|_| \"24h\".to_string());\n\n        let port = env::var(\"PORT\")\n            .unwrap_or_else(|_| \"50001\".to_string())\n            .parse::\u003cu16\u003e()\n            .map_err(|_| ConfigError::ParseError(\"PORT\".to_string()))?;\n\n        Ok(Self {\n            database_url,\n            jwt_secret,\n            jwt_expires_in,\n            port,\n        })\n    }\n}\n","traces":[{"line":23,"address":[7086257,7084800,7086246],"length":1,"stats":{"Line":9}},{"line":24,"address":[3471247,3471025],"length":1,"stats":{"Line":16}},{"line":25,"address":[7104813],"length":1,"stats":{"Line":0}},{"line":27,"address":[7006832,7006850],"length":1,"stats":{"Line":25}},{"line":30,"address":[7084292,7084433],"length":1,"stats":{"Line":25}},{"line":32,"address":[7105323,7105251,7105643,7105433],"length":1,"stats":{"Line":34}},{"line":33,"address":[4256320,4256336],"length":1,"stats":{"Line":0}},{"line":35,"address":[7088070,7088275,7088688],"length":1,"stats":{"Line":16}},{"line":37,"address":[7023113],"length":1,"stats":{"Line":16}},{"line":38,"address":[3472031],"length":1,"stats":{"Line":9}},{"line":39,"address":[7084937],"length":1,"stats":{"Line":16}},{"line":40,"address":[7023065],"length":1,"stats":{"Line":9}}],"covered":10,"coverable":12},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","error.rs"],"content":"use axum::{\n    http::StatusCode,\n    response::{IntoResponse, Response},\n    Json,\n};\nuse serde_json::json;\nuse thiserror::Error;\n\n#[derive(Error, Debug, Clone)]\npub enum AppError {\n    #[error(\"Erro de autenticação: {0}\")]\n    AuthError(String),\n\n    #[error(\"Erro de validação: {0}\")]\n    ValidationError(String),\n\n    #[error(\"Erro de banco de dados: {0}\")]\n    DatabaseError(String),\n\n    #[error(\"Recurso não encontrado: {0}\")]\n    NotFoundError(String),\n\n    #[error(\"Erro interno do servidor: {0}\")]\n    InternalServerError(String),\n}\n\nimpl IntoResponse for AppError {\n    fn into_response(self) -\u003e Response {\n        let (status, error_message) = match self {\n            AppError::AuthError(message) =\u003e (StatusCode::UNAUTHORIZED, message),\n            AppError::ValidationError(message) =\u003e (StatusCode::BAD_REQUEST, message),\n            AppError::DatabaseError(message) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, message),\n            AppError::NotFoundError(message) =\u003e (StatusCode::NOT_FOUND, message),\n            AppError::InternalServerError(message) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, message),\n        };\n\n        let body = Json(json!({\n            \"error\": {\n                \"message\": error_message,\n                \"status\": status.as_u16()\n            }\n        }));\n\n        (status, body).into_response()\n    }\n}\n\nimpl From\u003csqlx::Error\u003e for AppError {\n    fn from(error: sqlx::Error) -\u003e Self {\n        match error {\n            sqlx::Error::RowNotFound =\u003e {\n                AppError::NotFoundError(\"Registro não encontrado\".to_string())\n            }\n            _ =\u003e AppError::DatabaseError(error.to_string()),\n        }\n    }\n}\n","traces":[{"line":27,"address":[37669160],"length":1,"stats":{"Line":0}},{"line":28,"address":[27227117],"length":1,"stats":{"Line":7}},{"line":29,"address":[7307952,7307430],"length":1,"stats":{"Line":14}},{"line":30,"address":[7235522],"length":1,"stats":{"Line":10}},{"line":31,"address":[8535363,8535691],"length":1,"stats":{"Line":5}},{"line":32,"address":[26923364],"length":1,"stats":{"Line":0}},{"line":33,"address":[23139459,23140265,23139493,23139431,23140225,23137996],"length":1,"stats":{"Line":3}},{"line":34,"address":[11373670],"length":1,"stats":{"Line":2}},{"line":37,"address":[23150336,23149578,23148159],"length":1,"stats":{"Line":35}},{"line":38,"address":[32351097],"length":1,"stats":{"Line":2}},{"line":39,"address":[36120057],"length":1,"stats":{"Line":0}},{"line":40,"address":[37644241,37644305,37644113,37644177],"length":1,"stats":{"Line":14}},{"line":44,"address":[30521712],"length":1,"stats":{"Line":7}},{"line":48,"address":[5909715],"length":1,"stats":{"Line":0}},{"line":49,"address":[5910702],"length":1,"stats":{"Line":0}},{"line":50,"address":[7302290],"length":1,"stats":{"Line":0}},{"line":51,"address":[8536292,8536235],"length":1,"stats":{"Line":1}},{"line":52,"address":[5271922,5272309,5271903],"length":1,"stats":{"Line":0}},{"line":54,"address":[26626323,26628426,26627607],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":19},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","auth_handler.rs"],"content":"use std::sync::Arc;\n\nuse axum::{http::StatusCode, response::IntoResponse, Json};\nuse serde_json::json;\n\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, LoginUserDto};\nuse crate::services::auth_service::AuthService;\n\npub struct AuthHandler {\n    auth_service: Arc\u003cdyn AuthService\u003e,\n}\n\nimpl AuthHandler {\n    pub fn new(auth_service: Arc\u003cdyn AuthService\u003e) -\u003e Self {\n        Self { auth_service }\n    }\n\n    pub async fn register(\n        \u0026self,\n        Json(create_user_dto): Json\u003cCreateUserDto\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        let user = self.auth_service.register(create_user_dto).await?;\n\n        Ok((\n            StatusCode::CREATED,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Usuário registrado com sucesso\",\n                \"data\": user\n            })),\n        ))\n    }\n\n    pub async fn login(\n        \u0026self,\n        Json(login_dto): Json\u003cLoginUserDto\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        let token = self.auth_service.login(login_dto).await?;\n\n        Ok((\n            StatusCode::OK,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Login realizado com sucesso\",\n                \"data\": token\n            })),\n        ))\n    }\n}\n","traces":[{"line":15,"address":[4227440],"length":1,"stats":{"Line":19}},{"line":19,"address":[7089728],"length":1,"stats":{"Line":13}},{"line":23,"address":[6641614],"length":1,"stats":{"Line":31}},{"line":25,"address":[7374372],"length":1,"stats":{"Line":8}},{"line":27,"address":[7376236,7377096,7377065,7375720,7376706,7375319,7375199],"length":1,"stats":{"Line":37}},{"line":35,"address":[7089808],"length":1,"stats":{"Line":7}},{"line":39,"address":[6661742],"length":1,"stats":{"Line":27}},{"line":41,"address":[7376410],"length":1,"stats":{"Line":7}},{"line":43,"address":[7313522,7314043,7315397,7315032,7315428,7313642,7314559],"length":1,"stats":{"Line":35}}],"covered":9,"coverable":9},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","book_offered_handler.rs"],"content":"use axum::{\n    extract::{Extension, Path},\n    http::StatusCode,\n    response::IntoResponse,\n    Json,\n};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::sync::Arc;\nuse utoipa::ToSchema;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::services::book_offered_service::BookOfferedService;\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct AddBookRequest {\n    pub google_id: String,\n}\n\npub struct BookOfferedHandler {\n    book_offered_service: Arc\u003cdyn BookOfferedService\u003e,\n}\n\nimpl BookOfferedHandler {\n    pub fn new(book_offered_service: Arc\u003cdyn BookOfferedService\u003e) -\u003e Self {\n        Self {\n            book_offered_service,\n        }\n    }\n\n    pub async fn add_book_to_offered(\n        \u0026self,\n        Extension(user_id): Extension\u003cUuid\u003e,\n        Json(add_book_request): Json\u003cAddBookRequest\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        let book_offered = self\n            .book_offered_service\n            .add_book_to_offered(\u0026add_book_request.google_id, \u0026user_id)\n            .await?;\n\n        Ok((\n            StatusCode::CREATED,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Livro adicionado à lista de possuídos com sucesso\",\n                \"data\": book_offered\n            })),\n        ))\n    }\n\n    pub async fn remove_book_from_offered(\n        \u0026self,\n        Extension(user_id): Extension\u003cUuid\u003e,\n        Path(book_id): Path\u003cUuid\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        self.book_offered_service\n            .remove_book_from_offered(\u0026book_id, \u0026user_id)\n            .await?;\n\n        Ok((\n            StatusCode::OK,\n            Json(json!({\n                    \"status\": \"success\",\n                    \"message\": \"Livro removido da lista de possuídos com sucesso\"\n            })),\n        ))\n    }\n}\n","traces":[{"line":26,"address":[7213328],"length":1,"stats":{"Line":13}},{"line":32,"address":[7203552],"length":1,"stats":{"Line":2}},{"line":37,"address":[7014984,7014870,7014631,7014690,7014432,7015140],"length":1,"stats":{"Line":11}},{"line":39,"address":[6989306],"length":1,"stats":{"Line":2}},{"line":40,"address":[6992356,6991734,6992166,6992013,6991954,6991907],"length":1,"stats":{"Line":9}},{"line":42,"address":[6993990],"length":1,"stats":{"Line":2}},{"line":44,"address":[6990340,6990775,6988877,6990744,6989870,6989354,6988953],"length":1,"stats":{"Line":10}},{"line":52,"address":[7203616],"length":1,"stats":{"Line":1}},{"line":57,"address":[6929335,6929507,6931136,6929145,6929709,6929276,6929593],"length":1,"stats":{"Line":7}},{"line":58,"address":[6994652],"length":1,"stats":{"Line":1}},{"line":59,"address":[6929193,6929677,6929404,6929348,6929539,6929304],"length":1,"stats":{"Line":5}},{"line":61,"address":[6993782],"length":1,"stats":{"Line":1}},{"line":63,"address":[6931104,6929746,6930147,6931063,6929670,6930660],"length":1,"stats":{"Line":4}}],"covered":13,"coverable":13},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","google_book_handler.rs"],"content":"use axum::{http::StatusCode, response::IntoResponse, Json};\nuse serde_json::json;\nuse std::sync::Arc;\n\nuse crate::error::AppError;\nuse crate::models::book::BookSearchRequest;\nuse crate::services::google_book_service::GoogleBookService;\n\npub struct GoogleBookHandler {\n    google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n}\n\nimpl GoogleBookHandler {\n    pub fn new(book_service: Arc\u003cdyn GoogleBookService\u003e) -\u003e Self {\n        Self {\n            google_book_service: book_service,\n        }\n    }\n\n    pub async fn search_books(\n        \u0026self,\n        Json(search_request): Json\u003cBookSearchRequest\u003e,\n    ) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n        if search_request.query.is_empty() {\n            return Err(AppError::ValidationError(\n                \"A consulta não pode estar vazia\".to_string(),\n            ));\n        }\n\n        let books = self\n            .google_book_service\n            .search_books(\u0026search_request.query)\n            .await?;\n\n        Ok((\n            StatusCode::OK,\n            Json(json!({\n                \"status\": \"success\",\n                \"message\": \"Livros encontrados com sucesso\",\n                \"data\": books\n            })),\n        ))\n    }\n}\n","traces":[{"line":14,"address":[4517568],"length":1,"stats":{"Line":19}},{"line":20,"address":[6654768],"length":1,"stats":{"Line":5}},{"line":24,"address":[7172332,7172208],"length":1,"stats":{"Line":11}},{"line":25,"address":[7172581],"length":1,"stats":{"Line":1}},{"line":26,"address":[7168898],"length":1,"stats":{"Line":1}},{"line":30,"address":[7172476,7172881,7175129,7172535,7172346,7173143,7172979],"length":1,"stats":{"Line":23}},{"line":32,"address":[7195179],"length":1,"stats":{"Line":5}},{"line":33,"address":[6666078],"length":1,"stats":{"Line":19}},{"line":35,"address":[7171317],"length":1,"stats":{"Line":4}},{"line":37,"address":[7107832,7109673,7109642,7108233,7108749,7107712,7109219],"length":1,"stats":{"Line":20}}],"covered":10,"coverable":10},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","handlers","mod.rs"],"content":"pub mod auth_handler;\npub mod book_offered_handler;\npub mod google_book_handler;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","lib.rs"],"content":"pub mod app;\npub mod config;\npub mod docs;\npub mod error;\npub mod handlers;\npub mod middleware;\npub mod models;\npub mod repositories;\npub mod routes;\npub mod services; ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","middleware","auth_middleware.rs"],"content":"use std::sync::Arc;\n\nuse axum::{\n    extract::Extension,\n    http::{header, Request},\n    middleware::Next,\n    response::Response,\n};\nuse jsonwebtoken::{decode, DecodingKey, Validation};\nuse uuid::Uuid;\n\nuse crate::{\n    config::Config,\n    error::AppError,\n    services::auth_service::{AuthServiceImpl, TokenClaims},\n};\n\npub async fn auth_middleware\u003cB\u003e(\n    Extension(_auth_service): Extension\u003cArc\u003cAuthServiceImpl\u003e\u003e,\n    mut request: Request\u003cB\u003e,\n    next: Next\u003cB\u003e,\n) -\u003e Result\u003cResponse, AppError\u003e {\n    // Verificar a existência do token de autenticação no header Authorization\n    let headers = request.headers();\n    let auth_header = headers.get(header::AUTHORIZATION);\n    let auth_header = auth_header\n        .and_then(|header| header.to_str().ok())\n        .ok_or_else(|| AppError::AuthError(\"Token de autenticação ausente\".to_string()))?;\n\n    // Validar o formato do token (Bearer \u003ctoken\u003e)\n    if !auth_header.starts_with(\"Bearer \") {\n        return Err(AppError::AuthError(\n            \"Formato de token inválido. Use Bearer \u003ctoken\u003e\".to_string(),\n        ));\n    }\n\n    // Extrair o token\n    let token = auth_header.trim_start_matches(\"Bearer \").trim();\n\n    // Carregar configuração\n    let config = Config::from_env().expect(\"Falha ao carregar configuração\");\n\n    // Validar o token JWT\n    let token_data = decode::\u003cTokenClaims\u003e(\n        token,\n        \u0026DecodingKey::from_secret(config.jwt_secret.as_bytes()),\n        \u0026Validation::default(),\n    )\n    .map_err(|e| AppError::AuthError(format!(\"Token inválido: {}\", e)))?;\n\n    // Extrair o user_id do token e converter para Uuid\n    let user_id_str = token_data.claims.sub;\n    let user_id = Uuid::parse_str(\u0026user_id_str)\n        .map_err(|_| AppError::AuthError(\"ID de usuário inválido no token\".to_string()))?;\n\n    // Adicionar o user_id aos extensions para que as rotas possam acessá-lo\n    request.extensions_mut().insert(user_id);\n\n    // Passar a requisição para o próximo handler\n    Ok(next.run(request).await)\n}\n","traces":[{"line":18,"address":[7206816],"length":1,"stats":{"Line":4}},{"line":24,"address":[7142575,7142708],"length":1,"stats":{"Line":8}},{"line":25,"address":[7204876],"length":1,"stats":{"Line":4}},{"line":26,"address":[7204949,7205174,7207170],"length":1,"stats":{"Line":8}},{"line":27,"address":[7208320,7208329],"length":1,"stats":{"Line":10}},{"line":28,"address":[7208382,7208368,7205142],"length":1,"stats":{"Line":6}},{"line":31,"address":[4330462,4330360],"length":1,"stats":{"Line":10}},{"line":32,"address":[7230577],"length":1,"stats":{"Line":1}},{"line":33,"address":[7204264],"length":1,"stats":{"Line":1}},{"line":38,"address":[4330723,4330515],"length":1,"stats":{"Line":10}},{"line":41,"address":[7143386],"length":1,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[4330943,4330846],"length":1,"stats":{"Line":10}},{"line":47,"address":[4330962],"length":1,"stats":{"Line":5}},{"line":49,"address":[4331063,4333600,4331354,4332304,4331270,4333635,4333782,4330981],"length":1,"stats":{"Line":14}},{"line":52,"address":[7226081],"length":1,"stats":{"Line":7}},{"line":53,"address":[7205612,7205434,7205341],"length":1,"stats":{"Line":12}},{"line":54,"address":[7218558,7218544,7216348],"length":1,"stats":{"Line":0}},{"line":57,"address":[7206509,7206614],"length":1,"stats":{"Line":12}},{"line":60,"address":[7206922,7206559,7203839,7205877,7205697],"length":1,"stats":{"Line":21}}],"covered":18,"coverable":20},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","middleware","mod.rs"],"content":"pub mod auth_middleware;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","book.rs"],"content":"use serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\nuse uuid::Uuid;\n\n#[derive(Debug, Serialize, ToSchema, Clone)]\npub struct GoogleBookDto {\n    pub google_id: String,\n    pub title: String,\n    pub authors: Option\u003cString\u003e,\n    pub publisher: Option\u003cString\u003e,\n    pub published_date: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub image_url: Option\u003cString\u003e,\n    pub page_count: Option\u003ci32\u003e,\n}\n\n#[derive(Debug, Serialize, ToSchema, Deserialize)]\npub struct BookSearchRequest {\n    pub query: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct BookOffered {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct BookWanted {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateBookOfferedDto {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateBookWantedDto {\n    pub book_id: Uuid,\n    pub user_id: Uuid,\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","mod.rs"],"content":"pub mod book;\npub mod user;\n\n#[cfg(test)]\nmod user_test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","user.rs"],"content":"use chrono::NaiveDateTime;\nuse serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\nuse utoipa::ToSchema;\nuse uuid::Uuid;\nuse validator::Validate;\nuse validator::{validate_email, ValidationError};\n\n#[derive(Debug, FromRow, Serialize)]\npub struct User {\n    pub id: Uuid,\n    pub name: String,\n    pub email: String,\n    #[serde(skip_serializing)]\n    pub hash_password: String,\n    pub created_at: NaiveDateTime,\n    pub updated_at: NaiveDateTime,\n}\n\n#[derive(Debug, Deserialize, ToSchema, Validate)]\npub struct CreateUserDto {\n    /// Nome do usuário (máximo 255 caracteres)\n    #[validate(length(min = 1, message = \"O nome não pode estar vazio\"))]\n    #[validate(length(max = 255, message = \"O nome deve ter menos de 255 caracteres\"))]\n    pub name: String,\n\n    /// Email do usuário (deve ser único e em formato válido)\n    #[validate(length(min = 1, message = \"O email não pode estar vazio\"))]\n    #[validate(length(max = 255, message = \"O email deve ter menos de 255 caracteres\"))]\n    #[validate(custom = \"validate_email_format\")]\n    pub email: String,\n\n    /// Senha do usuário (mínimo 6 caracteres)\n    #[validate(length(min = 6, message = \"A senha deve ter pelo menos 6 caracteres\"))]\n    pub password: String,\n}\n\nimpl CreateUserDto {\n    /// Valida todos os campos do DTO\n    ///\n    /// Retorna erro se algum campo não estiver de acordo com as regras de validação\n    pub fn validate_all(\u0026self) -\u003e Result\u003c(), crate::error::AppError\u003e {\n        match self.validate() {\n            Ok(_) =\u003e Ok(()),\n            Err(e) =\u003e Err(crate::error::AppError::ValidationError(format!(\n                \"Erro de validação: {}\",\n                e\n            ))),\n        }\n    }\n}\n\n/// Função personalizada para validar formato de email\nfn validate_email_format(email: \u0026str) -\u003e Result\u003c(), ValidationError\u003e {\n    if validate_email(email) {\n        Ok(())\n    } else {\n        let mut error = ValidationError::new(\"email\");\n        error.message = Some(\"Formato de email inválido\".into());\n        Err(error)\n    }\n}\n\n#[derive(Debug, Deserialize, ToSchema, Validate)]\npub struct LoginUserDto {\n    /// Email do usuário\n    #[validate(length(min = 1, message = \"O email não pode estar vazio\"))]\n    #[validate(length(max = 255, message = \"O email deve ter menos de 255 caracteres\"))]\n    #[validate(custom = \"validate_email_format\")]\n    pub email: String,\n\n    /// Senha do usuário\n    #[validate(length(min = 1, message = \"A senha não pode estar vazia\"))]\n    pub password: String,\n}\n\nimpl LoginUserDto {\n    /// Valida todos os campos do DTO\n    ///\n    /// Retorna erro se algum campo não estiver de acordo com as regras de validação\n    pub fn validate_all(\u0026self) -\u003e Result\u003c(), crate::error::AppError\u003e {\n        match self.validate() {\n            Ok(_) =\u003e Ok(()),\n            Err(e) =\u003e Err(crate::error::AppError::ValidationError(format!(\n                \"Erro de validação: {}\",\n                e\n            ))),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, ToSchema)]\npub struct UserResponse {\n    /// ID único do usuário\n    #[schema(value_type = String, format = \"uuid\")]\n    pub id: Uuid,\n    /// Nome do usuário\n    pub name: String,\n    /// Email do usuário\n    pub email: String,\n    /// Data de criação do registro\n    #[schema(value_type = String, format = DateTime)]\n    pub created_at: NaiveDateTime,\n    /// Data da última atualização\n    #[schema(value_type = String, format = DateTime)]\n    pub updated_at: NaiveDateTime,\n}\n\n#[derive(Debug, Serialize, ToSchema)]\npub struct TokenResponse {\n    /// Token JWT de acesso\n    pub access_token: String,\n    /// Tipo do token (Bearer)\n    pub token_type: String,\n    /// Informações do usuário\n    pub user: UserResponse,\n}\n\nimpl From\u003cUser\u003e for UserResponse {\n    fn from(user: User) -\u003e Self {\n        Self {\n            id: user.id,\n            name: user.name,\n            email: user.email,\n            created_at: user.created_at,\n            updated_at: user.updated_at,\n        }\n    }\n}\n","traces":[{"line":42,"address":[7337488,7337906],"length":1,"stats":{"Line":14}},{"line":43,"address":[7265544],"length":1,"stats":{"Line":10}},{"line":44,"address":[7347569],"length":1,"stats":{"Line":11}},{"line":45,"address":[7353251,7353018,7353126],"length":1,"stats":{"Line":6}},{"line":54,"address":[7327575,7327168],"length":1,"stats":{"Line":18}},{"line":55,"address":[3593993,3594084],"length":1,"stats":{"Line":32}},{"line":56,"address":[7353528],"length":1,"stats":{"Line":16}},{"line":58,"address":[3594002],"length":1,"stats":{"Line":2}},{"line":59,"address":[3594130,3594028],"length":1,"stats":{"Line":7}},{"line":60,"address":[7266316],"length":1,"stats":{"Line":2}},{"line":81,"address":[7338368,7338786],"length":1,"stats":{"Line":8}},{"line":82,"address":[3594392],"length":1,"stats":{"Line":11}},{"line":83,"address":[7328625],"length":1,"stats":{"Line":8}},{"line":84,"address":[7328742,7328634,7328867],"length":1,"stats":{"Line":3}},{"line":120,"address":[7329008],"length":1,"stats":{"Line":7}},{"line":122,"address":[7329031],"length":1,"stats":{"Line":8}},{"line":123,"address":[7348873],"length":1,"stats":{"Line":8}},{"line":124,"address":[7354339],"length":1,"stats":{"Line":8}},{"line":125,"address":[7338910],"length":1,"stats":{"Line":8}},{"line":126,"address":[7266958],"length":1,"stats":{"Line":8}}],"covered":20,"coverable":20},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","models","user_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::models::user::CreateUserDto;\n    use validator::Validate;\n\n    #[test]\n    fn test_valid_user_dto() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        assert!(\n            dto.validate().is_ok(),\n            \"O DTO válido deveria passar na validação\"\n        );\n    }\n\n    #[test]\n    fn test_empty_name() {\n        let dto = CreateUserDto {\n            name: \"\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com nome vazio deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"name\"),\n            \"Erro deveria estar no campo 'name'\"\n        );\n        assert!(\n            error.field_errors().get(\"name\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"não pode estar vazio\"),\n            \"Mensagem de erro deveria indicar que o nome não pode estar vazio\"\n        );\n    }\n\n    #[test]\n    fn test_long_name() {\n        // Criar um nome com 256 caracteres (acima do limite)\n        let name = \"A\".repeat(256);\n\n        let dto = CreateUserDto {\n            name,\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com nome longo demais deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"name\"),\n            \"Erro deveria estar no campo 'name'\"\n        );\n        assert!(\n            error.field_errors().get(\"name\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"menos de 255\"),\n            \"Mensagem de erro deveria indicar que o nome deve ter menos de 255 caracteres\"\n        );\n    }\n\n    #[test]\n    fn test_long_email() {\n        // Criar um nome com 256 caracteres (acima do limite)\n        let email = \"A\".repeat(256);\n\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email,\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com email longo demais deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"email\"),\n            \"Erro deveria estar no campo 'email'\"\n        );\n        assert!(\n            error.field_errors().get(\"email\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"menos de 255\"),\n            \"Mensagem de erro deveria indicar que o email deve ter menos de 255 caracteres\"\n        );\n    }\n\n    #[test]\n    fn test_empty_email() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com email vazio deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"email\"),\n            \"Erro deveria estar no campo 'email'\"\n        );\n        assert!(\n            error.field_errors().get(\"email\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"não pode estar vazio\"),\n            \"Mensagem de erro deveria indicar que o email não pode estar vazio\"\n        );\n    }\n\n    #[test]\n    fn test_invalid_email_format() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"email_invalido\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com formato de email inválido deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"email\"),\n            \"Erro deveria estar no campo 'email'\"\n        );\n        assert!(\n            error.field_errors().get(\"email\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"Formato de email inválido\"),\n            \"Mensagem de erro deveria indicar que o formato do email é inválido\"\n        );\n    }\n\n    #[test]\n    fn test_short_password() {\n        let dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"12345\".to_string(), // Menos de 6 caracteres\n        };\n\n        let result = dto.validate();\n        assert!(\n            result.is_err(),\n            \"O DTO com senha curta demais deveria falhar na validação\"\n        );\n\n        let error = result.unwrap_err();\n        assert!(\n            error.field_errors().contains_key(\"password\"),\n            \"Erro deveria estar no campo 'password'\"\n        );\n        assert!(\n            error.field_errors().get(\"password\").unwrap()[0]\n                .message\n                .as_ref()\n                .unwrap()\n                .contains(\"pelo menos 6 caracteres\"),\n            \"Mensagem de erro deveria indicar que a senha deve ter pelo menos 6 caracteres\"\n        );\n    }\n\n    #[test]\n    fn test_validate_all_method() {\n        // Teste com DTO válido\n        let valid_dto = CreateUserDto {\n            name: \"Teste\".to_string(),\n            email: \"teste@example.com\".to_string(),\n            password: \"senha123\".to_string(),\n        };\n        assert!(\n            valid_dto.validate_all().is_ok(),\n            \"O método validate_all deveria retornar Ok para um DTO válido\"\n        );\n\n        // Teste com DTO inválido\n        let invalid_dto = CreateUserDto {\n            name: \"\".to_string(),\n            email: \"email_invalido\".to_string(),\n            password: \"12345\".to_string(),\n        };\n        let result = invalid_dto.validate_all();\n        assert!(\n            result.is_err(),\n            \"O método validate_all deveria retornar Err para um DTO inválido\"\n        );\n\n        let error = result.unwrap_err();\n        match error {\n            crate::error::AppError::ValidationError(msg) =\u003e {\n                assert!(\n                    msg.contains(\"Erro de validação\"),\n                    \"Mensagem de erro deveria começar com 'Erro de validação'\"\n                );\n            }\n            _ =\u003e panic!(\"Tipo de erro inesperado, esperava ValidationError\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository.rs"],"content":"use crate::models::book::GoogleBookDto;\nuse chrono::NaiveDate;\nuse sqlx::PgPool;\nuse async_trait::async_trait;\nuse uuid::Uuid;\nuse crate::error::AppError;\n\n// Estender GoogleBookDto para incluir o id do banco de dados\n#[derive(Debug, Clone)]\npub struct BookWithId {\n    pub id: Uuid,\n    pub book: GoogleBookDto,\n}\n\n#[async_trait]\npub trait BookRepository: Send + Sync + 'static {\n    async fn create(\u0026self, book: \u0026GoogleBookDto) -\u003e Result\u003cUuid, AppError\u003e;\n    async fn find_by_google_id(\u0026self, google_id: \u0026str) -\u003e Result\u003cOption\u003cBookWithId\u003e, AppError\u003e;\n    async fn find_by_id(\u0026self, id: \u0026str) -\u003e Result\u003cOption\u003cGoogleBookDto\u003e, AppError\u003e;\n}\n\npub struct PgBookRepository {\n    pool: PgPool,\n}\n\nimpl PgBookRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl BookRepository for PgBookRepository {\n    async fn find_by_google_id(\u0026self, google_id: \u0026str) -\u003e Result\u003cOption\u003cBookWithId\u003e, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            SELECT \n                id,\n                google_id,\n                title,\n                author,\n                publisher,\n                published_date,\n                description,\n                image_url,\n                page_count\n            FROM books \n            WHERE google_id = $1\n            \"#,\n            google_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.map(|r| BookWithId {\n            id: r.id,\n            book: GoogleBookDto {\n                google_id: r.google_id.unwrap_or_default(),\n                title: r.title,\n                authors: Some(r.author),\n                publisher: r.publisher,\n                published_date: r.published_date.map(|d| d.to_string()),\n                description: Some(r.description),\n                image_url: Some(r.image_url),\n                page_count: r.page_count,\n            }\n        }))\n    }\n\n    async fn find_by_id(\u0026self, id: \u0026str) -\u003e Result\u003cOption\u003cGoogleBookDto\u003e, AppError\u003e {\n        // Tenta converter a string em UUID\n        let book_id = match Uuid::parse_str(id) {\n            Ok(uuid) =\u003e uuid,\n            Err(_) =\u003e return Ok(None), // Retorna None para IDs inválidos\n        };\n\n        let result = sqlx::query!(\n            r#\"\n            SELECT \n                google_id,\n                title,\n                author,\n                publisher,\n                published_date,\n                description,\n                image_url,\n                page_count\n            FROM books \n            WHERE id = $1\n            \"#,\n            book_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        match result {\n            Some(r) =\u003e Ok(Some(GoogleBookDto {\n                google_id: r.google_id.unwrap_or_default(),\n                title: r.title,\n                authors: Some(r.author),\n                publisher: r.publisher,\n                published_date: r.published_date.map(|d| d.to_string()),\n                description: Some(r.description),\n                image_url: Some(r.image_url),\n                page_count: r.page_count,\n            })),\n            None =\u003e Ok(None),\n        }\n    }\n\n    async fn create(\u0026self, book: \u0026GoogleBookDto) -\u003e Result\u003cUuid, AppError\u003e {\n        // Tenta converter a data de publicação para o formato NaiveDate\n        let published_date = match \u0026book.published_date {\n            Some(date_str) =\u003e {\n                match NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\") {\n                    Ok(date) =\u003e Some(date),\n                    Err(_) =\u003e {\n                        return Err(AppError::ValidationError(format!(\n                            \"A data '{}' deve estar no formato AAAA-MM-DD\",\n                            date_str\n                        )));\n                    }\n                }\n            }\n            None =\u003e None,\n        };\n\n        let result = sqlx::query!(\n            r#\"\n            INSERT INTO books (\n                title, \n                author, \n                description, \n                image_url, \n                publisher, \n                published_date, \n                page_count, \n                google_id\n            )\n            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n            RETURNING id\n            \"#,\n            \u0026book.title[..book.title.len().min(250)],\n            \u0026book.authors.clone().unwrap_or_default()[..book.authors.clone().unwrap_or_default().len().min(250)],\n            \u0026book.description.clone().unwrap_or_default()[..book.description.clone().unwrap_or_default().len().min(250)],\n            book.image_url.clone().unwrap_or_default(),\n            book.publisher,\n            published_date,\n            book.page_count,\n            book.google_id\n        )\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.id)\n    }\n}\n","traces":[{"line":27,"address":[7181696],"length":1,"stats":{"Line":20}},{"line":34,"address":[7179503],"length":1,"stats":{"Line":9}},{"line":35,"address":[4337260,4336812,4337801,4337561,4336886,4337484],"length":1,"stats":{"Line":15}},{"line":53,"address":[7047100,7047783,7047990,7047729,7047848],"length":1,"stats":{"Line":12}},{"line":54,"address":[7047536,7047554,7047329],"length":1,"stats":{"Line":0}},{"line":56,"address":[7058448,7059339,7058200,7059391,7059580,7058050],"length":1,"stats":{"Line":12}},{"line":57,"address":[7047702],"length":1,"stats":{"Line":3}},{"line":58,"address":[7059016],"length":1,"stats":{"Line":3}},{"line":59,"address":[7048722],"length":1,"stats":{"Line":3}},{"line":60,"address":[7074083],"length":1,"stats":{"Line":3}},{"line":61,"address":[6985970],"length":1,"stats":{"Line":3}},{"line":62,"address":[6986034],"length":1,"stats":{"Line":3}},{"line":63,"address":[6986069,6986912,6986928],"length":1,"stats":{"Line":9}},{"line":64,"address":[4338496],"length":1,"stats":{"Line":3}},{"line":65,"address":[7068936],"length":1,"stats":{"Line":3}},{"line":66,"address":[7059004],"length":1,"stats":{"Line":3}},{"line":71,"address":[7075440,7075104,7076160,7075285,7075151],"length":1,"stats":{"Line":3}},{"line":73,"address":[7050244],"length":1,"stats":{"Line":1}},{"line":74,"address":[7050301],"length":1,"stats":{"Line":1}},{"line":75,"address":[7060179],"length":1,"stats":{"Line":1}},{"line":78,"address":[6987966,6988261,6987580,6988196,6987454,6988479],"length":1,"stats":{"Line":5}},{"line":95,"address":[7076342,7076083,7075312,7076137,7076201],"length":1,"stats":{"Line":4}},{"line":96,"address":[7062608,7062626,7061135],"length":1,"stats":{"Line":0}},{"line":98,"address":[7051290],"length":1,"stats":{"Line":1}},{"line":99,"address":[7052071,7051442],"length":1,"stats":{"Line":2}},{"line":100,"address":[7076768],"length":1,"stats":{"Line":1}},{"line":101,"address":[7061451],"length":1,"stats":{"Line":1}},{"line":102,"address":[6988803],"length":1,"stats":{"Line":1}},{"line":103,"address":[7054267],"length":1,"stats":{"Line":1}},{"line":104,"address":[7071619,7072784,7072768],"length":1,"stats":{"Line":3}},{"line":105,"address":[7050905],"length":1,"stats":{"Line":1}},{"line":106,"address":[4341385],"length":1,"stats":{"Line":1}},{"line":107,"address":[6989177],"length":1,"stats":{"Line":1}},{"line":109,"address":[7051396],"length":1,"stats":{"Line":0}},{"line":113,"address":[7178919],"length":1,"stats":{"Line":3}},{"line":115,"address":[7063313],"length":1,"stats":{"Line":1}},{"line":116,"address":[7078855],"length":1,"stats":{"Line":1}},{"line":117,"address":[7053688,7053599],"length":1,"stats":{"Line":2}},{"line":118,"address":[7056281],"length":1,"stats":{"Line":1}},{"line":120,"address":[4345804,4343222,4345683],"length":1,"stats":{"Line":3}},{"line":127,"address":[7073387],"length":1,"stats":{"Line":0}},{"line":130,"address":[7081503,7079704,7079218,7079961,7082377,7081967,7079323,7080061,7079417,7079580,7082084,7079798],"length":1,"stats":{"Line":7}},{"line":145,"address":[7056352,7056142],"length":1,"stats":{"Line":2}},{"line":146,"address":[6991082,6991322,6991223],"length":1,"stats":{"Line":3}},{"line":147,"address":[7056855,7056996,7057095],"length":1,"stats":{"Line":3}},{"line":148,"address":[6991844],"length":1,"stats":{"Line":1}},{"line":155,"address":[7066077,7066397,7062985,7066020,7066559],"length":1,"stats":{"Line":4}},{"line":156,"address":[7066960,7066978,7066889],"length":1,"stats":{"Line":0}},{"line":158,"address":[6994056],"length":1,"stats":{"Line":1}}],"covered":44,"coverable":49},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","create_book_test.rs"],"content":"use crate::error::AppError;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_create_book() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"abc123\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Verifica se o ID retornado não é vazio\n    assert!(\n        book_id.to_string().len() \u003e 0,\n        \"O ID do livro não deve ser vazio\"\n    );\n\n    // Busca o livro usando o repository\n    let found_book = book_repository\n        .find_by_google_id(\u0026book.google_id)\n        .await\n        .expect(\"Falha ao buscar livro pelo google_id\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro criado não foi encontrado pelo google_id\"\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se o ID do livro corresponde ao ID retornado pela criação\n    assert_eq!(found_book.id, book_id, \"O ID do livro não corresponde ao ID retornado pela criação\");\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.book.google_id, book.google_id);\n    assert_eq!(found_book.book.title, book.title);\n    assert_eq!(found_book.book.authors, book.authors);\n    assert_eq!(found_book.book.publisher, book.publisher);\n    assert_eq!(found_book.book.published_date, book.published_date);\n    assert_eq!(found_book.book.description, book.description);\n    assert_eq!(found_book.book.image_url, book.image_url);\n    assert_eq!(found_book.book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_create_book_with_invalid_date() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory, com uma data inválida\n    let book = create_test_book(\"abc456\", false);\n\n    // Tenta inserir o livro com data inválida e espera um erro de validação\n    let result = book_repository.create(\u0026book).await;\n\n    assert!(result.is_err(), \"Deveria falhar ao criar livro com data inválida\");\n\n    // Verifica se é um erro de validação\n    match result {\n        Err(AppError::ValidationError(_)) =\u003e (),\n        _ =\u003e panic!(\"Esperava um erro de validação\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","find_book_by_google_id_test.rs"],"content":"use crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_find_book_by_google_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"test123\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Testa a função find_by_google_id\n    let found_book = book_repository\n        .find_by_google_id(\u0026book.google_id)\n        .await\n        .expect(\"Falha ao buscar livro\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro com google_id '{}' não foi encontrado\",\n        book.google_id\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se o ID do livro corresponde ao ID retornado pela criação\n    assert_eq!(found_book.id, book_id, \"O ID do livro não corresponde ao ID retornado pela criação\");\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.book.google_id, book.google_id);\n    assert_eq!(found_book.book.title, book.title);\n    assert_eq!(found_book.book.authors, book.authors);\n    assert_eq!(found_book.book.publisher, book.publisher);\n    // Comparação simplificada para published_date já que pode haver diferenças de formatação\n    assert!(found_book.book.published_date.is_some());\n    assert_eq!(\n        found_book.book.description.unwrap_or_default(),\n        book.description.unwrap_or_default()\n    );\n    assert_eq!(\n        found_book.book.image_url.unwrap_or_default(),\n        book.image_url.unwrap_or_default()\n    );\n    assert_eq!(found_book.book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_find_book_by_google_id_not_found() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Testa buscar um livro que não existe\n    let not_found = book_repository\n        .find_by_google_id(\"non_existent_id\")\n        .await\n        .expect(\"Falha na consulta\");\n\n    assert!(not_found.is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","find_by_google_id_test.rs"],"content":"use crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_find_by_google_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"test_find_by_google_id_456\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Verifica se o ID retornado não é vazio\n    assert!(\n        book_id.to_string().len() \u003e 0,\n        \"O ID do livro não deve ser vazio\"\n    );\n\n    // Busca o livro usando o repository\n    let found_book = book_repository\n        .find_by_google_id(\u0026book.google_id)\n        .await\n        .expect(\"Falha ao buscar livro pelo google_id\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro criado não foi encontrado pelo google_id\"\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se o ID do livro corresponde ao ID retornado pela criação\n    assert_eq!(found_book.id, book_id, \"O ID do livro não corresponde ao ID retornado pela criação\");\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.book.google_id, book.google_id);\n    assert_eq!(found_book.book.title, book.title);\n    assert_eq!(found_book.book.authors, book.authors);\n    assert_eq!(found_book.book.publisher, book.publisher);\n    assert_eq!(found_book.book.published_date, book.published_date);\n    assert_eq!(found_book.book.description, book.description);\n    assert_eq!(found_book.book.image_url, book.image_url);\n    assert_eq!(found_book.book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_find_by_google_id_not_found() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Busca um livro com um google_id que não existe\n    let result = book_repository\n        .find_by_google_id(\"nonexistent_id\")\n        .await\n        .expect(\"Falha ao buscar livro pelo google_id\");\n\n    // Verifica se o resultado é None\n    assert!(\n        result.is_none(),\n        \"Não deveria encontrar um livro com google_id inexistente\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","find_by_id_test.rs"],"content":"use crate::repositories::book_repository::BookRepository;\nuse crate::repositories::book_repository_test::create_test_book;\nuse crate::repositories::book_repository_test::setup_test_repository;\nuse crate::repositories::test_helpers::get_test_mutex;\n\n#[tokio::test]\nasync fn test_find_by_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste usando a factory\n    let book = create_test_book(\"test_find_123\", true);\n\n    // Insere o livro no banco de dados\n    let book_id = book_repository\n        .create(\u0026book)\n        .await\n        .expect(\"Falha ao criar livro\");\n\n    // Verifica se o ID retornado não é vazio\n    assert!(\n        book_id.to_string().len() \u003e 0,\n        \"O ID do livro não deve ser vazio\"\n    );\n\n    // Busca o livro usando o repository - convertendo UUID para string\n    let found_book = book_repository\n        .find_by_id(\u0026book_id.to_string())\n        .await\n        .expect(\"Falha ao buscar livro pelo ID\");\n\n    // Verifica se o livro foi encontrado\n    assert!(\n        found_book.is_some(),\n        \"O livro criado não foi encontrado pelo ID\"\n    );\n\n    let found_book = found_book.unwrap();\n\n    // Verifica se os dados do livro encontrado correspondem aos dados inseridos\n    assert_eq!(found_book.google_id, book.google_id);\n    assert_eq!(found_book.title, book.title);\n    assert_eq!(found_book.authors, book.authors);\n    assert_eq!(found_book.publisher, book.publisher);\n    assert_eq!(found_book.published_date, book.published_date);\n    assert_eq!(found_book.description, book.description);\n    assert_eq!(found_book.image_url, book.image_url);\n    assert_eq!(found_book.page_count, book.page_count);\n}\n\n#[tokio::test]\nasync fn test_find_by_id_not_found() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let book_repository = setup_test_repository().await;\n\n    // Busca um livro com um ID que não existe\n    let result = book_repository\n        .find_by_id(\"nonexistent_id\")\n        .await\n        .expect(\"Falha ao buscar livro pelo ID\");\n\n    // Verifica se o resultado é None\n    assert!(\n        result.is_none(),\n        \"Não deveria encontrar um livro com ID inexistente\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","book_repository_test","mod.rs"],"content":"pub mod create_book_test;\npub mod find_book_by_google_id_test;\npub mod find_by_google_id_test;\npub mod find_by_id_test;\n\nuse crate::models::book::GoogleBookDto;\nuse crate::repositories::book_repository::PgBookRepository;\nuse crate::repositories::test_helpers::get_test_db_pool;\n\n\nasync fn setup_test_repository() -\u003e PgBookRepository {\n    // Obtém o pool de conexão com o banco de dados de teste\n    let pool = get_test_db_pool().await;\n\n    // Limpa o banco de dados para garantir o isolamento dos testes\n    crate::repositories::test_helpers::clean_database(\u0026pool).await;\n\n    // Criamos o DatabasePool com o pool real\n    PgBookRepository::new(pool)\n}\n\npub fn create_test_book(google_id: \u0026str, with_valid_date: bool) -\u003e GoogleBookDto {\n    GoogleBookDto {\n        google_id: String::from(google_id),\n        title: String::from(\"Livro de Teste\"),\n        authors: Some(String::from(\"Autor Teste\")),\n        publisher: Some(String::from(\"Editora Teste\")),\n        // Usa data válida ou inválida conforme solicitado\n        published_date: Some(String::from(if with_valid_date {\n            \"2022-05-10\"\n        } else {\n            \"10/05/2022\"\n        })),\n        description: Some(String::from(\"Esta é uma descrição de teste\")),\n        image_url: Some(String::from(\"http://example.com/livro.jpg\")),\n        page_count: Some(300),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository.rs"],"content":"use async_trait::async_trait;\nuse sqlx::PgPool;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookOffered, CreateBookOfferedDto};\n\n#[async_trait]\npub trait BooksOfferedRepository: Send + Sync + 'static {\n    async fn create(\u0026self, book_offered: \u0026CreateBookOfferedDto) -\u003e Result\u003cBookOffered, AppError\u003e;\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookOffered\u003e, AppError\u003e;\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct PgBooksOfferedRepository {\n    pool: PgPool,\n}\n\nimpl PgBooksOfferedRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl BooksOfferedRepository for PgBooksOfferedRepository {\n    async fn create(\u0026self, book_offered: \u0026CreateBookOfferedDto) -\u003e Result\u003cBookOffered, AppError\u003e {\n        // Inserir na tabela books_offered\n        let result = sqlx::query!(\n            r#\"\n            INSERT INTO books_offered (book_id, user_id)\n            VALUES ($1, $2)\n            RETURNING book_id, user_id\n            \"#,\n            book_offered.book_id,\n            book_offered.user_id\n        )\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| {\n            if e.to_string().contains(\"duplicate key\") {\n                AppError::ValidationError(\"Este livro já está na sua lista de possuídos\".to_string())\n            } else if e.to_string().contains(\"foreign key constraint\") {\n                if e.to_string().contains(\"books_offered_book_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Livro com ID {} não encontrado\",\n                        book_offered.book_id\n                    ))\n                } else if e.to_string().contains(\"books_offered_user_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Usuário com ID {} não encontrado\",\n                        book_offered.user_id\n                    ))\n                } else {\n                    AppError::DatabaseError(e.to_string())\n                }\n            } else {\n                AppError::DatabaseError(e.to_string())\n            }\n        })?;\n\n        Ok(BookOffered {\n            book_id: result.book_id,\n            user_id: result.user_id,\n        })\n    }\n\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookOffered\u003e, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            SELECT book_id, user_id\n            FROM books_offered\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.map(|r| BookOffered {\n            book_id: r.book_id,\n            user_id: r.user_id,\n        }))\n    }\n\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            DELETE FROM books_offered\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .execute(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        // Retorna true se algo foi excluído, false caso contrário\n        Ok(result.rows_affected() \u003e 0)\n    }\n} ","traces":[{"line":20,"address":[7223296],"length":1,"stats":{"Line":16}},{"line":27,"address":[7305319],"length":1,"stats":{"Line":9}},{"line":29,"address":[6802447,6802960,6802557,6802243,6801700],"length":1,"stats":{"Line":13}},{"line":39,"address":[6817726,6817791,6817672,6816960,6817951],"length":1,"stats":{"Line":12}},{"line":40,"address":[6814476,6814185,6812564,6813024],"length":1,"stats":{"Line":4}},{"line":41,"address":[6818499,6818567,6819911],"length":1,"stats":{"Line":3}},{"line":42,"address":[6797080],"length":1,"stats":{"Line":1}},{"line":43,"address":[6813278],"length":1,"stats":{"Line":1}},{"line":44,"address":[6793603,6792768],"length":1,"stats":{"Line":2}},{"line":45,"address":[6797032,6796882],"length":1,"stats":{"Line":2}},{"line":49,"address":[6731029,6731476,6731274],"length":1,"stats":{"Line":2}},{"line":50,"address":[3710125,3709975],"length":1,"stats":{"Line":2}},{"line":55,"address":[3709915],"length":1,"stats":{"Line":0}},{"line":58,"address":[6730752],"length":1,"stats":{"Line":0}},{"line":62,"address":[3708797],"length":1,"stats":{"Line":3}},{"line":63,"address":[6791929],"length":1,"stats":{"Line":3}},{"line":64,"address":[6802729],"length":1,"stats":{"Line":3}},{"line":68,"address":[6797219,6797184,6797301,6797456,6798114],"length":1,"stats":{"Line":9}},{"line":69,"address":[6794785,6794591,6795166,6794052,6795063,6794886],"length":1,"stats":{"Line":12}},{"line":79,"address":[6794564,6794683,6794618,6794833,6793856],"length":1,"stats":{"Line":12}},{"line":80,"address":[6821408,6821426,6821255],"length":1,"stats":{"Line":0}},{"line":82,"address":[6733084,6733446,6733177,6733408],"length":1,"stats":{"Line":12}},{"line":83,"address":[6796291],"length":1,"stats":{"Line":3}},{"line":84,"address":[6796308],"length":1,"stats":{"Line":3}},{"line":88,"address":[6816574,6817205,6816317,6816192,6816227],"length":1,"stats":{"Line":6}},{"line":89,"address":[6800310,6800151,6800445,6800046,6799842,6799330],"length":1,"stats":{"Line":8}},{"line":98,"address":[6680265],"length":1,"stats":{"Line":8}},{"line":99,"address":[6796992,6797010,6796806],"length":1,"stats":{"Line":0}},{"line":102,"address":[6734863,6734956],"length":1,"stats":{"Line":4}}],"covered":25,"coverable":29},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","create_books_offered_test.rs"],"content":"use crate::models::book::CreateBookOfferedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_offered_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_create_books_offered() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa a criação de um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    let result = books_offered_repository.create(\u0026book_offered).await;\n    \n    assert!(result.is_ok(), \"Falha ao criar book_offered: {:?}\", result.err());\n    \n    let book_offered = result.unwrap();\n    assert_eq!(book_offered.book_id, book_id);\n    assert_eq!(book_offered.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_create_books_offered_with_invalid_book_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta criar um book_offered com um book_id inexistente\n    let book_offered = CreateBookOfferedDto {\n        book_id: Uuid::new_v4(),\n        user_id: user.id,\n    };\n\n    let result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com book_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Livro com ID\"), \n        \"Erro deveria indicar que o livro não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_offered_with_invalid_user_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"invalid_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Tenta criar um book_offered com um user_id inexistente\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: Uuid::new_v4(),\n    };\n\n    let result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com user_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Usuário com ID\"), \n        \"Erro deveria indicar que o usuário não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_offered_duplicate() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"duplicate_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    // Primeira inserção deve ter sucesso\n    let first_result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(first_result.is_ok(), \"A primeira inserção deveria ter sucesso\");\n\n    // Segunda inserção deve falhar com erro de duplicação\n    let second_result = books_offered_repository.create(\u0026book_offered).await;\n    assert!(second_result.is_err(), \"A segunda inserção deveria falhar\");\n    \n    let error = second_result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"já está na sua lista\"), \n        \"Erro deveria indicar que o livro já está na lista: {:?}\", error\n    );\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","delete_books_offered_test.rs"],"content":"use crate::models::book::CreateBookOfferedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_offered_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_delete_books_offered() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_offered_repository.create(\u0026book_offered).await.unwrap();\n\n    // Verifica se o book_offered foi criado corretamente\n    let find_result_before = books_offered_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_before.is_some(), \"O book_offered deveria existir antes da deleção\");\n\n    // Testa a deleção do book_offered\n    let result = books_offered_repository.delete(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao deletar book_offered: {:?}\", result.err());\n    assert!(result.unwrap(), \"A deleção deveria retornar true\");\n\n    // Verifica se foi realmente deletado\n    let find_result_after = books_offered_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_after.is_none(), \"O book_offered não foi deletado corretamente\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_offered_nonexistent() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta deletar um book_offered inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_offered_repository.delete(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A deleção deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(!result.unwrap(), \"Deleção de ID inexistente deveria retornar false\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_offered_multiple_users() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_multi_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria books_offered para ambos os usuários\n    let book_offered1 = CreateBookOfferedDto {\n        book_id,\n        user_id: user1.id,\n    };\n    \n    let book_offered2 = CreateBookOfferedDto {\n        book_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_offered_repository.create(\u0026book_offered1).await.unwrap();\n    books_offered_repository.create(\u0026book_offered2).await.unwrap();\n\n    // Deleta apenas para o usuário 1\n    let delete_result = books_offered_repository.delete(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o usuário 1 deveria ter sucesso\");\n\n    // Verifica se foi removido para o usuário 1\n    let find_result1 = books_offered_repository.find(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro não deveria mais estar oferecido pelo usuário 1\");\n\n    // Verifica se ainda existe para o usuário 2\n    let find_result2 = books_offered_repository.find(\u0026book_id, \u0026user2.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro ainda deveria estar oferecido pelo usuário 2\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_offered_multiple_books() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"delete_book1_test\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"delete_book2_test\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria books_offered para ambos os livros\n    let book_offered1 = CreateBookOfferedDto {\n        book_id: book1_id,\n        user_id: user.id,\n    };\n    \n    let book_offered2 = CreateBookOfferedDto {\n        book_id: book2_id,\n        user_id: user.id,\n    };\n\n    // Insere as relações\n    books_offered_repository.create(\u0026book_offered1).await.unwrap();\n    books_offered_repository.create(\u0026book_offered2).await.unwrap();\n\n    // Deleta apenas o livro 1\n    let delete_result = books_offered_repository.delete(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o livro 1 deveria ter sucesso\");\n\n    // Verifica se o livro 1 foi removido\n    let find_result1 = books_offered_repository.find(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro 1 não deveria mais estar oferecido\");\n\n    // Verifica se o livro 2 ainda existe\n    let find_result2 = books_offered_repository.find(\u0026book2_id, \u0026user.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro 2 ainda deveria estar oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","find_books_offered_test.rs"],"content":"use crate::models::book::CreateBookOfferedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_offered_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_find_books_offered() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_offered\n    let book_offered = CreateBookOfferedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_offered_repository.create(\u0026book_offered).await.unwrap();\n\n    // Testa a busca do book_offered\n    let result = books_offered_repository.find(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao buscar book_offered: {:?}\", result.err());\n    \n    let found = result.unwrap();\n    assert!(found.is_some(), \"Book offered não encontrado\");\n    \n    let found = found.unwrap();\n    assert_eq!(found.book_id, book_id);\n    assert_eq!(found.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_find_books_offered_nonexistent_book() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Testa busca com book_id inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_offered_repository.find(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_offered com ID de livro inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_offered_nonexistent_user() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_nonexistent_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa busca com user_id inexistente\n    let non_existent_user_id = Uuid::new_v4();\n    let result = books_offered_repository.find(\u0026book_id, \u0026non_existent_user_id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com user_id inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_offered com user_id inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_offered_multiple_entries() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_offered_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"find_multi_test1\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"find_multi_test2\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria várias relações de books_offered\n    let book_offered1 = CreateBookOfferedDto {\n        book_id: book1_id,\n        user_id: user1.id,\n    };\n    \n    let book_offered2 = CreateBookOfferedDto {\n        book_id: book2_id,\n        user_id: user1.id,\n    };\n    \n    let book_offered3 = CreateBookOfferedDto {\n        book_id: book1_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_offered_repository.create(\u0026book_offered1).await.unwrap();\n    books_offered_repository.create(\u0026book_offered2).await.unwrap();\n    books_offered_repository.create(\u0026book_offered3).await.unwrap();\n\n    // Teste 1: Usuário 1 oferece o Livro 1\n    let result1 = books_offered_repository.find(\u0026book1_id, \u0026user1.id).await.unwrap();\n    assert!(result1.is_some(), \"Usuário 1 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 2: Usuário 1 oferece o Livro 2\n    let result2 = books_offered_repository.find(\u0026book2_id, \u0026user1.id).await.unwrap();\n    assert!(result2.is_some(), \"Usuário 1 deveria ter o Livro 2 como oferecido\");\n    \n    // Teste 3: Usuário 2 oferece o Livro 1\n    let result3 = books_offered_repository.find(\u0026book1_id, \u0026user2.id).await.unwrap();\n    assert!(result3.is_some(), \"Usuário 2 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 4: Usuário 2 NÃO oferece o Livro 2\n    let result4 = books_offered_repository.find(\u0026book2_id, \u0026user2.id).await.unwrap();\n    assert!(result4.is_none(), \"Usuário 2 não deveria ter o Livro 2 como oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_offered_repository_test","mod.rs"],"content":"pub mod create_books_offered_test;\npub mod find_books_offered_test;\npub mod delete_books_offered_test;\n\nuse crate::models::book::GoogleBookDto;\nuse crate::models::user::CreateUserDto;\nuse crate::repositories::book_repository::{BookRepository, PgBookRepository};\nuse crate::repositories::books_offered_repository::{BooksOfferedRepository, PgBooksOfferedRepository};\nuse crate::repositories::test_helpers::{get_test_db_pool, clean_database};\nuse crate::repositories::user_repository::{UserRepository, PgUserRepository};\nuse uuid::Uuid;\n\n// Cria uma função de setup de repositório para o PgBookRepository\npub async fn setup_book_repository() -\u003e impl BookRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBookRepository::new(pool)\n}\n\n// Cria uma função de setup de repositório para o PgUserRepository\npub async fn setup_user_repository() -\u003e impl UserRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgUserRepository::new(pool)\n}\n\n// Função para criar o repositório de books_offered\npub async fn setup_test_repository() -\u003e impl BooksOfferedRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBooksOfferedRepository::new(pool)\n}\n\n// Função para criar um usuário de teste\npub fn create_test_user() -\u003e CreateUserDto {\n    CreateUserDto {\n        name: \"Test User\".to_string(),\n        email: format!(\"test_{}@example.com\", Uuid::new_v4()),\n        password: \"password\".to_string(),\n    }\n}\n\n// Função para criar um livro de teste\npub fn create_test_book(google_id: \u0026str) -\u003e GoogleBookDto {\n    GoogleBookDto {\n        google_id: google_id.to_string(),\n        title: \"Livro de Teste\".to_string(),\n        authors: Some(\"Autor Teste\".to_string()),\n        publisher: Some(\"Editora Teste\".to_string()),\n        published_date: Some(\"2022-05-10\".to_string()),\n        description: Some(\"Descrição de teste\".to_string()),\n        image_url: Some(\"http://example.com/image.jpg\".to_string()),\n        page_count: Some(200),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository.rs"],"content":"use async_trait::async_trait;\nuse sqlx::PgPool;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookWanted, CreateBookWantedDto};\n\n#[async_trait]\npub trait BooksWantedRepository: Send + Sync + 'static {\n    async fn create(\u0026self, book_wanted: \u0026CreateBookWantedDto) -\u003e Result\u003cBookWanted, AppError\u003e;\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookWanted\u003e, AppError\u003e;\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct PgBooksWantedRepository {\n    pool: PgPool,\n}\n\nimpl PgBooksWantedRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl BooksWantedRepository for PgBooksWantedRepository {\n    async fn create(\u0026self, book_wanted: \u0026CreateBookWantedDto) -\u003e Result\u003cBookWanted, AppError\u003e {\n        // Inserir na tabela books_wanted\n        let result = sqlx::query!(\n            r#\"\n            INSERT INTO books_wanted (book_id, user_id)\n            VALUES ($1, $2)\n            RETURNING book_id, user_id\n            \"#,\n            book_wanted.book_id,\n            book_wanted.user_id\n        )\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| {\n            if e.to_string().contains(\"duplicate key\") {\n                AppError::ValidationError(\"Este livro já está na sua lista de desejados\".to_string())\n            } else if e.to_string().contains(\"foreign key constraint\") {\n                if e.to_string().contains(\"books_wanted_book_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Livro com ID {} não encontrado\",\n                        book_wanted.book_id\n                    ))\n                } else if e.to_string().contains(\"books_wanted_user_id_fkey\") {\n                    AppError::ValidationError(format!(\n                        \"Usuário com ID {} não encontrado\",\n                        book_wanted.user_id\n                    ))\n                } else {\n                    AppError::DatabaseError(e.to_string())\n                }\n            } else {\n                AppError::DatabaseError(e.to_string())\n            }\n        })?;\n\n        Ok(BookWanted {\n            book_id: result.book_id,\n            user_id: result.user_id,\n        })\n    }\n\n    async fn find(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cOption\u003cBookWanted\u003e, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            SELECT book_id, user_id\n            FROM books_wanted\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        Ok(result.map(|r| BookWanted {\n            book_id: r.book_id,\n            user_id: r.user_id,\n        }))\n    }\n\n    async fn delete(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        let result = sqlx::query!(\n            r#\"\n            DELETE FROM books_wanted\n            WHERE book_id = $1 AND user_id = $2\n            \"#,\n            book_id,\n            user_id\n        )\n        .execute(\u0026self.pool)\n        .await\n        .map_err(|e| AppError::DatabaseError(e.to_string()))?;\n\n        // Retorna true se algo foi excluído, false caso contrário\n        Ok(result.rows_affected() \u003e 0)\n    }\n} ","traces":[{"line":20,"address":[7016096],"length":1,"stats":{"Line":20}},{"line":27,"address":[7098839],"length":1,"stats":{"Line":3}},{"line":29,"address":[7031117,7031520,7030260,7030803,7031007],"length":1,"stats":{"Line":5}},{"line":39,"address":[7046286,7045520,7046351,7046232,7046511],"length":1,"stats":{"Line":4}},{"line":40,"address":[7042745,7041124,7043036,7041584],"length":1,"stats":{"Line":2}},{"line":41,"address":[7047127,7048471,7047059],"length":1,"stats":{"Line":3}},{"line":42,"address":[7025640],"length":1,"stats":{"Line":1}},{"line":43,"address":[7041838],"length":1,"stats":{"Line":1}},{"line":44,"address":[7022163,7021328],"length":1,"stats":{"Line":2}},{"line":45,"address":[7025442,7025592],"length":1,"stats":{"Line":2}},{"line":49,"address":[6959589,6960036,6959834],"length":1,"stats":{"Line":2}},{"line":50,"address":[3682231,3682381],"length":1,"stats":{"Line":2}},{"line":55,"address":[3682171],"length":1,"stats":{"Line":0}},{"line":58,"address":[6959312],"length":1,"stats":{"Line":0}},{"line":62,"address":[3681053],"length":1,"stats":{"Line":1}},{"line":63,"address":[7020489],"length":1,"stats":{"Line":1}},{"line":64,"address":[7031289],"length":1,"stats":{"Line":1}},{"line":68,"address":[7025861,7025779,7025744,7026674,7026016],"length":1,"stats":{"Line":9}},{"line":69,"address":[7023623,7023726,7023446,7023151,7023345,7022612],"length":1,"stats":{"Line":12}},{"line":79,"address":[7023178,7023124,7022416,7023393,7023243],"length":1,"stats":{"Line":12}},{"line":80,"address":[7049986,7049815,7049968],"length":1,"stats":{"Line":0}},{"line":82,"address":[6961644,6962006,6961737,6961968],"length":1,"stats":{"Line":8}},{"line":83,"address":[7024851],"length":1,"stats":{"Line":1}},{"line":84,"address":[7024868],"length":1,"stats":{"Line":1}},{"line":88,"address":[7045134,7045765,7044752,7044787,7044877],"length":1,"stats":{"Line":3}},{"line":89,"address":[7029005,7028870,7028606,7028711,7027890,7028402],"length":1,"stats":{"Line":4}},{"line":98,"address":[6678969],"length":1,"stats":{"Line":4}},{"line":99,"address":[7025366,7025552,7025570],"length":1,"stats":{"Line":0}},{"line":102,"address":[6963423,6963516],"length":1,"stats":{"Line":2}}],"covered":25,"coverable":29},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","create_books_wanted_test.rs"],"content":"use crate::models::book::CreateBookWantedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_wanted_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_create_books_wanted() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa a criação de um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    let result = books_wanted_repository.create(\u0026book_wanted).await;\n    \n    assert!(result.is_ok(), \"Falha ao criar book_wanted: {:?}\", result.err());\n    \n    let book_wanted = result.unwrap();\n    assert_eq!(book_wanted.book_id, book_id);\n    assert_eq!(book_wanted.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_create_books_wanted_with_invalid_book_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta criar um book_wanted com um book_id inexistente\n    let book_wanted = CreateBookWantedDto {\n        book_id: Uuid::new_v4(),\n        user_id: user.id,\n    };\n\n    let result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com book_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Livro com ID\"), \n        \"Erro deveria indicar que o livro não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_wanted_with_invalid_user_id() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"invalid_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Tenta criar um book_wanted com um user_id inexistente\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: Uuid::new_v4(),\n    };\n\n    let result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(result.is_err(), \"Deveria falhar ao criar com user_id inválido\");\n    \n    let error = result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"Usuário com ID\"), \n        \"Erro deveria indicar que o usuário não foi encontrado\"\n    );\n}\n\n#[tokio::test]\nasync fn test_create_books_wanted_duplicate() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"duplicate_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    // Primeira inserção deve ter sucesso\n    let first_result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(first_result.is_ok(), \"A primeira inserção deveria ter sucesso\");\n\n    // Segunda inserção deve falhar com erro de duplicação\n    let second_result = books_wanted_repository.create(\u0026book_wanted).await;\n    assert!(second_result.is_err(), \"A segunda inserção deveria falhar\");\n    \n    let error = second_result.unwrap_err();\n    assert!(\n        format!(\"{:?}\", error).contains(\"já está na sua lista\"), \n        \"Erro deveria indicar que o livro já está na lista: {:?}\", error\n    );\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","delete_books_wanted_test.rs"],"content":"use crate::models::book::CreateBookWantedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_wanted_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_delete_books_wanted() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_wanted_repository.create(\u0026book_wanted).await.unwrap();\n\n    // Verifica se o book_wanted foi criado corretamente\n    let find_result_before = books_wanted_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_before.is_some(), \"O book_wanted deveria existir antes da deleção\");\n\n    // Testa a deleção do book_wanted\n    let result = books_wanted_repository.delete(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao deletar book_wanted: {:?}\", result.err());\n    assert!(result.unwrap(), \"A deleção deveria retornar true\");\n\n    // Verifica se foi realmente deletado\n    let find_result_after = books_wanted_repository.find(\u0026book_id, \u0026user.id).await.unwrap();\n    assert!(find_result_after.is_none(), \"O book_wanted não foi deletado corretamente\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_wanted_nonexistent() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Tenta deletar um book_wanted inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_wanted_repository.delete(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A deleção deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(!result.unwrap(), \"Deleção de ID inexistente deveria retornar false\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_wanted_multiple_users() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"delete_multi_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria books_wanted para ambos os usuários\n    let book_wanted1 = CreateBookWantedDto {\n        book_id,\n        user_id: user1.id,\n    };\n    \n    let book_wanted2 = CreateBookWantedDto {\n        book_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_wanted_repository.create(\u0026book_wanted1).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted2).await.unwrap();\n\n    // Deleta apenas para o usuário 1\n    let delete_result = books_wanted_repository.delete(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o usuário 1 deveria ter sucesso\");\n\n    // Verifica se foi removido para o usuário 1\n    let find_result1 = books_wanted_repository.find(\u0026book_id, \u0026user1.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro não deveria mais estar oferecido pelo usuário 1\");\n\n    // Verifica se ainda existe para o usuário 2\n    let find_result2 = books_wanted_repository.find(\u0026book_id, \u0026user2.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro ainda deveria estar oferecido pelo usuário 2\");\n}\n\n#[tokio::test]\nasync fn test_delete_books_wanted_multiple_books() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"delete_book1_test\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"delete_book2_test\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria books_wanted para ambos os livros\n    let book_wanted1 = CreateBookWantedDto {\n        book_id: book1_id,\n        user_id: user.id,\n    };\n    \n    let book_wanted2 = CreateBookWantedDto {\n        book_id: book2_id,\n        user_id: user.id,\n    };\n\n    // Insere as relações\n    books_wanted_repository.create(\u0026book_wanted1).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted2).await.unwrap();\n\n    // Deleta apenas o livro 1\n    let delete_result = books_wanted_repository.delete(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(delete_result, \"A deleção para o livro 1 deveria ter sucesso\");\n\n    // Verifica se o livro 1 foi removido\n    let find_result1 = books_wanted_repository.find(\u0026book1_id, \u0026user.id).await.unwrap();\n    assert!(find_result1.is_none(), \"O livro 1 não deveria mais estar oferecido\");\n\n    // Verifica se o livro 2 ainda existe\n    let find_result2 = books_wanted_repository.find(\u0026book2_id, \u0026user.id).await.unwrap();\n    assert!(find_result2.is_some(), \"O livro 2 ainda deveria estar oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","find_books_wanted_test.rs"],"content":"use crate::models::book::CreateBookWantedDto;\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_wanted_repository_test::{\n    create_test_book, create_test_user, setup_book_repository, setup_test_repository, setup_user_repository,\n};\nuse crate::repositories::test_helpers::get_test_mutex;\nuse crate::repositories::user_repository::UserRepository;\nuse uuid::Uuid;\n\n#[tokio::test]\nasync fn test_find_books_wanted() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_test123\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Cria um book_wanted\n    let book_wanted = CreateBookWantedDto {\n        book_id,\n        user_id: user.id,\n    };\n\n    books_wanted_repository.create(\u0026book_wanted).await.unwrap();\n\n    // Testa a busca do book_wanted\n    let result = books_wanted_repository.find(\u0026book_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"Falha ao buscar book_wanted: {:?}\", result.err());\n    \n    let found = result.unwrap();\n    assert!(found.is_some(), \"Book wanted não encontrado\");\n    \n    let found = found.unwrap();\n    assert_eq!(found.book_id, book_id);\n    assert_eq!(found.user_id, user.id);\n}\n\n#[tokio::test]\nasync fn test_find_books_wanted_nonexistent_book() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um usuário para o teste\n    let user = create_test_user();\n    let user = user_repository.create(\u0026user, \"senha_hash\".to_string()).await.unwrap();\n\n    // Testa busca com book_id inexistente\n    let non_existent_id = Uuid::new_v4();\n    let result = books_wanted_repository.find(\u0026non_existent_id, \u0026user.id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com ID inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_wanted com ID de livro inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_wanted_nonexistent_user() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria um livro para o teste\n    let book = create_test_book(\"find_nonexistent_user_test\");\n    let book_id = book_repository.create(\u0026book).await.unwrap();\n\n    // Testa busca com user_id inexistente\n    let non_existent_user_id = Uuid::new_v4();\n    let result = books_wanted_repository.find(\u0026book_id, \u0026non_existent_user_id).await;\n    \n    assert!(result.is_ok(), \"A busca deveria ser bem-sucedida mesmo com user_id inexistente\");\n    assert!(result.unwrap().is_none(), \"Não deveria encontrar book_wanted com user_id inexistente\");\n}\n\n#[tokio::test]\nasync fn test_find_books_wanted_multiple_entries() {\n    // Usa mutex para garantir execução sequencial dos testes\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    // Setup dos repositórios\n    let book_repository = setup_book_repository().await;\n    let user_repository = setup_user_repository().await;\n    let books_wanted_repository = setup_test_repository().await;\n\n    // Cria dois usuários para o teste\n    let user1 = create_test_user();\n    let user1 = user_repository.create(\u0026user1, \"senha_hash_1\".to_string()).await.unwrap();\n    \n    let user2 = create_test_user();\n    let user2 = user_repository.create(\u0026user2, \"senha_hash_2\".to_string()).await.unwrap();\n\n    // Cria dois livros para o teste\n    let book1 = create_test_book(\"find_multi_test1\");\n    let book1_id = book_repository.create(\u0026book1).await.unwrap();\n    \n    let book2 = create_test_book(\"find_multi_test2\");\n    let book2_id = book_repository.create(\u0026book2).await.unwrap();\n\n    // Cria várias relações de books_wanted\n    let book_wanted1 = CreateBookWantedDto {\n        book_id: book1_id,\n        user_id: user1.id,\n    };\n    \n    let book_wanted2 = CreateBookWantedDto {\n        book_id: book2_id,\n        user_id: user1.id,\n    };\n    \n    let book_wanted3 = CreateBookWantedDto {\n        book_id: book1_id,\n        user_id: user2.id,\n    };\n\n    // Insere as relações\n    books_wanted_repository.create(\u0026book_wanted1).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted2).await.unwrap();\n    books_wanted_repository.create(\u0026book_wanted3).await.unwrap();\n\n    // Teste 1: Usuário 1 oferece o Livro 1\n    let result1 = books_wanted_repository.find(\u0026book1_id, \u0026user1.id).await.unwrap();\n    assert!(result1.is_some(), \"Usuário 1 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 2: Usuário 1 oferece o Livro 2\n    let result2 = books_wanted_repository.find(\u0026book2_id, \u0026user1.id).await.unwrap();\n    assert!(result2.is_some(), \"Usuário 1 deveria ter o Livro 2 como oferecido\");\n    \n    // Teste 3: Usuário 2 oferece o Livro 1\n    let result3 = books_wanted_repository.find(\u0026book1_id, \u0026user2.id).await.unwrap();\n    assert!(result3.is_some(), \"Usuário 2 deveria ter o Livro 1 como oferecido\");\n    \n    // Teste 4: Usuário 2 NÃO oferece o Livro 2\n    let result4 = books_wanted_repository.find(\u0026book2_id, \u0026user2.id).await.unwrap();\n    assert!(result4.is_none(), \"Usuário 2 não deveria ter o Livro 2 como oferecido\");\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","books_wanted_repository_test","mod.rs"],"content":"pub mod create_books_wanted_test;\npub mod find_books_wanted_test;\npub mod delete_books_wanted_test;\n\nuse crate::models::book::GoogleBookDto;\nuse crate::models::user::CreateUserDto;\nuse crate::repositories::book_repository::{BookRepository, PgBookRepository};\nuse crate::repositories::books_wanted_repository::{BooksWantedRepository, PgBooksWantedRepository};\nuse crate::repositories::test_helpers::{get_test_db_pool, clean_database};\nuse crate::repositories::user_repository::{UserRepository, PgUserRepository};\nuse uuid::Uuid;\n\n// Cria uma função de setup de repositório para o PgBookRepository\npub async fn setup_book_repository() -\u003e impl BookRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBookRepository::new(pool)\n}\n\n// Cria uma função de setup de repositório para o PgUserRepository\npub async fn setup_user_repository() -\u003e impl UserRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgUserRepository::new(pool)\n}\n\n// Função para criar o repositório de books_wanted\npub async fn setup_test_repository() -\u003e impl BooksWantedRepository {\n    let pool = get_test_db_pool().await;\n    clean_database(\u0026pool).await;\n    PgBooksWantedRepository::new(pool)\n}\n\n// Função para criar um usuário de teste\npub fn create_test_user() -\u003e CreateUserDto {\n    CreateUserDto {\n        name: \"Test User\".to_string(),\n        email: format!(\"test_{}@example.com\", Uuid::new_v4()),\n        password: \"password\".to_string(),\n    }\n}\n\n// Função para criar um livro de teste\npub fn create_test_book(google_id: \u0026str) -\u003e GoogleBookDto {\n    GoogleBookDto {\n        google_id: google_id.to_string(),\n        title: \"Livro de Teste\".to_string(),\n        authors: Some(\"Autor Teste\".to_string()),\n        publisher: Some(\"Editora Teste\".to_string()),\n        published_date: Some(\"2022-05-10\".to_string()),\n        description: Some(\"Descrição de teste\".to_string()),\n        image_url: Some(\"http://example.com/image.jpg\".to_string()),\n        page_count: Some(200),\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","mod.rs"],"content":"pub mod book_repository;\npub mod user_repository;\npub mod books_offered_repository;\npub mod books_wanted_repository;\n#[cfg(test)]\npub mod user_repository_test;\n\n#[cfg(test)]\npub mod book_repository_test;\n\n#[cfg(test)]\npub mod books_offered_repository_test;\n\n#[cfg(test)]\npub mod books_wanted_repository_test;\n#[cfg(test)]\npub mod test_helpers {\n    use dotenv::dotenv;\n    use sqlx::PgPool;\n    use std::env;\n    use std::sync::Arc;\n    use tokio::sync::Mutex;\n\n    // Mutex para garantir que apenas um teste por vez acesse o banco\n    static TEST_MUTEX: tokio::sync::OnceCell\u003cArc\u003cMutex\u003c()\u003e\u003e\u003e = tokio::sync::OnceCell::const_new();\n\n    // Retorna um mutex para garantir a execução sequencial dos testes\n    pub async fn get_test_mutex() -\u003e Arc\u003cMutex\u003c()\u003e\u003e {\n        TEST_MUTEX\n            .get_or_init(|| async { Arc::new(Mutex::new(())) })\n            .await\n            .clone()\n    }\n\n    // Configura e retorna um pool de conexão com o banco de dados de teste\n    pub async fn get_test_db_pool() -\u003e PgPool {\n        // Carrega variáveis de ambiente\n        dotenv().ok();\n\n        // Usa as credenciais do banco de dados de teste\n        let db_user = env::var(\"POSTGRES_USER\").expect(\"POSTGRES_USER deve estar definido\");\n        let db_password =\n            env::var(\"POSTGRES_PASSWORD\").expect(\"POSTGRES_PASSWORD deve estar definido\");\n        let db_name = env::var(\"POSTGRES_TEST_DB\").expect(\"POSTGRES_TEST_DB deve estar definido\");\n        let db_port =\n            env::var(\"POSTGRES_TEST_PORT\").expect(\"POSTGRES_TEST_PORT deve estar definido\");\n\n        // Constrói a string de conexão para o banco de dados de teste\n        let connection_string = format!(\n            \"postgres://{}:{}@localhost:{}/{}\",\n            db_user, db_password, db_port, db_name\n        );\n\n        // Conecta ao banco de dados de teste\n        let pool = PgPool::connect(\u0026connection_string)\n            .await\n            .expect(\"Falha ao conectar ao banco de teste\");\n\n        clean_database(\u0026pool).await;\n\n        pool\n    }\n\n    // Limpa todas as tabelas do banco de teste para garantir um estado inicial conhecido\n    pub async fn clean_database(pool: \u0026PgPool) {\n        // Limpa todas as tabelas que possam afetar o teste\n        sqlx::query(\"TRUNCATE TABLE users CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela users\");\n\n        // Limpa outras tabelas relacionadas\n        sqlx::query(\"TRUNCATE TABLE books_wanted CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela books_wanted\");\n\n        sqlx::query(\"TRUNCATE TABLE books_offered CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela books_offered\");\n\n        sqlx::query(\"TRUNCATE TABLE trades CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela trades\");\n\n        sqlx::query(\"TRUNCATE TABLE books CASCADE\")\n            .execute(pool)\n            .await\n            .expect(\"Falha ao limpar a tabela books\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","user_repository.rs"],"content":"use async_trait::async_trait;\nuse sqlx::PgPool;\n\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, User};\n\n#[async_trait]\npub trait UserRepository: Send + Sync + 'static {\n    async fn create(\u0026self, user: \u0026CreateUserDto, hash_password: String) -\u003e Result\u003cUser, AppError\u003e;\n    async fn find_by_email(\u0026self, email: \u0026str) -\u003e Result\u003cOption\u003cUser\u003e, AppError\u003e;\n}\n\npub struct PgUserRepository {\n    pool: PgPool,\n}\n\nimpl PgUserRepository {\n    pub fn new(pool: PgPool) -\u003e Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl UserRepository for PgUserRepository {\n    async fn create(\u0026self, user: \u0026CreateUserDto, hash_password: String) -\u003e Result\u003cUser, AppError\u003e {\n        let result = sqlx::query_as::\u003c_, User\u003e(\n            \"INSERT INTO users (name, email, hash_password) VALUES ($1, $2, $3) RETURNING *\",\n        )\n        .bind(\u0026user.name)\n        .bind(\u0026user.email)\n        .bind(\u0026hash_password)\n        .fetch_one(\u0026self.pool)\n        .await\n        .map_err(|e| {\n            if e.to_string().contains(\"duplicate key\") {\n                AppError::ValidationError(\"Email já está em uso\".to_string())\n            } else {\n                AppError::DatabaseError(e.to_string())\n            }\n        })?;\n\n        Ok(result)\n    }\n\n    async fn find_by_email(\u0026self, email: \u0026str) -\u003e Result\u003cOption\u003cUser\u003e, AppError\u003e {\n        let result = sqlx::query_as::\u003c_, User\u003e(\"SELECT * FROM users WHERE email = $1\")\n            .bind(email)\n            .fetch_optional(\u0026self.pool)\n            .await\n            .map_err(AppError::from)?;\n\n        Ok(result)\n    }\n}\n","traces":[{"line":18,"address":[6910976],"length":1,"stats":{"Line":18}},{"line":25,"address":[6936279],"length":1,"stats":{"Line":32}},{"line":29,"address":[6809810],"length":1,"stats":{"Line":8}},{"line":30,"address":[6799078],"length":1,"stats":{"Line":8}},{"line":31,"address":[6825342],"length":1,"stats":{"Line":8}},{"line":33,"address":[6820024,6820308,6819548,6819970,6820080],"length":1,"stats":{"Line":31}},{"line":34,"address":[6738723,6738352],"length":1,"stats":{"Line":2}},{"line":35,"address":[3675929,3675595,3675648],"length":1,"stats":{"Line":6}},{"line":36,"address":[6821358],"length":1,"stats":{"Line":2}},{"line":38,"address":[6801455],"length":1,"stats":{"Line":0}},{"line":42,"address":[6800752],"length":1,"stats":{"Line":7}},{"line":45,"address":[6800672,6800809,6801779,6800707,6801213,6800964],"length":1,"stats":{"Line":28}},{"line":46,"address":[6821816,6822524,6822145,6821946,6821860,6822320],"length":1,"stats":{"Line":50}},{"line":47,"address":[6802023],"length":1,"stats":{"Line":8}},{"line":49,"address":[6801473,6801189,6801245,6800836,6801135],"length":1,"stats":{"Line":37}},{"line":50,"address":[6801708],"length":1,"stats":{"Line":0}},{"line":52,"address":[6739731],"length":1,"stats":{"Line":11}}],"covered":15,"coverable":17},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","repositories","user_repository_test.rs"],"content":"use crate::{\n    error::AppError,\n    models::user::CreateUserDto,\n    repositories::{\n        test_helpers::{get_test_db_pool, get_test_mutex},\n        user_repository::{PgUserRepository, UserRepository},\n    },\n};\nuse uuid::Uuid;\n\nasync fn setup_test_repository() -\u003e PgUserRepository {\n    // Obtém o pool de conexão com o banco de dados de teste\n    let pool = get_test_db_pool().await;\n    \n    // Criamos o DatabasePool com o pool real\n    PgUserRepository::new(pool)\n}\n\n#[tokio::test]\nasync fn test_create_user() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    let user = CreateUserDto {\n        name: \"Test User\".to_string(),\n        email: \"test@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n\n    // Hash simulado para testes\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    let created_user = user_repository\n        .create(\u0026user, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar usuário\");\n\n    assert_ne!(created_user.id, Uuid::nil());\n    assert_eq!(created_user.name, \"Test User\");\n    assert_eq!(created_user.email, \"test@example.com\");\n    assert_eq!(created_user.hash_password, hash_password);\n}\n\n#[tokio::test]\nasync fn test_find_by_email() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    // Cria um usuário para teste\n    let user = CreateUserDto {\n        name: \"Email Test\".to_string(),\n        email: \"find_by_email@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    // Insere o usuário no banco\n    let created_user = user_repository\n        .create(\u0026user, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar usuário\");\n\n    // Testa a busca por email com email existente\n    let found_user_opt = user_repository\n        .find_by_email(\"find_by_email@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(found_user_opt.is_some());\n\n    let found_user = found_user_opt.unwrap();\n    assert_eq!(found_user.id, created_user.id);\n    assert_eq!(found_user.email, \"find_by_email@example.com\");\n    assert_eq!(found_user.name, \"Email Test\");\n\n    // Testa a busca por email com email inexistente\n    let non_existent_result = user_repository\n        .find_by_email(\"nonexistent@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(non_existent_result.is_none());\n}\n\n#[tokio::test]\nasync fn test_email_exists() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    // Cria um usuário para teste\n    let user = CreateUserDto {\n        name: \"Email Exists Test\".to_string(),\n        email: \"email_exists@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    // Insere o usuário no banco\n    user_repository.create(\u0026user, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar usuário\");\n\n    // Verifica se email existe através de find_by_email para testar a funcionalidade\n    let found_user = user_repository\n        .find_by_email(\"email_exists@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(found_user.is_some());\n\n    // Verifica que email inexistente retorna None\n    let not_found = user_repository\n        .find_by_email(\"nonexistent@example.com\")\n        .await\n        .expect(\"Falha ao buscar usuário pelo email\");\n\n    assert!(not_found.is_none());\n}\n\n#[tokio::test]\nasync fn test_duplicate_email() {\n    let mutex = get_test_mutex().await;\n    let _lock = mutex.lock().await;\n\n    let user_repository = setup_test_repository().await;\n\n    // Cria um primeiro usuário\n    let user1 = CreateUserDto {\n        name: \"First User\".to_string(),\n        email: \"duplicate@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n    let hash_password = \"hashed_password_for_test\".to_string();\n\n    // Insere o primeiro usuário\n    user_repository.create(\u0026user1, hash_password.clone())\n        .await\n        .expect(\"Falha ao criar primeiro usuário\");\n\n    // Tenta criar um segundo usuário com o mesmo email\n    let user2 = CreateUserDto {\n        name: \"Second User\".to_string(),\n        email: \"duplicate@example.com\".to_string(),\n        password: \"different_password\".to_string(),\n    };\n\n    // Deve falhar com erro de validação\n    let result = user_repository.create(\u0026user2, \"another_hash\".to_string()).await;\n    assert!(result.is_err());\n\n    // Verifica se é o tipo de erro esperado\n    match result {\n        Err(AppError::ValidationError(_)) =\u003e (),\n        _ =\u003e panic!(\"Esperava erro de validação para email duplicado\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","auth_routes.rs"],"content":"use std::sync::Arc;\n\nuse axum::{routing::post, Router};\nuse sqlx::PgPool;\n\nuse crate::config::Config;\nuse crate::handlers::auth_handler::AuthHandler;\nuse crate::repositories::user_repository::PgUserRepository;\nuse crate::services::auth_service::AuthServiceImpl;\nuse crate::services::password_service::create_password_service;\n\npub fn auth_routes(pool: Arc\u003cPgPool\u003e) -\u003e Router {\n    let config = Config::from_env().expect(\"Falha ao carregar configuração\");\n\n    let user_repository = Arc::new(PgUserRepository::new(pool.as_ref().clone()));\n    let password_service = create_password_service();\n\n    let auth_service = Arc::new(AuthServiceImpl::new(\n        user_repository,\n        password_service,\n        config,\n    ));\n\n    let auth_handler = Arc::new(AuthHandler::new(auth_service));\n\n    let handler_clone = auth_handler.clone();\n\n    Router::new()\n        .route(\n            \"/api/auth/register\",\n            post(move |body| async move { handler_clone.register(body).await }),\n        )\n        .route(\n            \"/api/auth/login\",\n            post(move |body| async move { auth_handler.login(body).await }),\n        )\n}\n","traces":[{"line":12,"address":[7008805,7008689,7007472],"length":1,"stats":{"Line":9}},{"line":13,"address":[6934914,6934806],"length":1,"stats":{"Line":26}},{"line":15,"address":[7007653,7007720],"length":1,"stats":{"Line":28}},{"line":16,"address":[7007799,7007871],"length":1,"stats":{"Line":30}},{"line":18,"address":[6935300],"length":1,"stats":{"Line":19}},{"line":19,"address":[7000591],"length":1,"stats":{"Line":19}},{"line":21,"address":[6935215],"length":1,"stats":{"Line":11}},{"line":24,"address":[6998251],"length":1,"stats":{"Line":11}},{"line":26,"address":[7023660,7023590],"length":1,"stats":{"Line":30}},{"line":28,"address":[4236875,4237042,4236737],"length":1,"stats":{"Line":33}},{"line":31,"address":[7008285],"length":1,"stats":{"Line":63}},{"line":35,"address":[7361040,7361075,7360966,7361418,7360928],"length":1,"stats":{"Line":52}}],"covered":12,"coverable":12},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","book_offered_routes.rs"],"content":"use std::sync::Arc;\n\nuse axum::{\n    routing::{delete, post},\n    Router,\n};\nuse sqlx::PgPool;\n\nuse crate::{\n    handlers::book_offered_handler::BookOfferedHandler,\n    repositories::{\n        book_repository::PgBookRepository, \n        books_offered_repository::PgBooksOfferedRepository,\n        books_wanted_repository::PgBooksWantedRepository\n    },\n    routes::protect_routes,\n    services::{\n        book_offered_service::BookOfferedServiceImpl,\n        google_book_service::GoogleBookServiceImpl,\n        http_service::HttpServiceImpl,\n    },\n};\n\npub fn book_offered_routes(pool: Arc\u003cPgPool\u003e) -\u003e Router {\n    // Repositórios\n    let book_repository = Arc::new(PgBookRepository::new(pool.as_ref().clone()));\n    let books_offered_repository = Arc::new(PgBooksOfferedRepository::new(pool.as_ref().clone()));\n    let books_wanted_repository = Arc::new(PgBooksWantedRepository::new(pool.as_ref().clone()));\n    \n    // Serviço HTTP\n    let http_service = Arc::new(HttpServiceImpl::new());\n    \n    // Serviço do Google Books\n    let google_book_service = Arc::new(GoogleBookServiceImpl::new(http_service));\n    \n    // Serviço de Livros Oferecidos\n    let book_offered_service = Arc::new(BookOfferedServiceImpl::new(\n        book_repository,\n        books_offered_repository,\n        books_wanted_repository,\n        google_book_service,\n    ));\n\n    // Handler\n    let book_offered_handler = Arc::new(BookOfferedHandler::new(book_offered_service));\n    let handler_clone = book_offered_handler.clone();\n    let handler_clone2 = book_offered_handler.clone();\n\n    // Configurar rotas protegidas\n    protect_routes(\n        Router::new()\n            .route(\n                \"/api/books/offered\",\n                post(move |user_id, body| async move {\n                    handler_clone.add_book_to_offered(user_id, body).await\n                }),\n            )\n            .route(\n                \"/api/books/offered/:book_id\",\n                delete(move |user_id, path| async move {\n                    handler_clone2.remove_book_from_offered(user_id, path).await\n                }),\n            ),\n    )\n} ","traces":[{"line":24,"address":[7044944,7046616,7046757],"length":1,"stats":{"Line":15}},{"line":26,"address":[6982095,6982230],"length":1,"stats":{"Line":34}},{"line":27,"address":[7044323,7044247],"length":1,"stats":{"Line":34}},{"line":28,"address":[7045456,7045380],"length":1,"stats":{"Line":34}},{"line":31,"address":[7045603,7045541],"length":1,"stats":{"Line":29}},{"line":34,"address":[6982752],"length":1,"stats":{"Line":15}},{"line":37,"address":[6982867],"length":1,"stats":{"Line":16}},{"line":38,"address":[4204747],"length":1,"stats":{"Line":17}},{"line":39,"address":[7045715],"length":1,"stats":{"Line":16}},{"line":40,"address":[7070995],"length":1,"stats":{"Line":16}},{"line":45,"address":[6982965],"length":1,"stats":{"Line":16}},{"line":46,"address":[7055720,7055793],"length":1,"stats":{"Line":30}},{"line":47,"address":[6983121,6983188],"length":1,"stats":{"Line":29}},{"line":51,"address":[7048596,7048920,7048750],"length":1,"stats":{"Line":43}},{"line":53,"address":[7071405],"length":1,"stats":{"Line":14}},{"line":54,"address":[7055957],"length":1,"stats":{"Line":24}},{"line":55,"address":[6886739,6886600,6886935,6886676],"length":1,"stats":{"Line":6}},{"line":60,"address":[7045356],"length":1,"stats":{"Line":20}},{"line":61,"address":[3576704,3576484,3576539,3576440],"length":1,"stats":{"Line":3}}],"covered":19,"coverable":19},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","google_book_routes.rs"],"content":"use std::sync::Arc;\n\nuse axum::{routing::post, Router};\n\nuse crate::{\n    handlers::google_book_handler::GoogleBookHandler, routes::protect_routes,\n    services::google_book_service::GoogleBookServiceImpl, services::http_service::HttpServiceImpl,\n};\n\npub fn google_book_routes() -\u003e Router {\n    // Serviço HTTP\n    let http_service = Arc::new(HttpServiceImpl::new());\n\n    // Serviço do Google Books\n    let book_service = Arc::new(GoogleBookServiceImpl::new(http_service));\n\n    // Handler\n    let book_handler = Arc::new(GoogleBookHandler::new(book_service));\n    let handler_clone = book_handler.clone();\n\n    // Configurar rota protegida\n    protect_routes(Router::new().route(\n        \"/api/books/search\",\n        post(move |body| async move { handler_clone.search_books(body).await }),\n    ))\n}\n","traces":[{"line":10,"address":[6939694,6939666,6939152],"length":1,"stats":{"Line":11}},{"line":12,"address":[6877248],"length":1,"stats":{"Line":19}},{"line":15,"address":[6949984],"length":1,"stats":{"Line":14}},{"line":18,"address":[4702042],"length":1,"stats":{"Line":15}},{"line":19,"address":[6939361,6939294],"length":1,"stats":{"Line":34}},{"line":22,"address":[6950293,6950364,6950142],"length":1,"stats":{"Line":49}},{"line":23,"address":[6939431],"length":1,"stats":{"Line":19}},{"line":24,"address":[4702203],"length":1,"stats":{"Line":36}}],"covered":8,"coverable":8},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","routes","mod.rs"],"content":"pub mod auth_routes;\npub mod book_offered_routes;\npub mod google_book_routes;\n\nuse axum::{middleware::from_fn, Router};\n\nuse crate::middleware::auth_middleware::auth_middleware;\n\n/// Função auxiliar para aplicar o middleware de autenticação a qualquer rota\n///\n/// Esta função facilita a proteção de rotas, mantendo consistência na aplicação\n/// do middleware de autenticação em todo o projeto.\npub fn protect_routes(router: Router) -\u003e Router {\n    router.layer(from_fn(auth_middleware))\n}\n","traces":[{"line":13,"address":[6748209,6748064,6748238],"length":1,"stats":{"Line":19}},{"line":14,"address":[6748080,6748222],"length":1,"stats":{"Line":15}}],"covered":2,"coverable":2},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\nuse chrono::{Duration, Utc};\nuse jsonwebtoken::{encode, EncodingKey, Header};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\nuse crate::config::Config;\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, LoginUserDto, TokenResponse, UserResponse};\nuse crate::repositories::user_repository::UserRepository;\nuse crate::services::password_service::PasswordService;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct TokenClaims {\n    pub sub: String,\n    pub iat: usize,\n    pub exp: usize,\n}\n\n#[async_trait]\npub trait AuthService: Send + Sync + 'static {\n    async fn register(\u0026self, user_dto: CreateUserDto) -\u003e Result\u003cUserResponse, AppError\u003e;\n    async fn login(\u0026self, login_dto: LoginUserDto) -\u003e Result\u003cTokenResponse, AppError\u003e;\n}\n\npub struct AuthServiceImpl {\n    user_repository: Arc\u003cdyn UserRepository\u003e,\n    password_service: Arc\u003cdyn PasswordService\u003e,\n    config: Config,\n}\n\nimpl AuthServiceImpl {\n    pub fn new(\n        user_repository: Arc\u003cdyn UserRepository\u003e,\n        password_service: Arc\u003cdyn PasswordService\u003e,\n        config: Config,\n    ) -\u003e Self {\n        Self {\n            user_repository,\n            password_service,\n            config,\n        }\n    }\n\n    fn generate_token(\u0026self, user_id: \u0026Uuid) -\u003e Result\u003cString, AppError\u003e {\n        let now = Utc::now();\n        let iat = now.timestamp() as usize;\n        let exp = (now + Duration::hours(self.config.jwt_expires_in.parse::\u003ci64\u003e().unwrap()))\n            .timestamp() as usize;\n\n        let claims = TokenClaims {\n            sub: user_id.to_string(),\n            iat,\n            exp,\n        };\n\n        encode(\n            \u0026Header::default(),\n            \u0026claims,\n            \u0026EncodingKey::from_secret(self.config.jwt_secret.as_bytes()),\n        )\n        .map_err(|e| AppError::InternalServerError(format!(\"Erro ao gerar token: {}\", e)))\n    }\n}\n\n#[async_trait]\nimpl AuthService for AuthServiceImpl {\n    async fn register(\u0026self, user_dto: CreateUserDto) -\u003e Result\u003cUserResponse, AppError\u003e {\n        // Validar entrada usando as validações do DTO\n        user_dto.validate_all()?;\n\n        // Hash da senha usando o adapter\n        let hash_password = self.password_service.hash_password(\u0026user_dto.password)?;\n\n        // Criar usuário\n        let user = self\n            .user_repository\n            .create(\u0026user_dto, hash_password)\n            .await?;\n\n        Ok(UserResponse::from(user))\n    }\n\n    async fn login(\u0026self, login_dto: LoginUserDto) -\u003e Result\u003cTokenResponse, AppError\u003e {\n        // Validar entrada usando as validações do DTO\n        login_dto.validate_all()?;\n\n        // Buscar usuário pelo email\n        let user = self\n            .user_repository\n            .find_by_email(\u0026login_dto.email)\n            .await?\n            .ok_or_else(|| AppError::AuthError(\"Credenciais inválidas\".to_string()))?;\n\n        // Verificar senha usando o adapter\n        let is_valid = self\n            .password_service\n            .verify_password(\u0026login_dto.password, \u0026user.hash_password)?;\n        if !is_valid {\n            return Err(AppError::AuthError(\"Credenciais inválidas\".to_string()));\n        }\n\n        // Gerar token\n        let token = self.generate_token(\u0026user.id)?;\n\n        Ok(TokenResponse {\n            access_token: token,\n            token_type: \"Bearer\".to_string(),\n            user: UserResponse::from(user),\n        })\n    }\n}\n","traces":[{"line":35,"address":[7112976],"length":1,"stats":{"Line":18}},{"line":47,"address":[7092288,7093108],"length":1,"stats":{"Line":8}},{"line":48,"address":[7118555],"length":1,"stats":{"Line":8}},{"line":49,"address":[7093302],"length":1,"stats":{"Line":8}},{"line":50,"address":[4702790,4702643],"length":1,"stats":{"Line":16}},{"line":54,"address":[7118842],"length":1,"stats":{"Line":8}},{"line":60,"address":[7092693],"length":1,"stats":{"Line":8}},{"line":62,"address":[7096233,7096306],"length":1,"stats":{"Line":16}},{"line":64,"address":[7207930,7207744,7207766],"length":1,"stats":{"Line":0}},{"line":70,"address":[7031567],"length":1,"stats":{"Line":48}},{"line":72,"address":[7279427,7278741,7278579,7278658],"length":1,"stats":{"Line":26}},{"line":75,"address":[7214200,7214427,7214044,7214736],"length":1,"stats":{"Line":21}},{"line":78,"address":[7277763,7277286,7276843,7277096,7276562,7276776],"length":1,"stats":{"Line":40}},{"line":80,"address":[7276722],"length":1,"stats":{"Line":8}},{"line":81,"address":[6653380],"length":1,"stats":{"Line":32}},{"line":83,"address":[4250209,4250458],"length":1,"stats":{"Line":15}},{"line":86,"address":[7301553,7298333,7299105,7298523,7298128,7298175,7301453],"length":1,"stats":{"Line":37}},{"line":88,"address":[7278761,7279253,7278936,7278840],"length":1,"stats":{"Line":22}},{"line":91,"address":[7218100,7216979,7217459,7216733,7217696,7219543,7217272,7217050],"length":1,"stats":{"Line":47}},{"line":93,"address":[4251640],"length":1,"stats":{"Line":11}},{"line":94,"address":[6590116],"length":1,"stats":{"Line":33}},{"line":95,"address":[6662906,6662855],"length":1,"stats":{"Line":6}},{"line":98,"address":[7283103,7284197,7282703,7282977],"length":1,"stats":{"Line":21}},{"line":100,"address":[7218399,7218201],"length":1,"stats":{"Line":8}},{"line":101,"address":[7300377],"length":1,"stats":{"Line":10}},{"line":102,"address":[7280697,7280628],"length":1,"stats":{"Line":4}},{"line":106,"address":[7306125,7306944,7306273,7305923],"length":1,"stats":{"Line":16}},{"line":108,"address":[7291121],"length":1,"stats":{"Line":8}},{"line":109,"address":[7279986],"length":1,"stats":{"Line":8}},{"line":110,"address":[7300802],"length":1,"stats":{"Line":8}},{"line":111,"address":[7218962],"length":1,"stats":{"Line":8}}],"covered":30,"coverable":31},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service_test","login_tests.rs"],"content":"use super::*;\nuse crate::models::user::{LoginUserDto, User};\nuse crate::services::auth_service::AuthServiceImpl;\nuse mockall::predicate;\nuse std::sync::Arc;\n\n/// Testa o login com credenciais válidas\n///\n/// Verifica se:\n/// 1. O login é bem-sucedido com email e senha corretos\n/// 2. O token é gerado corretamente\n/// 3. Os dados do usuário são retornados corretamente\n#[tokio::test]\nasync fn success_with_valid_credentials() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n    let user_id = Uuid::new_v4();\n    let test_timestamp = create_test_timestamp();\n\n    // Mock para retornar um usuário quando buscado por email\n    mock_repo\n        .expect_find_by_email()\n        .with(predicate::eq(\"teste@example.com\"))\n        .returning(move |_| {\n            Ok(Some(User {\n                id: user_id,\n                name: \"Teste\".to_string(),\n                email: \"teste@example.com\".to_string(),\n                hash_password: \"hash_password\".to_string(),\n                created_at: test_timestamp,\n                updated_at: test_timestamp,\n            }))\n        });\n\n    // Criar mock do PasswordService configurado para retornar true (senha válida)\n    let mock_password_service = create_mock_password_service(\"hash_dummy\".to_string(), true);\n\n    // Criar serviço de autenticação com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Act\n    let login_dto = LoginUserDto {\n        email: \"teste@example.com\".to_string(),\n        password: \"senha123\".to_string(),\n    };\n\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(result.is_ok(), \"O login deveria ter sido bem-sucedido\");\n\n    if let Ok(token_response) = result {\n        assert_eq!(token_response.token_type, \"Bearer\");\n        assert!(!token_response.access_token.is_empty());\n        assert_eq!(token_response.user.name, \"Teste\");\n        assert_eq!(token_response.user.email, \"teste@example.com\");\n    }\n}\n\n/// Testa falhas de validação em campos obrigatórios durante o login\n///\n/// Este teste parametrizado verifica se o login falha apropriadamente quando:\n/// - O email está vazio\n/// - O email tem formato inválido\n/// - O email é muito longo\n/// - A senha está vazia\n///\n/// E valida que a mensagem de erro contém o texto esperado em cada caso.\n#[tokio::test]\nasync fn fail_with_invalid_fields() {\n    // Casos de teste parametrizados\n    let test_cases = vec![\n        InvalidFieldTestCase {\n            name: \"email vazio\",\n            field_name: \"email\",\n            user_name: \"\",  // não importa para login\n            user_email: \"\", // Email vazio\n            user_password: \"senha123\",\n            expected_message: \"O email não pode estar vazio\",\n        },\n        InvalidFieldTestCase {\n            name: \"formato de email inválido\",\n            field_name: \"email\",\n            user_name: \"\",                // não importa para login\n            user_email: \"email_invalido\", // Email com formato inválido\n            user_password: \"senha123\",\n            expected_message: \"Formato de email inválido\",\n        },\n        // Para o teste de email longo, vamos adicioná-lo diretamente no teste\n        // e não na lista de casos, para evitar problemas de lifetime\n    ];\n\n    // Executar testes para cada caso de validação\n    for test_case in test_cases {\n        // Arrange\n        let mock_repo = MockUserRepository::new();\n\n        // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n        let mock_password_service =\n            create_mock_password_service(\"hashed_password\".to_string(), true);\n\n        let auth_service = AuthServiceImpl::new(\n            Arc::new(mock_repo),\n            mock_password_service,\n            create_test_config(),\n        );\n\n        let login_dto = LoginUserDto {\n            email: test_case.user_email.to_string(),\n            password: test_case.user_password.to_string(),\n        };\n\n        // Act\n        let result = auth_service.login(login_dto).await;\n\n        // Assert\n        assert!(\n            result.is_err(),\n            \"O login deveria falhar com {} inválido/vazio\",\n            test_case.field_name\n        );\n\n        assert_validation_error_with_message(\n            \u0026result.unwrap_err(),\n            test_case.expected_message,\n            \u0026format!(\"Erro ao validar {}\", test_case.name),\n        );\n    }\n\n    // Teste específico para email longo\n    let mock_repo = MockUserRepository::new();\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Criar um email longo (acima do limite)\n    let long_email = \"A\".repeat(256);\n    let login_dto = LoginUserDto {\n        email: long_email,\n        password: \"senha123\".to_string(),\n    };\n\n    // Act\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O login deveria falhar com email muito longo\"\n    );\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"O email deve ter menos de 255 caracteres\",\n        \"Erro ao validar email muito longo\",\n    );\n\n    // Teste para senha vazia\n    let mock_repo = MockUserRepository::new();\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let login_dto = LoginUserDto {\n        email: \"teste@example.com\".to_string(),\n        password: \"\".to_string(),\n    };\n\n    // Act\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(result.is_err(), \"O login deveria falhar com senha vazia\");\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"A senha não pode estar vazia\",\n        \"Erro ao validar senha vazia\",\n    );\n}\n\n/// Testa o login com email inexistente\n///\n/// Verifica se:\n/// 1. O login falha quando o email não existe no banco\n/// 2. A mensagem de erro indica \"Credenciais inválidas\" (sem expor se o email existe ou não)\n#[tokio::test]\nasync fn fail_with_invalid_email() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Mock retorna None (usuário não encontrado)\n    mock_repo\n        .expect_find_by_email()\n        .with(predicate::eq(\"nao_existe@example.com\"))\n        .returning(|_| Ok(None));\n\n    // Criar mock do PasswordService (não importa a configuração, pois o email não existe)\n    let mock_password_service = create_mock_password_service(\"hash_dummy\".to_string(), true);\n\n    // Criar serviço de autenticação com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Act\n    let login_dto = LoginUserDto {\n        email: \"nao_existe@example.com\".to_string(),\n        password: \"senha123\".to_string(),\n    };\n\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(result.is_err(), \"O login deveria falhar com email inválido\");\n    assert_auth_error_with_message(\n        \u0026result.unwrap_err(),\n        \"Credenciais inválidas\",\n        \"Erro ao fazer login com email inválido\",\n    );\n}\n\n/// Testa o login com senha incorreta\n///\n/// Verifica se:\n/// 1. O login falha quando a senha está incorreta\n/// 2. A mensagem de erro indica \"Credenciais inválidas\" (sem especificar que a senha está errada)\n#[tokio::test]\nasync fn fail_with_invalid_password() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n    let user_id = Uuid::new_v4();\n    let test_timestamp = create_test_timestamp();\n\n    // Mock retorna um usuário (email existe)\n    mock_repo\n        .expect_find_by_email()\n        .with(predicate::eq(\"teste@example.com\"))\n        .returning(move |_| {\n            Ok(Some(User {\n                id: user_id,\n                name: \"Teste\".to_string(),\n                email: \"teste@example.com\".to_string(),\n                hash_password: \"hash_password\".to_string(),\n                created_at: test_timestamp,\n                updated_at: test_timestamp,\n            }))\n        });\n\n    // Criar mock do PasswordService configurado para retornar false (senha inválida)\n    let mock_password_service = create_mock_password_service(\"hash_dummy\".to_string(), false);\n\n    // Criar serviço de autenticação com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Act\n    let login_dto = LoginUserDto {\n        email: \"teste@example.com\".to_string(),\n        password: \"senha_incorreta\".to_string(),\n    };\n\n    let result = auth_service.login(login_dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O login deveria falhar com senha incorreta\"\n    );\n    assert_auth_error_with_message(\n        \u0026result.unwrap_err(),\n        \"Credenciais inválidas\",\n        \"Erro ao fazer login com senha incorreta\",\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service_test","mod.rs"],"content":"use async_trait::async_trait;\nuse chrono::DateTime;\nuse mockall::mock;\nuse std::sync::Arc;\nuse uuid::Uuid;\n\nuse crate::config::Config;\nuse crate::error::AppError;\nuse crate::models::user::{CreateUserDto, User};\nuse crate::repositories::user_repository::UserRepository;\nuse crate::services::auth_service::AuthService;\nuse crate::services::password_service::PasswordService;\n\n// Módulos de testes\npub mod login_tests;\npub mod register_tests;\n\n// ----- Mocks para os testes -----\n\n// Mock do UserRepository\nmock! {\n    pub UserRepository {}\n\n    #[async_trait]\n    impl UserRepository for UserRepository {\n        async fn create(\u0026self, user: \u0026CreateUserDto, hash_password: String) -\u003e Result\u003cUser, AppError\u003e;\n        async fn find_by_email(\u0026self, email: \u0026str) -\u003e Result\u003cOption\u003cUser\u003e, AppError\u003e;\n    }\n}\n\n// Mock do PasswordService\nmock! {\n    pub PasswordService {}\n\n    #[async_trait]\n    impl PasswordService for PasswordService {\n        fn hash_password(\u0026self, password: \u0026str) -\u003e Result\u003cString, AppError\u003e;\n        fn verify_password(\u0026self, password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, AppError\u003e;\n    }\n}\n\n// ----- Funções auxiliares para preparação de testes -----\n\n/// Cria uma configuração padrão para testes\npub fn create_test_config() -\u003e Config {\n    Config {\n        database_url: \"postgres://dummy\".to_string(),\n        jwt_secret: \"test_secret\".to_string(),\n        jwt_expires_in: \"1\".to_string(),\n        port: 8080,\n    }\n}\n\n/// Cria um timestamp fictício para testes\npub fn create_test_timestamp() -\u003e chrono::NaiveDateTime {\n    let timestamp = DateTime::from_timestamp(61, 0).unwrap();\n    timestamp.naive_utc()\n}\n\n/// Cria um usuário fictício para testes\npub fn create_test_user(name: \u0026str, email: \u0026str) -\u003e User {\n    User {\n        id: Uuid::new_v4(),\n        name: name.to_string(),\n        email: email.to_string(),\n        hash_password: \"hashed_password\".to_string(),\n        created_at: create_test_timestamp(),\n        updated_at: create_test_timestamp(),\n    }\n}\n\n/// Cria um DTO de usuário para testes\npub fn create_user_dto(name: \u0026str, email: \u0026str, password: \u0026str) -\u003e CreateUserDto {\n    CreateUserDto {\n        name: name.to_string(),\n        email: email.to_string(),\n        password: password.to_string(),\n    }\n}\n\n/// Cria um mock do PasswordService configurado para testes\npub fn create_mock_password_service(\n    hash_result: String,\n    verify_result: bool,\n) -\u003e Arc\u003cMockPasswordService\u003e {\n    let mut mock_service = MockPasswordService::new();\n\n    // Configure o comportamento do mock para hash_password\n    mock_service\n        .expect_hash_password()\n        .returning(move |_| Ok(hash_result.clone()));\n\n    // Configure o comportamento do mock para verify_password\n    mock_service\n        .expect_verify_password()\n        .returning(move |_, _| Ok(verify_result));\n\n    Arc::new(mock_service)\n}\n\n// Struct para facilitar parametrização de testes\npub struct InvalidFieldTestCase {\n    pub name: \u0026'static str,             // Nome do caso de teste\n    pub field_name: \u0026'static str,       // Nome do campo sendo testado\n    pub user_name: \u0026'static str,        // Valor para o campo nome\n    pub user_email: \u0026'static str,       // Valor para o campo email\n    pub user_password: \u0026'static str,    // Valor para o campo senha\n    pub expected_message: \u0026'static str, // Mensagem de erro esperada\n}\n\n// ----- Funções auxiliares para verificação de erros -----\n\n/// Verifica se o erro é do tipo esperado e contém a mensagem esperada\npub fn assert_error_with_message(\n    err: \u0026AppError,\n    error_type: \u0026str,\n    expected_message: \u0026str,\n    context: \u0026str,\n) {\n    match (err, error_type) {\n        (AppError::ValidationError(msg), \"ValidationError\") =\u003e {\n            assert!(\n                msg.contains(expected_message),\n                \"{}: Mensagem de erro inesperada: '{}', esperava que contivesse: '{}'\",\n                context,\n                msg,\n                expected_message\n            );\n        }\n        (AppError::AuthError(msg), \"AuthError\") =\u003e {\n            assert!(\n                msg.contains(expected_message),\n                \"{}: Mensagem de erro inesperada: '{}', esperava que contivesse: '{}'\",\n                context,\n                msg,\n                expected_message\n            );\n        }\n        (AppError::DatabaseError(msg), \"DatabaseError\") =\u003e {\n            assert!(\n                msg.contains(expected_message),\n                \"{}: Mensagem de erro inesperada: '{}', esperava que contivesse: '{}'\",\n                context,\n                msg,\n                expected_message\n            );\n        }\n        _ =\u003e panic!(\n            \"{}: Tipo de erro inesperado: {:?}, esperava {}\",\n            context, err, error_type\n        ),\n    }\n}\n\n/// Verifica se o erro é do tipo ValidationError e contém a mensagem esperada\npub fn assert_validation_error_with_message(err: \u0026AppError, expected_message: \u0026str, context: \u0026str) {\n    assert_error_with_message(err, \"ValidationError\", expected_message, context);\n}\n\n/// Verifica se o erro é do tipo AuthError e contém a mensagem esperada\npub fn assert_auth_error_with_message(err: \u0026AppError, expected_message: \u0026str, context: \u0026str) {\n    assert_error_with_message(err, \"AuthError\", expected_message, context);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","auth_service_test","register_tests.rs"],"content":"use super::*;\nuse crate::error::AppError;\nuse crate::services::auth_service::AuthServiceImpl;\nuse mockall::predicate;\nuse std::sync::Arc;\n\n/// Testa o registro de usuário com dados válidos\n///\n/// Verifica se:\n/// 1. O registro é bem-sucedido quando todos os campos são válidos\n/// 2. O objeto UserResponse retornado contém os dados corretos do usuário\n#[tokio::test]\nasync fn success_with_valid_data() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Configurar mock para retornar sucesso\n    mock_repo\n        .expect_create()\n        .with(\n            predicate::function(|user: \u0026CreateUserDto| {\n                user.name == \"Teste\"\n                    \u0026\u0026 user.email == \"teste@example.com\"\n                    \u0026\u0026 user.password.len() \u003e= 6\n            }),\n            predicate::always(),\n        )\n        .returning(|user, _| Ok(create_test_user(\u0026user.name, \u0026user.email)));\n\n    // Criar mock do PasswordService que retorna um hash fixo\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    // Criar o serviço com os mocks\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"teste@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(result.is_ok(), \"O registro deveria ter sido bem-sucedido\");\n\n    if let Ok(user_response) = result {\n        assert_eq!(user_response.name, \"Teste\");\n        assert_eq!(user_response.email, \"teste@example.com\");\n    }\n}\n\n/// Testa falhas de validação em campos obrigatórios durante o registro\n///\n/// Este teste parametrizado verifica se o registro falha apropriadamente quando:\n/// - O nome está vazio\n/// - O email está vazio\n/// - A senha está vazia\n///\n/// E valida que a mensagem de erro contém o texto esperado em cada caso.\n#[tokio::test]\nasync fn fail_with_invalid_fields() {\n    // Casos de teste parametrizados\n    let test_cases = vec![\n        InvalidFieldTestCase {\n            name: \"nome vazio\",\n            field_name: \"nome\",\n            user_name: \"\",\n            user_email: \"teste@example.com\",\n            user_password: \"senha123\",\n            expected_message: \"O nome não pode estar vazio\",\n        },\n        InvalidFieldTestCase {\n            name: \"email vazio\",\n            field_name: \"email\",\n            user_name: \"Teste\",\n            user_email: \"\",\n            user_password: \"senha123\",\n            expected_message: \"O email não pode estar vazio\",\n        },\n        InvalidFieldTestCase {\n            name: \"senha vazia\",\n            field_name: \"senha\",\n            user_name: \"Teste\",\n            user_email: \"teste@example.com\",\n            user_password: \"\",\n            expected_message: \"deve ter pelo menos 6\",\n        },\n    ];\n\n    // Executar testes para cada caso de validação\n    for test_case in test_cases {\n        // Arrange\n        let mock_repo = MockUserRepository::new();\n\n        // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n        let mock_password_service =\n            create_mock_password_service(\"hashed_password\".to_string(), true);\n\n        let auth_service = AuthServiceImpl::new(\n            Arc::new(mock_repo),\n            mock_password_service,\n            create_test_config(),\n        );\n\n        let dto = create_user_dto(\n            test_case.user_name,\n            test_case.user_email,\n            test_case.user_password,\n        );\n\n        // Act\n        let result = auth_service.register(dto).await;\n\n        // Assert\n        assert!(\n            result.is_err(),\n            \"O registro deveria falhar com {} vazio\",\n            test_case.field_name\n        );\n\n        assert_validation_error_with_message(\n            \u0026result.unwrap_err(),\n            test_case.expected_message,\n            \u0026format!(\"Erro ao validar {}\", test_case.name),\n        );\n    }\n}\n\n/// Testa o registro de usuário com senha muito curta (menos de 6 caracteres)\n///\n/// Verifica se:\n/// 1. O registro falha apropriadamente\n/// 2. A mensagem de erro indica que a senha precisa ter pelo menos 6 caracteres\n#[tokio::test]\nasync fn fail_with_short_password() {\n    // Arrange\n    let mock_repo = MockUserRepository::new();\n\n    // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"teste@example.com\", \"12345\"); // Menos de 6 caracteres\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(result.is_err(), \"O registro deveria falhar com senha curta\");\n\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"A senha deve ter pelo menos 6 caracteres\",\n        \"Erro ao validar tamanho mínimo da senha\",\n    );\n}\n\n/// Testa o registro de usuário com email já existente\n///\n/// Verifica se:\n/// 1. O registro falha quando o email já está em uso\n/// 2. A mensagem de erro indica especificamente que o email já está em uso\n#[tokio::test]\nasync fn fail_with_duplicate_email() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Simular erro de duplicação de email\n    mock_repo\n        .expect_create()\n        .with(predicate::always(), predicate::always())\n        .returning(|_, _| {\n            Err(AppError::ValidationError(\n                \"Email já está em uso\".to_string(),\n            ))\n        });\n\n    // Criar mock do PasswordService\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"email_existente@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O registro deveria falhar com email duplicado\"\n    );\n\n    assert_validation_error_with_message(\n        \u0026result.unwrap_err(),\n        \"Email já está em uso\",\n        \"Erro ao validar email duplicado\",\n    );\n}\n\n/// Testa o registro de usuário com nome muito longo\n///\n/// Verifica se:\n/// 1. O registro falha quando o nome é excessivamente longo\n/// 2. A mensagem de erro indica que o nome é muito longo\n#[tokio::test]\nasync fn fail_with_long_name() {\n    // Arrange\n    let mock_repo = MockUserRepository::new();\n\n    // Criar mock do PasswordService (não será usado devido à validação falhar antes)\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    // Criar um nome com 256 caracteres (acima do limite)\n    let long_name = \"A\".repeat(256);\n    let dto = create_user_dto(\u0026long_name, \"teste@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O registro deveria falhar com nome muito longo\"\n    );\n\n    assert_error_with_message(\n        \u0026result.unwrap_err(),\n        \"ValidationError\",\n        \"O nome deve ter menos de 255 caracteres\",\n        \"Erro ao validar nome com tamanho excessivo\",\n    );\n}\n\n/// Testa o comportamento quando o repositório retorna um erro de banco de dados\n///\n/// Verifica se:\n/// 1. O erro do repositório é propagado corretamente pelo serviço\n/// 2. A mensagem de erro é mantida intacta\n#[tokio::test]\nasync fn fail_with_database_error() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n\n    // Configurar mock para retornar um erro de banco de dados\n    mock_repo\n        .expect_create()\n        .with(predicate::always(), predicate::always())\n        .returning(|_, _| {\n            Err(AppError::DatabaseError(\n                \"Erro de conexão com o banco de dados\".to_string(),\n            ))\n        });\n\n    // Criar mock do PasswordService\n    let mock_password_service = create_mock_password_service(\"hashed_password\".to_string(), true);\n\n    let auth_service = AuthServiceImpl::new(\n        Arc::new(mock_repo),\n        mock_password_service,\n        create_test_config(),\n    );\n\n    let dto = create_user_dto(\"Teste\", \"teste@example.com\", \"senha123\");\n\n    // Act\n    let result = auth_service.register(dto).await;\n\n    // Assert\n    assert!(\n        result.is_err(),\n        \"O registro deveria falhar com erro de banco de dados\"\n    );\n\n    assert_error_with_message(\n        \u0026result.unwrap_err(),\n        \"DatabaseError\",\n        \"Erro de conexão com o banco de dados\",\n        \"Erro ao lidar com falha do repositório\",\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_offered_service.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookOffered, CreateBookOfferedDto};\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::services::google_book_service::GoogleBookService;\n\n#[async_trait]\npub trait BookOfferedService: Send + Sync + 'static {\n    async fn add_book_to_offered(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookOffered, AppError\u003e;\n    async fn remove_book_from_offered(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct BookOfferedServiceImpl {\n    book_repository: Arc\u003cdyn BookRepository\u003e,\n    books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n    books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n    google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n}\n\nimpl BookOfferedServiceImpl {\n    pub fn new(\n        book_repository: Arc\u003cdyn BookRepository\u003e,\n        books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n        books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n        google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n    ) -\u003e Self {\n        Self {\n            book_repository,\n            books_offered_repository,\n            books_wanted_repository,\n            google_book_service,\n        }\n    }\n}\n\n#[async_trait]\nimpl BookOfferedService for BookOfferedServiceImpl {\n    async fn add_book_to_offered(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookOffered, AppError\u003e {\n        // Variável para armazenar o UUID do banco de dados\n        let book_uuid: Uuid;\n        \n        // Verificar se o livro existe no banco de dados e obter seu ID interno\n        let existing_book = self.book_repository.find_by_google_id(google_id).await?;\n        \n        if let Some(book_with_id) = existing_book {\n            // Se o livro já existe, usar o ID existente\n            book_uuid = book_with_id.id;\n        } else {\n            // Livro não existe, precisa ser criado\n            // Buscar do Google Books API\n            let book_dto = self.google_book_service.find_book_by_id(google_id).await?;\n            \n            // Criar o livro no banco de dados\n            book_uuid = self.book_repository.create(\u0026book_dto).await?;\n        }\n        \n        // Verificar se o livro já está na lista de desejados do usuário\n        if let Some(_) = self.books_wanted_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de desejados\".to_string()));\n        }\n        \n        // Verificar se o livro já está na lista de possuídos do usuário\n        if let Some(_) = self.books_offered_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de possuídos\".to_string()));\n        }\n        \n        // Criar DTO para adicionar à lista de possuídos\n        let create_dto = CreateBookOfferedDto {\n            book_id: book_uuid,\n            user_id: *user_id,\n        };\n\n        // Adicionar à lista de livros possuídos\n        let book_offered = self.books_offered_repository.create(\u0026create_dto).await?;\n\n        Ok(book_offered)\n    }\n\n    async fn remove_book_from_offered(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        // Verificar se o livro existe na lista de possuídos do usuário\n        let exists = self.books_offered_repository.find(book_id, user_id).await?;\n        if exists.is_none() {\n            return Err(AppError::ValidationError(\n                \"Este livro não está na sua lista de possuídos\".to_string(),\n            ));\n        }\n\n        // Remover da lista de livros possuídos\n        self.books_offered_repository.delete(book_id, user_id).await\n    }\n} ","traces":[{"line":27,"address":[7420592],"length":1,"stats":{"Line":15}},{"line":44,"address":[7426183],"length":1,"stats":{"Line":9}},{"line":49,"address":[7609178,7608887,7608987,7610088,7609569,7608567],"length":1,"stats":{"Line":8}},{"line":51,"address":[7599830,7599718],"length":1,"stats":{"Line":6}},{"line":53,"address":[7599891],"length":1,"stats":{"Line":3}},{"line":57,"address":[7600311,7601021,7600121,7598780,7600733,7599941],"length":1,"stats":{"Line":7}},{"line":60,"address":[7610677,7608609,7611211,7610499,7610878],"length":1,"stats":{"Line":2}},{"line":64,"address":[7600056,7598822,7602414,7601670,7601488],"length":1,"stats":{"Line":8}},{"line":65,"address":[7601172,7601098],"length":1,"stats":{"Line":2}},{"line":69,"address":[7540259,7539929,7540119,7541082,7536683],"length":1,"stats":{"Line":8}},{"line":70,"address":[7601847,7602011],"length":1,"stats":{"Line":4}},{"line":76,"address":[7601904],"length":1,"stats":{"Line":3}},{"line":80,"address":[7603118,7603695,7602928,7603247,7598864,7603843],"length":1,"stats":{"Line":8}},{"line":82,"address":[7541423],"length":1,"stats":{"Line":3}},{"line":85,"address":[7338966],"length":1,"stats":{"Line":6}},{"line":87,"address":[6596383],"length":1,"stats":{"Line":3}},{"line":88,"address":[4287210,4287118],"length":1,"stats":{"Line":4}},{"line":89,"address":[4287406],"length":1,"stats":{"Line":2}},{"line":90,"address":[7605129],"length":1,"stats":{"Line":2}},{"line":95,"address":[6669090],"length":1,"stats":{"Line":5}}],"covered":20,"coverable":20},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","book_wanted_service.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\nuse uuid::Uuid;\n\nuse crate::error::AppError;\nuse crate::models::book::{BookWanted, CreateBookWantedDto};\nuse crate::repositories::book_repository::BookRepository;\nuse crate::repositories::books_wanted_repository::BooksWantedRepository;\nuse crate::repositories::books_offered_repository::BooksOfferedRepository;\nuse crate::services::google_book_service::GoogleBookService;\n\n#[async_trait]\npub trait BookWantedService: Send + Sync + 'static {\n    async fn add_book_to_wanted(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookWanted, AppError\u003e;\n    async fn remove_book_from_wanted(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e;\n}\n\npub struct BookWantedServiceImpl {\n    book_repository: Arc\u003cdyn BookRepository\u003e,\n    books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n    books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n    google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n}\n\nimpl BookWantedServiceImpl {\n    pub fn new(\n        book_repository: Arc\u003cdyn BookRepository\u003e,\n        books_wanted_repository: Arc\u003cdyn BooksWantedRepository\u003e,\n        books_offered_repository: Arc\u003cdyn BooksOfferedRepository\u003e,\n        google_book_service: Arc\u003cdyn GoogleBookService\u003e,\n    ) -\u003e Self {\n        Self {\n            book_repository,\n            books_wanted_repository,\n            books_offered_repository,\n            google_book_service,\n        }\n    }\n}\n\n#[async_trait]\nimpl BookWantedService for BookWantedServiceImpl {\n    async fn add_book_to_wanted(\u0026self, google_id: \u0026str, user_id: \u0026Uuid) -\u003e Result\u003cBookWanted, AppError\u003e {\n        // Variável para armazenar o UUID do banco de dados\n        let book_uuid: Uuid;\n        \n        // Verificar se o livro existe no banco de dados e obter seu ID interno\n        let existing_book = self.book_repository.find_by_google_id(google_id).await?;\n        \n        if let Some(book_with_id) = existing_book {\n            // Se o livro já existe, usar o ID existente\n            book_uuid = book_with_id.id;\n        } else {\n            // Livro não existe, precisa ser criado\n            // Buscar do Google Books API\n            let book_dto = self.google_book_service.find_book_by_id(google_id).await?;\n            \n            // Criar o livro no banco de dados\n            book_uuid = self.book_repository.create(\u0026book_dto).await?;\n        }\n        \n        // Verificar se o livro já está na lista de desejados do usuário\n        if let Some(_) = self.books_wanted_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de desejados\".to_string()));\n        }\n        \n        // Verificar se o livro já está na lista de possuídos do usuário\n        if let Some(_) = self.books_offered_repository.find(\u0026book_uuid, user_id).await? {\n            return Err(AppError::ValidationError(\"Este livro já está na sua lista de possuídos\".to_string()));\n        }\n        \n        // Criar DTO para adicionar à lista de desejados\n        let create_dto = CreateBookWantedDto {\n            book_id: book_uuid,\n            user_id: *user_id,\n        };\n\n        // Adicionar à lista de livros desejados\n        let book_wanted = self.books_wanted_repository.create(\u0026create_dto).await?;\n\n        Ok(book_wanted)\n    }\n\n    async fn remove_book_from_wanted(\u0026self, book_id: \u0026Uuid, user_id: \u0026Uuid) -\u003e Result\u003cbool, AppError\u003e {\n        // Verificar se o livro existe na lista de desejados do usuário\n        let exists = self.books_wanted_repository.find(book_id, user_id).await?;\n        if exists.is_none() {\n            return Err(AppError::ValidationError(\n                \"Este livro não está na sua lista de desejados\".to_string(),\n            ));\n        }\n\n        // Remover da lista de livros desejados\n        self.books_wanted_repository.delete(book_id, user_id).await\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service.rs"],"content":"use crate::error::AppError;\nuse crate::models::book::GoogleBookDto;\nuse crate::services::http_service::HttpService;\nuse serde_json::Value;\nuse std::sync::Arc;\n\npub trait GoogleBookService: Send + Sync {\n    fn search_books\u003c'a\u003e(\n        \u0026'a self,\n        query: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cVec\u003cGoogleBookDto\u003e, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e;\n\n    fn find_book_by_id\u003c'a\u003e(\n        \u0026'a self,\n        google_id: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cGoogleBookDto, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e;\n}\n\npub struct GoogleBookServiceImpl {\n    http_service: Arc\u003cdyn HttpService\u003e,\n}\n\nimpl GoogleBookServiceImpl {\n    pub fn new(http_service: Arc\u003cdyn HttpService\u003e) -\u003e Self {\n        Self { http_service }\n    }\n\n    // Função auxiliar para converter JSON em GoogleBookDto\n    fn convert_to_google_book_dto(\u0026self, item: \u0026Value) -\u003e GoogleBookDto {\n        let google_id = item[\"id\"].as_str().unwrap_or_default().to_string();\n        let volume_info = \u0026item[\"volumeInfo\"];\n\n        // Extrair informações\n        let title = volume_info[\"title\"].as_str();\n        let title = title.unwrap_or_default().to_string();\n\n        // Processar autores\n        let authors = match volume_info[\"authors\"].as_array() {\n            Some(authors_array) =\u003e {\n                let mut authors_vec: Vec\u003cString\u003e = Vec::new();\n                for author in authors_array {\n                    if let Some(author_str) = author.as_str() {\n                        authors_vec.push(author_str.to_string());\n                    }\n                }\n                Some(authors_vec.join(\", \"))\n            }\n            None =\u003e None,\n        };\n\n        let publisher = volume_info[\"publisher\"].as_str().map(|s| s.to_string());\n\n        let published_date = match volume_info[\"publishedDate\"].as_str() {\n            Some(date_str) =\u003e Some(date_str.to_string()),\n            None =\u003e None,\n        };\n\n        let description = volume_info[\"description\"].as_str().map(|s| s.to_string());\n        let page_count = volume_info[\"pageCount\"].as_i64().map(|n| n as i32);\n\n        let image_url = match volume_info.get(\"imageLinks\") {\n            Some(image_links) =\u003e match image_links.get(\"thumbnail\") {\n                Some(thumbnail) =\u003e thumbnail.as_str().map(|s| s.to_string()),\n                None =\u003e None,\n            },\n            None =\u003e None,\n        };\n\n        GoogleBookDto {\n            google_id,\n            title,\n            authors,\n            publisher,\n            published_date,\n            description,\n            image_url,\n            page_count,\n        }\n    }\n}\n\nimpl GoogleBookService for GoogleBookServiceImpl {\n    fn search_books\u003c'a\u003e(\n        \u0026'a self,\n        query: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cVec\u003cGoogleBookDto\u003e, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e {\n        Box::pin(async move {\n            let mut url = String::from(\"https://www.googleapis.com/books/v1/volumes?q=\");\n            url.push_str(\u0026query);\n            url.push_str(\"\u0026fields=items(id,volumeInfo(title,authors,publisher,publishedDate,description,pageCount,imageLinks/thumbnail))\");\n\n            let data = self.http_service.get(\u0026url).await?;\n\n            let items = match data.get(\"items\") {\n                Some(items) =\u003e items,\n                None =\u003e return Ok(vec![]),\n            };\n\n            let mut books = Vec::new();\n\n            if let Some(items_array) = items.as_array() {\n                for item in items_array {\n                    let book = self.convert_to_google_book_dto(item);\n                    books.push(book);\n                }\n            }\n\n            Ok(books)\n        })\n    }\n\n    fn find_book_by_id\u003c'a\u003e(\n        \u0026'a self,\n        google_id: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003c\n        Box\u003cdyn std::future::Future\u003cOutput = Result\u003cGoogleBookDto, AppError\u003e\u003e + Send + 'a\u003e,\n    \u003e {\n        Box::pin(async move {\n            let mut url = String::from(\"https://www.googleapis.com/books/v1/volumes/\");\n            url.push_str(\u0026google_id);\n            url.push_str(\"?fields=id,volumeInfo(title,authors,publisher,publishedDate,description,pageCount,imageLinks/thumbnail)\");\n\n            let data = match self.http_service.get(\u0026url).await {\n                Ok(data) =\u003e data,\n                Err(AppError::NotFoundError(_)) =\u003e {\n                    let message = format!(\"Livro com ID {} não encontrado\", google_id);\n                    return Err(AppError::NotFoundError(message));\n                }\n                Err(e) =\u003e return Err(e),\n            };\n\n            // Converter dados em GoogleBookDto\n            let book = self.convert_to_google_book_dto(\u0026data);\n            Ok(book)\n        })\n    }\n}\n","traces":[{"line":28,"address":[7204368],"length":1,"stats":{"Line":19}},{"line":33,"address":[7271931,7271767,7269072],"length":1,"stats":{"Line":5}},{"line":34,"address":[7286442],"length":1,"stats":{"Line":5}},{"line":35,"address":[7265757,7265840],"length":1,"stats":{"Line":10}},{"line":38,"address":[7269320],"length":1,"stats":{"Line":5}},{"line":39,"address":[7276721],"length":1,"stats":{"Line":5}},{"line":42,"address":[7286897,7286807],"length":1,"stats":{"Line":10}},{"line":43,"address":[7267157],"length":1,"stats":{"Line":5}},{"line":44,"address":[5044020],"length":1,"stats":{"Line":5}},{"line":45,"address":[7205097,7205307,7205184],"length":1,"stats":{"Line":15}},{"line":46,"address":[5044318,5046087],"length":1,"stats":{"Line":10}},{"line":47,"address":[7294625],"length":1,"stats":{"Line":5}},{"line":50,"address":[7205369,7205272],"length":1,"stats":{"Line":10}},{"line":52,"address":[7204977],"length":1,"stats":{"Line":1}},{"line":55,"address":[5044502,5044047],"length":1,"stats":{"Line":20}},{"line":57,"address":[7270327,7270243],"length":1,"stats":{"Line":10}},{"line":58,"address":[7277813,7277719],"length":1,"stats":{"Line":10}},{"line":59,"address":[7266931],"length":1,"stats":{"Line":3}},{"line":62,"address":[7421136,7421158],"length":1,"stats":{"Line":20}},{"line":63,"address":[5044987,5045067],"length":1,"stats":{"Line":20}},{"line":65,"address":[7206178],"length":1,"stats":{"Line":5}},{"line":66,"address":[7278934,7278236],"length":1,"stats":{"Line":10}},{"line":67,"address":[7411392,7411414],"length":1,"stats":{"Line":15}},{"line":68,"address":[7278971],"length":1,"stats":{"Line":0}},{"line":70,"address":[7278216],"length":1,"stats":{"Line":3}},{"line":87,"address":[7268480],"length":1,"stats":{"Line":6}},{"line":93,"address":[4675625,4675271,4675135,4676802,4675088,4675228],"length":1,"stats":{"Line":18}},{"line":94,"address":[7421357],"length":1,"stats":{"Line":6}},{"line":95,"address":[4675318],"length":1,"stats":{"Line":6}},{"line":96,"address":[4675392],"length":1,"stats":{"Line":6}},{"line":98,"address":[7411415,7412251,7410815,7410650,7411057],"length":1,"stats":{"Line":12}},{"line":100,"address":[7350179,7350333],"length":1,"stats":{"Line":10}},{"line":101,"address":[7432373],"length":1,"stats":{"Line":5}},{"line":102,"address":[7411570,7411629],"length":1,"stats":{"Line":4}},{"line":105,"address":[7432394],"length":1,"stats":{"Line":5}},{"line":107,"address":[7432572,7432507],"length":1,"stats":{"Line":10}},{"line":108,"address":[7411970,7411841],"length":1,"stats":{"Line":10}},{"line":109,"address":[7412070],"length":1,"stats":{"Line":5}},{"line":110,"address":[4676661],"length":1,"stats":{"Line":5}},{"line":114,"address":[7432646],"length":1,"stats":{"Line":5}},{"line":118,"address":[7269632],"length":1,"stats":{"Line":2}},{"line":124,"address":[7268694],"length":1,"stats":{"Line":6}},{"line":125,"address":[4676901],"length":1,"stats":{"Line":2}},{"line":126,"address":[7438685],"length":1,"stats":{"Line":2}},{"line":127,"address":[4677089],"length":1,"stats":{"Line":2}},{"line":129,"address":[6655796],"length":1,"stats":{"Line":8}},{"line":130,"address":[4677629],"length":1,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[7414340,7414568],"length":1,"stats":{"Line":4}},{"line":133,"address":[7439953],"length":1,"stats":{"Line":2}},{"line":135,"address":[7413407],"length":1,"stats":{"Line":1}},{"line":139,"address":[7351961],"length":1,"stats":{"Line":1}},{"line":140,"address":[7352085],"length":1,"stats":{"Line":1}}],"covered":51,"coverable":53},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service_test","find_book_by_id_tests.rs"],"content":"use crate::services::google_book_service::{GoogleBookService, GoogleBookServiceImpl};\nuse crate::services::http_service::{HttpService, HttpServiceImpl};\nuse std::sync::Arc;\nuse crate::error::AppError;\nuse serde_json::json;\n\n// Implementação para mock do HttpService\nstruct MockHttpService {\n    response: Option\u003cserde_json::Value\u003e,\n    error: Option\u003cAppError\u003e,\n}\n\nimpl MockHttpService {\n    fn new_success(response: serde_json::Value) -\u003e Self {\n        Self {\n            response: Some(response),\n            error: None,\n        }\n    }\n\n    fn new_error(error: AppError) -\u003e Self {\n        Self {\n            response: None,\n            error: Some(error),\n        }\n    }\n}\n\nimpl HttpService for MockHttpService {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        _url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cserde_json::Value, AppError\u003e\u003e + Send + 'a\u003e\u003e {\n        let response = self.response.clone();\n        let error = self.error.clone();\n\n        Box::pin(async move {\n            match (response, error) {\n                (Some(resp), _) =\u003e Ok(resp),\n                (_, Some(err)) =\u003e Err(err),\n                _ =\u003e Err(AppError::InternalServerError(\"Nenhuma resposta ou erro configurado\".to_string())),\n            }\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn find_book_by_id_test() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // ID de um livro bem conhecido\n        let book_id = \"YyXoAAAACAAJ\"; // Clean Code de Robert Martin\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca de livro por ID deveria ser bem-sucedida\");\n\n        let book = result.unwrap();\n        assert_eq!(book.google_id, book_id, \"O ID do livro deve corresponder ao solicitado\");\n        assert!(!book.title.is_empty(), \"O título não deve estar vazio\");\n    }\n\n    #[tokio::test]\n    async fn test_find_book_by_id_invalid_id() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // ID inválido que não deve existir\n        let book_id = \"invalid_id_12345678900987654321\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"A busca com ID inválido deve falhar\");\n    }\n\n    #[tokio::test]\n    async fn test_find_book_by_id_empty_id() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        let book_id = \"\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"A busca com ID vazio deve falhar\");\n    }\n\n    #[tokio::test]\n    async fn test_find_book_by_id_real_book_details() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // ID de um livro específico da O'Reilly sobre Rust\n        let book_id = \"0weDoAEACAAJ\"; // \"Programming Rust\" de Jim Blandy\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca por ID válido deve ser bem-sucedida\");\n\n        let book = result.unwrap();\n        assert_eq!(book.google_id, book_id);\n        \n        // Validações de campos obrigatórios\n        assert!(!book.title.is_empty(), \"Título deve estar presente\");\n        \n        // Verificação de campos opcionais com conteúdo esperado\n        if let Some(authors) = book.authors {\n            assert!(!authors.is_empty(), \"Lista de autores não deve estar vazia quando presente\");\n        }\n        \n        if let Some(description) = book.description {\n            assert!(!description.is_empty(), \"Descrição não deve estar vazia quando presente\");\n        }\n        \n        if let Some(image_url) = book.image_url {\n            assert!(image_url.starts_with(\"http\"), \"URL da imagem deve ser válida\");\n        }\n    }\n\n    // Teste usando mock para simular erro 404 (NotFoundError)\n    #[tokio::test]\n    async fn test_find_book_by_id_not_found_error() {\n        // Arrange\n        // Criar um mock do HttpService que retorna erro NotFoundError\n        let mock_http_service = Arc::new(MockHttpService::new_error(\n            AppError::NotFoundError(\"Recurso não encontrado\".to_string())\n        ));\n        \n        let service = GoogleBookServiceImpl::new(mock_http_service);\n        let book_id = \"test_not_found_id\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"Deve falhar quando o livro não é encontrado\");\n        \n        match result {\n            Err(AppError::NotFoundError(msg)) =\u003e {\n                assert!(msg.contains(\"não encontrado\"), \"Mensagem deve informar que o livro não foi encontrado\");\n                assert!(msg.contains(book_id), \"Mensagem deve conter o ID do livro\");\n            },\n            _ =\u003e panic!(\"Deveria retornar um NotFoundError\")\n        }\n    }\n\n    // Teste usando mock para simular erro interno (InternalServerError)\n    #[tokio::test]\n    async fn test_find_book_by_id_internal_error() {\n        // Arrange\n        // Criar um mock do HttpService que retorna erro interno\n        let mock_http_service = Arc::new(MockHttpService::new_error(\n            AppError::InternalServerError(\"Erro interno na requisição HTTP\".to_string())\n        ));\n        \n        let service = GoogleBookServiceImpl::new(mock_http_service);\n        let book_id = \"test_error_id\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        assert!(result.is_err(), \"Deve falhar quando ocorre um erro interno\");\n        \n        match result {\n            Err(AppError::InternalServerError(msg)) =\u003e {\n                assert!(msg.contains(\"Erro interno\"), \"Mensagem deve informar sobre o erro interno\");\n            },\n            _ =\u003e panic!(\"Deveria propagar o InternalServerError\")\n        }\n    }\n\n    // Teste usando mock para simular resposta vazia ou inválida\n    #[tokio::test]\n    async fn test_find_book_by_id_empty_response() {\n        // Arrange\n        // Criar um mock que retorna objeto vazio com apenas ID\n        let mock_http_service = Arc::new(MockHttpService::new_success(json!({\n            \"id\": \"test_empty_response_id\",\n            // Sem volumeInfo ou outros campos necessários\n        })));\n        \n        let service = GoogleBookServiceImpl::new(mock_http_service);\n        let book_id = \"test_empty_response_id\";\n\n        // Act\n        let result = service.find_book_by_id(book_id).await;\n\n        // Assert\n        // A chamada deve ter sucesso, mas o livro retornado deve ter apenas o ID\n        assert!(result.is_ok(), \"Deve retornar um objeto mesmo com dados mínimos\");\n        \n        let book = result.unwrap();\n        assert_eq!(book.google_id, book_id, \"ID do livro deve corresponder\");\n        assert_eq!(book.title, \"\", \"Título deve estar vazio\");\n        assert_eq!(book.authors, None, \"Autores devem ser None\");\n        assert_eq!(book.description, None, \"Descrição deve ser None\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service_test","mod.rs"],"content":"pub mod find_book_by_id_tests;\npub mod search_books_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","google_book_service_test","search_books_tests.rs"],"content":"use crate::services::google_book_service::{GoogleBookService, GoogleBookServiceImpl};\nuse crate::services::http_service::HttpServiceImpl;\nuse std::sync::Arc;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_search_books_real_api() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        let query = \"Rust Programming Language\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca de livros deveria ser bem-sucedida\");\n\n        let books = result.unwrap();\n        assert!(\n            !books.is_empty(),\n            \"A busca deveria retornar pelo menos um livro\"\n        );\n\n        // Verificar estrutura dos dados retornados no primeiro livro\n        let first_book = \u0026books[0];\n        assert!(\n            !first_book.google_id.is_empty(),\n            \"O ID do Google não deve estar vazio\"\n        );\n        assert!(\n            !first_book.title.is_empty(),\n            \"O título não deve estar vazio\"\n        );\n\n        // Verificamos se os campos opcionais possuem estrutura adequada quando presentes\n        if let Some(authors) = \u0026first_book.authors {\n            assert!(\n                !authors.is_empty(),\n                \"Autores não devem estar vazios quando presentes\"\n            );\n        }\n\n        if let Some(image_url) = \u0026first_book.image_url {\n            assert!(\n                image_url.starts_with(\"http\"),\n                \"URL da imagem deve ser uma URL válida quando presente\"\n            );\n        }\n\n        if let Some(page_count) = first_book.page_count {\n            assert!(\n                page_count \u003e 0,\n                \"Contagem de páginas deve ser positiva quando presente\"\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_books_with_specific_author() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        let query = \"author:Martin Fowler\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca por autor deveria ser bem-sucedida\");\n\n        let books = result.unwrap();\n        if !books.is_empty() {\n            // Se houver resultados, verificar se o autor está presente em pelo menos um livro\n            let author_found = books.iter().any(|book| {\n                if let Some(authors) = \u0026book.authors {\n                    authors.contains(\"Fowler\")\n                } else {\n                    false\n                }\n            });\n\n            assert!(\n                author_found,\n                \"Pelo menos um livro deveria conter o autor buscado\"\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_books_with_nonexistent_title() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // Uma string improvável de corresponder a um título real\n        let query = \"título extremamente improvável de existir 9283749232874\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(\n            result.is_ok(),\n            \"A busca por título inexistente deve ser processada sem erro\"\n        );\n\n        let books = result.unwrap();\n        assert!(\n            books.is_empty(),\n            \"A busca por título inexistente deve retornar lista vazia\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_search_books_response_structure() {\n        // Arrange\n        let http_service = Arc::new(HttpServiceImpl::new());\n        let service = GoogleBookServiceImpl::new(http_service);\n        // Um livro bem conhecido que deve ter todos os campos preenchidos\n        let query = \"title:Clean Code Robert Martin\";\n\n        // Act\n        let result = service.search_books(query).await;\n\n        // Assert\n        assert!(result.is_ok(), \"A busca deveria ser bem-sucedida\");\n\n        let books = result.unwrap();\n        if !books.is_empty() {\n            let book = \u0026books[0];\n\n            // Verificamos a estrutura completa do objeto retornado\n            assert!(\n                !book.google_id.is_empty(),\n                \"ID do Google deve estar preenchido\"\n            );\n            assert!(!book.title.is_empty(), \"Título deve estar preenchido\");\n\n            // Campos opcionais devem ter estrutura válida se presentes\n            if let Some(publisher) = \u0026book.publisher {\n                assert!(\n                    !publisher.is_empty(),\n                    \"Editora não deve estar vazia quando presente\"\n                );\n            }\n\n            if let Some(published_date) = \u0026book.published_date {\n                assert!(\n                    !published_date.is_empty(),\n                    \"Data de publicação não deve estar vazia quando presente\"\n                );\n            }\n\n            if let Some(description) = \u0026book.description {\n                assert!(\n                    !description.is_empty(),\n                    \"Descrição não deve estar vazia quando presente\"\n                );\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","http_service.rs"],"content":"use crate::error::AppError;\nuse reqwest::Client;\nuse serde_json::Value;\n\npub trait HttpService: Send + Sync {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cValue, AppError\u003e\u003e + Send + 'a\u003e\u003e;\n}\n\npub struct HttpServiceImpl {\n    client: Client,\n}\n\nimpl HttpServiceImpl {\n    pub fn new() -\u003e Self {\n        Self {\n            client: Client::new(),\n        }\n    }\n}\n\nimpl HttpService for HttpServiceImpl {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cValue, AppError\u003e\u003e + Send + 'a\u003e\u003e\n    {\n        Box::pin(async move {\n            let response = self.client.get(url).send().await.map_err(|e| {\n                AppError::InternalServerError(format!(\"Erro na requisição HTTP: {}\", e))\n            })?;\n\n            let status = response.status();\n            if !status.is_success() {\n                let message = format!(\"Erro na requisição: Status {}\", status);\n                return Err(AppError::NotFoundError(message));\n            }\n\n            let data: Value = response.json().await.map_err(|e| {\n                AppError::InternalServerError(format!(\"Erro ao processar resposta: {}\", e))\n            })?;\n\n            Ok(data)\n        })\n    }\n}\n","traces":[{"line":17,"address":[6950544],"length":1,"stats":{"Line":12}},{"line":19,"address":[6939777],"length":1,"stats":{"Line":20}},{"line":25,"address":[6950560],"length":1,"stats":{"Line":6}},{"line":30,"address":[6877903],"length":1,"stats":{"Line":18}},{"line":31,"address":[6842048,6842185,6843167,6843776,6841964,6841893,6844020,6842588],"length":1,"stats":{"Line":18}},{"line":32,"address":[6905718,6905783,6905882],"length":1,"stats":{"Line":0}},{"line":35,"address":[6904597,6904443],"length":1,"stats":{"Line":10}},{"line":36,"address":[6905560],"length":1,"stats":{"Line":5}},{"line":37,"address":[6842810,6842710],"length":1,"stats":{"Line":4}},{"line":38,"address":[6908323],"length":1,"stats":{"Line":2}},{"line":41,"address":[6842738,6844292,6843717,6843084,6841982,6843192,6844048,6843638],"length":1,"stats":{"Line":15}},{"line":42,"address":[6907114,6907015,6906950],"length":1,"stats":{"Line":0}},{"line":45,"address":[6843519],"length":1,"stats":{"Line":5}}],"covered":11,"coverable":13},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","http_service_test","get.rs"],"content":"use serde_json::json;\nuse crate::error::AppError;\nuse crate::services::http_service::{HttpService, HttpServiceImpl};\n\n// Implementação simples de HttpService para testes\nstruct TestHttpService {\n    response: Option\u003cserde_json::Value\u003e,\n    error: Option\u003cAppError\u003e,\n    expected_url: String,\n}\n\nimpl TestHttpService {\n    fn new_success(url: \u0026str, response: serde_json::Value) -\u003e Self {\n        Self {\n            response: Some(response),\n            error: None,\n            expected_url: url.to_string(),\n        }\n    }\n\n    fn new_error(url: \u0026str, error: AppError) -\u003e Self {\n        Self {\n            response: None,\n            error: Some(error),\n            expected_url: url.to_string(),\n        }\n    }\n}\n\nimpl HttpService for TestHttpService {\n    fn get\u003c'a\u003e(\n        \u0026'a self,\n        url: \u0026'a str,\n    ) -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cserde_json::Value, AppError\u003e\u003e + Send + 'a\u003e\u003e {\n        let response = self.response.clone();\n        let error = self.error.clone();\n        let expected_url = self.expected_url.clone();\n\n        Box::pin(async move {\n            // Verifica se a URL é a esperada\n            assert_eq!(url, expected_url, \"URL não corresponde à esperada\");\n\n            // Retorna o resultado configurado\n            match (response, error) {\n                (Some(resp), _) =\u003e Ok(resp),\n                (_, Some(err)) =\u003e Err(err),\n                _ =\u003e Err(AppError::InternalServerError(\"Nenhuma resposta ou erro configurado\".to_string())),\n            }\n        })\n    }\n}\n\n// Teste para simular erro na requisição HTTP\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_http_request_error() {\n    // Criar serviço de teste que simula um erro de conexão\n    let service = TestHttpService::new_error(\n        \"https://example.com/test\",\n        AppError::InternalServerError(\"Erro na requisição HTTP: falha de conexão\".to_string())\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/test\").await;\n    \n    // Verificar que retornou o erro interno esperado\n    assert!(result.is_err());\n    match result {\n        Err(AppError::InternalServerError(msg)) =\u003e {\n            assert!(msg.contains(\"Erro na requisição HTTP\"));\n        }\n        _ =\u003e panic!(\"Deveria ser um erro InternalServerError\"),\n    }\n}\n\n// Teste para simular erro de status HTTP (404)\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_http_status_error() {\n    // Criar serviço de teste que simula um erro 404\n    let service = TestHttpService::new_error(\n        \"https://example.com/not-found\",\n        AppError::NotFoundError(\"Erro na requisição: Status 404\".to_string())\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/not-found\").await;\n    \n    // Verificar que retornou o erro NotFound esperado\n    assert!(result.is_err());\n    match result {\n        Err(AppError::NotFoundError(msg)) =\u003e {\n            assert!(msg.contains(\"Status 404\"));\n        }\n        _ =\u003e panic!(\"Deveria ser um erro NotFoundError\"),\n    }\n}\n\n// Teste para simular JSON inválido\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_invalid_json_response() {\n    // Criar serviço de teste que simula um erro de JSON inválido\n    let service = TestHttpService::new_error(\n        \"https://example.com/invalid-json\",\n        AppError::InternalServerError(\"Erro ao processar resposta: JSON inválido\".to_string())\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/invalid-json\").await;\n    \n    // Verificar que retornou o erro de processamento esperado\n    assert!(result.is_err());\n    match result {\n        Err(AppError::InternalServerError(msg)) =\u003e {\n            assert!(msg.contains(\"Erro ao processar resposta\"));\n        }\n        _ =\u003e panic!(\"Deveria ser um erro InternalServerError\"),\n    }\n}\n\n// Teste para resposta bem-sucedida\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_successful_response() {\n    // Criar serviço de teste que simula uma resposta bem-sucedida\n    let service = TestHttpService::new_success(\n        \"https://example.com/success\",\n        json!({\"test\": \"success\"})\n    );\n    \n    // Realizar a requisição\n    let result = service.get(\"https://example.com/success\").await;\n    \n    // Verificar que retornou o resultado esperado\n    assert!(result.is_ok());\n    let data = result.unwrap();\n    assert_eq!(data[\"test\"], json!(\"success\"));\n}\n\n// Teste de integração com o HttpServiceImpl real\n#[tokio::test(flavor = \"current_thread\")]\nasync fn test_real_http_service() {\n    // Criamos uma instância real do HttpService\n    let http_service = HttpServiceImpl::new();\n    \n    // Fazemos uma requisição para uma API pública conhecida\n    let result = http_service.get(\"https://jsonplaceholder.typicode.com/todos/1\").await;\n    \n    // Verificamos se a requisição foi bem-sucedida\n    assert!(result.is_ok());\n    \n    // Verificamos se a resposta contém campos esperados\n    let data = result.unwrap();\n    assert!(data.get(\"id\").is_some());\n    assert!(data.get(\"title\").is_some());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","http_service_test","mod.rs"],"content":"pub mod get;","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","mod.rs"],"content":"pub mod auth_service;\npub mod book_offered_service;\npub mod book_wanted_service;\npub mod google_book_service;\npub mod http_service;\npub mod password_service;\n\n#[cfg(test)]\npub mod auth_service_test;\n\n#[cfg(test)]\npub mod book_offered_wanted_service_test;\n\n#[cfg(test)]\npub mod google_book_service_test;\n\n#[cfg(test)]\npub mod http_service_test;\n\n#[cfg(test)]\npub mod password_service_test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","password_service.rs"],"content":"use async_trait::async_trait;\nuse std::sync::Arc;\n\nuse argon2::{\n    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},\n    Argon2,\n};\n\nuse crate::error::AppError;\n\n/// Interface para serviços de gerenciamento de senha\n///\n/// Esta interface define operações para hash e verificação de senhas,\n/// permitindo desacoplar o AuthService da implementação específica (Argon2)\n#[async_trait]\npub trait PasswordService: Send + Sync + 'static {\n    /// Gera um hash para uma senha\n    fn hash_password(\u0026self, password: \u0026str) -\u003e Result\u003cString, AppError\u003e;\n\n    /// Verifica se uma senha corresponde a um hash\n    fn verify_password(\u0026self, password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, AppError\u003e;\n}\n\n/// Implementação do PasswordService usando Argon2\npub struct Argon2PasswordService;\n\nimpl Argon2PasswordService {\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n}\n\n#[async_trait]\nimpl PasswordService for Argon2PasswordService {\n    fn hash_password(\u0026self, password: \u0026str) -\u003e Result\u003cString, AppError\u003e {\n        let salt = SaltString::generate(\u0026mut OsRng);\n        let argon2 = Argon2::default();\n\n        argon2\n            .hash_password(password.as_bytes(), \u0026salt)\n            .map(|hash| hash.to_string())\n            .map_err(|e| AppError::InternalServerError(format!(\"Erro ao gerar hash: {}\", e)))\n    }\n\n    fn verify_password(\u0026self, password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, AppError\u003e {\n        let parsed_hash = PasswordHash::new(hash)\n            .map_err(|e| AppError::InternalServerError(format!(\"Erro ao analisar hash: {}\", e)))?;\n\n        Ok(Argon2::default()\n            .verify_password(password.as_bytes(), \u0026parsed_hash)\n            .is_ok())\n    }\n}\n\n/// Factory para criar instâncias do PasswordService\n///\n/// Permite flexibilidade para mudar a implementação no futuro\npub fn create_password_service() -\u003e Arc\u003cdyn PasswordService\u003e {\n    Arc::new(Argon2PasswordService::new())\n}\n","traces":[{"line":35,"address":[6627200],"length":1,"stats":{"Line":11}},{"line":36,"address":[6566050],"length":1,"stats":{"Line":10}},{"line":37,"address":[6630741],"length":1,"stats":{"Line":11}},{"line":39,"address":[6628268],"length":1,"stats":{"Line":10}},{"line":41,"address":[7141484,7141472],"length":1,"stats":{"Line":18}},{"line":42,"address":[7141637,7141504,7141520],"length":1,"stats":{"Line":0}},{"line":45,"address":[6653616],"length":1,"stats":{"Line":8}},{"line":46,"address":[6653722,6654049],"length":1,"stats":{"Line":12}},{"line":47,"address":[7131664,7131797,7131680],"length":1,"stats":{"Line":4}},{"line":49,"address":[6638418],"length":1,"stats":{"Line":8}},{"line":58,"address":[6653392],"length":1,"stats":{"Line":18}},{"line":59,"address":[6565969],"length":1,"stats":{"Line":10}}],"covered":11,"coverable":12},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","src","services","password_service_test.rs"],"content":"use crate::error::AppError;\nuse crate::services::password_service::{\n    create_password_service, Argon2PasswordService, PasswordService,\n};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_hash_password_success() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n\n        // Act\n        let result = service.hash_password(password);\n\n        // Assert\n        assert!(\n            result.is_ok(),\n            \"O hash da senha deveria ser gerado com sucesso\"\n        );\n        let hash = result.unwrap();\n        assert!(!hash.is_empty(), \"O hash não deve ser vazio\");\n        assert!(\n            hash.contains(\"$argon2\"),\n            \"O hash deve usar o formato Argon2\"\n        );\n    }\n\n    #[test]\n    fn test_verify_password_success() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n\n        // Primeiro, gerar um hash da senha\n        let hash = service.hash_password(password).unwrap();\n\n        // Act\n        let result = service.verify_password(password, \u0026hash);\n\n        // Assert\n        assert!(result.is_ok(), \"A verificação deveria ser bem-sucedida\");\n        assert!(\n            result.unwrap(),\n            \"A senha correta deveria ser verificada como válida\"\n        );\n    }\n\n    #[test]\n    fn test_verify_password_with_wrong_password() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let correct_password = \"senha123\";\n        let wrong_password = \"senha456\";\n\n        // Primeiro, gerar um hash da senha correta\n        let hash = service.hash_password(correct_password).unwrap();\n\n        // Act\n        let result = service.verify_password(wrong_password, \u0026hash);\n\n        // Assert\n        assert!(\n            result.is_ok(),\n            \"A verificação deveria ser processada sem erros\"\n        );\n        assert!(\n            !result.unwrap(),\n            \"A senha incorreta deveria ser verificada como inválida\"\n        );\n    }\n\n    #[test]\n    fn test_verify_password_with_invalid_hash() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n        let invalid_hash = \"hash_invalido\";\n\n        // Act\n        let result = service.verify_password(password, invalid_hash);\n\n        // Assert\n        assert!(\n            result.is_err(),\n            \"A verificação deveria falhar com hash inválido\"\n        );\n        let error = result.unwrap_err();\n        match error {\n            AppError::InternalServerError(msg) =\u003e {\n                assert!(\n                    msg.contains(\"Erro ao analisar hash\"),\n                    \"A mensagem de erro deveria indicar problema na análise do hash\"\n                );\n            }\n            _ =\u003e panic!(\"Tipo de erro inesperado: {:?}\", error),\n        }\n    }\n\n    #[test]\n    fn test_create_password_service() {\n        // Act\n        let _service = create_password_service();\n\n        // Assert\n        // Verificamos se a função factory retorna corretamente um serviço\n        // A verificação é implícita, pois se não retornasse um PasswordService,\n        // o código não compilaria\n        assert!(true, \"O serviço foi criado com sucesso\");\n    }\n\n    #[test]\n    fn test_hashed_passwords_are_different() {\n        // Arrange\n        let service = Argon2PasswordService::new();\n        let password = \"senha123\";\n\n        // Act\n        let hash1 = service.hash_password(password).unwrap();\n        let hash2 = service.hash_password(password).unwrap();\n\n        // Assert\n        assert_ne!(\n            hash1, hash2,\n            \"Hashes da mesma senha devem ser diferentes (salt diferente)\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","add_book_offered_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_add_book_to_offered() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Primeiro, vamos buscar um livro para obter um ID válido\n    let search_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de busca\");\n\n    let search_body: Value = search_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de busca\");\n\n    let books = search_body[\"data\"].as_array().unwrap();\n    assert!(!books.is_empty(), \"A busca deve retornar pelo menos um livro\");\n\n    let google_id = books[0][\"google_id\"].as_str().unwrap();\n\n    // Act - Adicionar o livro à lista de possuídos\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para adicionar livro\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::CREATED);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(\n        body[\"message\"],\n        \"Livro adicionado à lista de possuídos com sucesso\"\n    );\n    assert!(body[\"data\"][\"book_id\"].is_string());\n    assert!(body[\"data\"][\"user_id\"].is_string());\n\n    // Tentar adicionar o mesmo livro novamente deve falhar\n    let duplicate_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição duplicada\");\n\n    let duplicate_status = duplicate_response.status();\n    let duplicate_body: Value = duplicate_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta duplicada\");\n\n    assert_eq!(duplicate_status, StatusCode::BAD_REQUEST);\n    assert_eq!(duplicate_body[\"error\"][\"status\"], 400);\n    assert!(duplicate_body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"já está na sua lista de possuídos\"));\n}\n\n#[tokio::test]\nasync fn test_add_book_to_offered_invalid_google_id() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Tentar adicionar um livro com ID inválido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": \"id_que_nao_existe_12345\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - A requisição deve falhar pois o Google Books API não encontrará o livro\n    let status = response.status();\n    assert_eq!(status, StatusCode::NOT_FOUND);\n}\n\n#[tokio::test]\nasync fn test_add_book_to_offered_without_authentication() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Tentar adicionar um livro sem autenticação\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .json(\u0026json!({\n            \"google_id\": \"qualquerid\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - A requisição deve falhar por falta de autenticação\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token de autenticação ausente\"));\n}\n\n// Teste para verificar erro ao tentar adicionar livro que já está na lista de desejados\n#[tokio::test]\n#[ignore = \"Requer implementação da rota de livros desejados\"]\nasync fn test_add_book_to_offered_already_in_wanted() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Primeiro, vamos buscar um livro para obter um ID válido\n    let search_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de busca\");\n\n    let search_body: Value = search_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de busca\");\n\n    let books = search_body[\"data\"].as_array().unwrap();\n    assert!(!books.is_empty(), \"A busca deve retornar pelo menos um livro\");\n\n    let google_id = books[0][\"google_id\"].as_str().unwrap();\n\n    // Nota: Este teste está marcado como ignorado (#[ignore]) porque requer a implementação\n    // da rota de livros desejados primeiro. Quando essa rota for implementada, podemos \n    // adicionar o livro à lista de desejados usando uma requisição HTTP normal.\n\n    // Adicionar à lista de desejados (isso depende da implementação da rota /api/books/wanted)\n    let wanted_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/wanted\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await;\n\n    // Se a rota não estiver disponível, ignorar o teste\n    if wanted_response.is_err() {\n        println!(\"A rota de livros desejados não está disponível. Ignorando teste.\");\n        return;\n    }\n\n    // Garantir que o livro foi adicionado à lista de desejados\n    assert_eq!(wanted_response.unwrap().status(), StatusCode::CREATED);\n\n    // Act - Tentar adicionar o mesmo livro à lista de oferecidos\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para adicionar livro à lista de oferecidos\");\n\n    // Assert - Verificar que a requisição falhou com o erro esperado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"já está na sua lista de desejados\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","auth_login_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::setup_test_app;\nuse reqwest::StatusCode;\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_login_success() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Criar email único para evitar conflitos\n    let email = format!(\"login_test_{}@example.com\", chrono::Utc::now().timestamp());\n    let password = \"senha123\";\n\n    // Registrar um usuário primeiro\n    let register_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Login\",\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de registro\");\n\n    assert_eq!(register_response.status(), StatusCode::CREATED);\n\n    // Act - Fazer login com usuário criado\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de login\");\n\n    // Assert\n    let status = login_response.status();\n    let body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(body[\"message\"], \"Login realizado com sucesso\");\n\n    // Verificar se retornou um token e os dados do usuário\n    assert!(body[\"data\"][\"access_token\"].is_string());\n    assert_eq!(body[\"data\"][\"token_type\"], \"Bearer\");\n    assert_eq!(body[\"data\"][\"user\"][\"email\"], email);\n}\n\n#[tokio::test]\nasync fn test_login_invalid_credentials() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Criar email único para evitar conflitos\n    let email = format!(\n        \"invalid_login_{}@example.com\",\n        chrono::Utc::now().timestamp()\n    );\n\n    // Registrar um usuário primeiro\n    let register_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário para Teste de Login Inválido\",\n            \"email\": email,\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de registro\");\n\n    assert_eq!(register_response.status(), StatusCode::CREATED);\n\n    // Act - Fazer login com senha incorreta\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": \"senha_incorreta\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de login\");\n\n    // Assert\n    let status = login_response.status();\n    let body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Credenciais inválidas\"));\n}\n\n#[tokio::test]\nasync fn test_login_nonexistent_user() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Email que provavelmente não existe\n    let email = format!(\"nonexistent_{}@example.com\", chrono::Utc::now().timestamp());\n\n    // Act - Fazer login com usuário inexistente\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": \"qualquer_senha\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de login\");\n\n    // Assert\n    let status = login_response.status();\n    let body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Credenciais inválidas\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","auth_register_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::setup_test_app;\nuse reqwest::StatusCode;\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_register_user_success() {\n    // Arrange - Configurar o aplicativo de teste\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Gerar um email único para evitar conflitos\n    let email = format!(\"test_user_{}@example.com\", chrono::Utc::now().timestamp());\n\n    // Act - Enviar requisição para registrar um usuário\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Teste\",\n            \"email\": email,\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::CREATED);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(body[\"message\"], \"Usuário registrado com sucesso\");\n    assert!(body[\"data\"][\"id\"].is_string());\n    assert_eq!(body[\"data\"][\"name\"], \"Usuário de Teste\");\n    assert_eq!(body[\"data\"][\"email\"], email);\n}\n\n#[tokio::test]\nasync fn test_register_user_invalid_email() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar requisição com email inválido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Teste\",\n            \"email\": \"email_invalido\",\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Formato de email inválido\"));\n}\n\n#[tokio::test]\nasync fn test_register_user_password_too_short() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar requisição com senha muito curta\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Usuário de Teste\",\n            \"email\": \"usuario@example.com\",\n            \"password\": \"12345\"  // Menos de 6 caracteres\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"A senha deve ter\"));\n}\n\n#[tokio::test]\nasync fn test_register_user_duplicate_email() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Email que será duplicado\n    let email = format!(\"duplicate_{}@example.com\", chrono::Utc::now().timestamp());\n\n    // Primeiro registro (deve ter sucesso)\n    let _ = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Primeiro Usuário\",\n            \"email\": email,\n            \"password\": \"senha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar primeira requisição\");\n\n    // Act - Tentar registrar com o mesmo email\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": \"Segundo Usuário\",\n            \"email\": email,\n            \"password\": \"outrasenha123\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar segunda requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Email já está em uso\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","books_search_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_search_books_success() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar livros com um termo de busca válido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Rust Programming\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(body[\"message\"], \"Livros encontrados com sucesso\");\n    assert!(body[\"data\"].is_array());\n\n    // Verificar se há pelo menos um livro na resposta\n    let data = body[\"data\"].as_array().unwrap();\n    if !data.is_empty() {\n        let first_book = \u0026data[0];\n\n        // Verificar se os campos obrigatórios existem\n        assert!(first_book[\"google_id\"].is_string());\n        assert!(first_book[\"title\"].is_string());\n\n        // Verificar se os campos têm valores adequados\n        assert!(!first_book[\"google_id\"].as_str().unwrap().is_empty());\n        assert!(!first_book[\"title\"].as_str().unwrap().is_empty());\n    }\n}\n\n#[tokio::test]\nasync fn test_search_books_without_authentication() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar livros sem fornecer token de autenticação\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar que a requisição falhou por falta de autenticação\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token de autenticação ausente\"));\n}\n\n#[tokio::test]\nasync fn test_search_books_with_invalid_token() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Token inválido\n    let invalid_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjk5OTk5OTk5OTl9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n\n    // Act - Buscar livros com token inválido\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", invalid_token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert - Verificar que a requisição falhou por token inválido\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_search_books_empty_query() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar uma consulta vazia\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::BAD_REQUEST);\n    assert_eq!(body[\"error\"][\"status\"], 400);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"não pode estar vazia\"));\n}\n\n#[tokio::test]\nasync fn test_search_books_specific_book() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar um livro específico com termos mais específicos\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code: A Handbook of Agile Software Craftsmanship Robert Martin\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n\n    let data = body[\"data\"].as_array().unwrap();\n\n    // Verificar se os resultados são relevantes - não exigimos match exato, pois a API pode retornar resultados diferentes\n    let is_relevant = data.iter().any(|book| {\n        let title = book[\"title\"].as_str().unwrap_or(\"\");\n        let authors = book[\"authors\"].as_str().unwrap_or(\"\");\n\n        // Considerar relevante se contiver partes do título ou nome do autor\n        title.contains(\"Clean\")\n            || title.contains(\"Code\")\n            || authors.contains(\"Martin\")\n            || authors.contains(\"Robert\")\n    });\n\n    assert!(\n        is_relevant,\n        \"Deveria encontrar livros relacionados a 'Clean Code' ou 'Robert Martin'\"\n    );\n}\n\n#[tokio::test]\nasync fn test_search_books_nonexistent_title() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar um título improvável de existir\n    let unique_query = format!(\"TítuloMuitoImprovável{}\", chrono::Utc::now().timestamp());\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": unique_query\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n\n    // O array de dados deve estar vazio ou ter poucos resultados\n    let data = body[\"data\"].as_array().unwrap();\n    assert!(\n        data.len() \u003c 2,\n        \"Não deveria encontrar muitos livros com um título improvável\"\n    );\n}\n\n#[tokio::test]\nasync fn test_search_books_with_author_filter() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Buscar livros de um autor específico\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"author:Martin Fowler\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n\n    let data = body[\"data\"].as_array().unwrap();\n    if !data.is_empty() {\n        // Verificar se os livros retornados são do autor pesquisado\n        let author_found = data.iter().any(|book| {\n            if let Some(authors) = book[\"authors\"].as_str() {\n                authors.contains(\"Fowler\") || authors.contains(\"Martin\")\n            } else {\n                false\n            }\n        });\n\n        assert!(\n            author_found,\n            \"Deveria encontrar pelo menos um livro do autor Martin Fowler\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","common","mod.rs"],"content":"pub mod test_utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","common","test_utils.rs"],"content":"use reqwest::Client;\nuse serde_json::{json, Value};\nuse std::net::TcpListener;\nuse troca_livros_api::app;\nuse uuid::Uuid;\n\npub struct TestApp {\n    pub port: u16,\n}\n\n/// Configura um aplicativo de teste com um banco de dados de teste\n///\n/// Esta função:\n/// 1. Cria uma conexão com o banco de dados de teste\n/// 2. Configura o servidor Axum\n/// 3. Inicia o servidor em uma porta aleatória\n/// 4. Retorna o objeto TestApp com informações para os testes\npub async fn setup_test_app() -\u003e TestApp {\n    // Carregar variáveis de ambiente\n    dotenv::dotenv().ok();\n\n    // Configurar logging para testes\n    let _ = tracing_subscriber::fmt()\n        .with_test_writer()\n        .with_env_filter(\"info\")\n        .try_init();\n\n    // Obter a URL do banco de dados de teste a partir da variável de ambiente\n    let test_db_url =\n        std::env::var(\"TEST_DATABASE_URL\").expect(\"TEST_DATABASE_URL não está definida\");\n\n    // Encontrar uma porta disponível\n    let listener = TcpListener::bind(\"127.0.0.1:0\").expect(\"Falha ao vincular a porta aleatória\");\n    let port = listener.local_addr().unwrap().port();\n\n    // Configurar rotas sem Swagger UI (não necessário para testes)\n    let created_app = app::create_app(\u0026test_db_url).await;\n\n    // Iniciar o servidor em uma nova thread\n    let server = axum::Server::from_tcp(listener)\n        .expect(\"Falha ao criar servidor a partir do listener\")\n        .serve(created_app.into_make_service());\n\n    tokio::spawn(server);\n\n    TestApp { port }\n}\n\n/// Cria um usuário de teste e retorna o token de autenticação\n///\n/// Esta função:\n/// 1. Registra um novo usuário (se necessário)\n/// 2. Faz login para obter o token JWT\n/// 3. Retorna o token para ser usado em requisições autenticadas\n#[allow(dead_code)]\npub async fn get_auth_token(app: \u0026TestApp) -\u003e String {\n    let client = Client::new();\n\n    // Criar credenciais únicas usando UUID para garantir unicidade absoluta\n    // mesmo quando chamado no mesmo milissegundo\n    let uuid = Uuid::new_v4().to_string();\n    let email = format!(\"auth_test_{}@example.com\", uuid);\n    let password = \"Senha@123\";\n    let name = format!(\"Usuário de Teste {}\", uuid);\n\n    // Registrar usuário\n    let register_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/register\", app.port))\n        .json(\u0026json!({\n            \"name\": name,\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao registrar usuário de teste\");\n\n    assert_eq!(register_response.status(), reqwest::StatusCode::CREATED);\n\n    // Fazer login\n    let login_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/auth/login\", app.port))\n        .json(\u0026json!({\n            \"email\": email,\n            \"password\": password\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao autenticar usuário de teste\");\n\n    let login_body: Value = login_response\n        .json()\n        .await\n        .expect(\"Falha ao ler resposta de login\");\n\n    // Extrair token\n    login_body[\"data\"][\"access_token\"]\n        .as_str()\n        .expect(\"Token não encontrado na resposta\")\n        .to_string()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","middleware_auth_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n#[tokio::test]\nasync fn test_auth_middleware_token_expiration() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Token expirado (exp está no passado)\n    let expired_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n\n    // Act - Tentar acessar uma rota protegida com token expirado\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", expired_token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_auth_middleware_malformed_token() {\n    // Arrange\n    let app = setup_test_app().await;\n    let client = reqwest::Client::new();\n\n    // Token malformado (não é um JWT válido)\n    let malformed_token = \"isto_nao_e_um_token_jwt_valido\";\n\n    // Act - Tentar acessar uma rota protegida com token malformado\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", malformed_token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_auth_middleware_missing_bearer() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Enviar token sem o prefixo \"Bearer \"\n    let response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, token) // Token sem o prefixo Bearer\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição\");\n\n    // Assert\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::UNAUTHORIZED);\n    assert_eq!(body[\"error\"][\"status\"], 401);\n    assert!(body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"Formato de token inválido\"));\n}\n\n#[tokio::test]\nasync fn test_auth_middleware_access_multiple_protected_routes() {\n    // Arrange\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Act - Acessar a primeira rota protegida\n    let response1 = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Clean Code\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar primeira requisição\");\n\n    // Assert para a primeira rota\n    assert_eq!(response1.status(), StatusCode::OK);\n\n    // Act - Acessar a mesma rota protegida novamente com o mesmo token\n    let response2 = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Domain-Driven Design\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar segunda requisição\");\n\n    // Assert para a segunda rota\n    assert_eq!(response2.status(), StatusCode::OK);\n\n    // Verificar que os dados retornados são diferentes (consultas diferentes)\n    let body1: Value = response1\n        .json()\n        .await\n        .expect(\"Falha ao ler primeira resposta\");\n    let body2: Value = response2\n        .json()\n        .await\n        .expect(\"Falha ao ler segunda resposta\");\n\n    // Verificar que ambas as respostas têm o status de sucesso\n    assert_eq!(body1[\"status\"], \"success\");\n    assert_eq!(body2[\"status\"], \"success\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mikhael","desktop","usp","bcc","5s","troca-livros","troca-livros-backend","tests","remove_book_offered_test.rs"],"content":"mod common;\n\nuse crate::common::test_utils::{get_auth_token, setup_test_app};\nuse reqwest::{header, StatusCode};\nuse serde_json::{json, Value};\n\n\n#[tokio::test]\nasync fn test_remove_book_from_offered() {\n    // Arrange - Configurar o aplicativo de teste e autenticar\n    let app = setup_test_app().await;\n    let token = get_auth_token(\u0026app).await;\n    let client = reqwest::Client::new();\n\n    // Primeiro, vamos buscar um livro para obter um ID válido\n    let search_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/search\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"query\": \"Domain-Driven Design\"\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição de busca\");\n\n    let search_body: Value = search_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de busca\");\n\n    let books = search_body[\"data\"].as_array().unwrap();\n    assert!(!books.is_empty(), \"A busca deve retornar pelo menos um livro\");\n\n    let google_id = books[0][\"google_id\"].as_str().unwrap();\n\n    // Adicionar o livro à lista de possuídos\n    let add_response = client\n        .post(\u0026format!(\"http://localhost:{}/api/books/offered\", app.port))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .json(\u0026json!({\n            \"google_id\": google_id\n        }))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para adicionar livro\");\n\n    let add_body: Value = add_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta de adição\");\n\n    let book_id = add_body[\"data\"][\"book_id\"].as_str().unwrap();\n\n    // Act - Remover o livro da lista de possuídos\n    let response = client\n        .delete(\u0026format!(\n            \"http://localhost:{}/api/books/offered/{}\",\n            app.port, book_id\n        ))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .send()\n        .await\n        .expect(\"Falha ao enviar requisição para remover livro\");\n\n    // Assert - Verificar o resultado\n    let status = response.status();\n    let body: Value = response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da resposta\");\n\n    assert_eq!(status, StatusCode::OK);\n    assert_eq!(body[\"status\"], \"success\");\n    assert_eq!(\n        body[\"message\"],\n        \"Livro removido da lista de possuídos com sucesso\"\n    );\n\n    // Tentar remover o mesmo livro novamente deve falhar\n    let second_delete_response = client\n        .delete(\u0026format!(\n            \"http://localhost:{}/api/books/offered/{}\",\n            app.port, book_id\n        ))\n        .header(header::AUTHORIZATION, format!(\"Bearer {}\", token))\n        .send()\n        .await\n        .expect(\"Falha ao enviar segunda requisição para remover livro\");\n\n    let second_delete_status = second_delete_response.status();\n    let second_delete_body: Value = second_delete_response\n        .json()\n        .await\n        .expect(\"Falha ao ler corpo da segunda resposta de remoção\");\n\n    assert_eq!(second_delete_status, StatusCode::BAD_REQUEST);\n    assert_eq!(second_delete_body[\"error\"][\"status\"], 400);\n    assert!(second_delete_body[\"error\"][\"message\"]\n        .as_str()\n        .unwrap()\n        .contains(\"não está na sua lista de possuídos\"));\n} ","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>